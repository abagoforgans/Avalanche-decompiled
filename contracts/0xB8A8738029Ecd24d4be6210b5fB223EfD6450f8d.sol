contract main {




// =====================  Runtime code  =====================


const totalSupply = 100000000 * 10^18


address owner;
mapping of uint256 stor1;
mapping of uint256 stor2;
mapping of uint256 allowance;
mapping of uint8 stor4;
array of address stor5;
uint256 stor6;
uint256 totalFees;
array of struct stor8;
array of struct stor9;
uint8 decimals;
array of address stor1546678032441257452667456735582814959992782782816731922691272282333561699760;

function totalFees() payable {
    return totalFees
}

function decimals() payable {
    return decimals
}

function owner() payable {
    return owner
}

function isExcluded(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor4[address(arg1)])
}

function allowance(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)]
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function decreaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if arg2 > allowance[msg.sender][address(arg1)]:
        revert with 0, 32, 37, 0x6545524332303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[165 len 27] >> 40, 0
    if allowance[msg.sender][address(arg1)] < arg2:
        revert with 0, 17
    if not msg.sender:
        revert with 0, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] - arg2
    emit Approval((allowance[msg.sender][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function increaseAllowance(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if allowance[msg.sender][address(arg1)] > !arg2:
        revert with 0, 17
    if allowance[msg.sender][address(arg1)] + arg2 < allowance[msg.sender][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] + arg2
    emit Approval((allowance[msg.sender][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function includeAccount(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not stor4[address(arg1)]:
        revert with 0, 'Account is not excluded'
    idx = 0
    while idx < stor5.length:
        mem[0] = 5
        if stor5[idx] != arg1:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if stor5.length < 1:
            revert with 0, 17
        if stor5.length - 1 >= stor5.length:
            revert with 0, 50
        if idx >= stor5.length:
            revert with 0, 50
        stor5[idx] = stor5[stor5.length]
        stor2[address(arg1)] = 0
        stor4[address(arg1)] = 0
        if not stor5.length:
            revert with 0, 49
        stor5[stor5.length] = 0
        stor5.length--
}

function name() payable {
    if bool(stor8.length):
        if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor8.length):
            if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor8.length):
                if 31 < uint255(stor8.length) * 0.5:
                    mem[128] = uint256(stor8.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor8.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor8[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor8.length), data=mem[128 len ceil32(uint255(stor8.length) * 0.5)])
                mem[128] = 256 * stor8.length.field_8
        else:
            if bool(stor8.length) == stor8.length.field_1 < 32:
                revert with 0, 34
            if stor8.length.field_1:
                if 31 < stor8.length.field_1:
                    mem[128] = uint256(stor8.field_0)
                    idx = 128
                    s = 0
                    while stor8.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor8[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor8.length), data=mem[128 len ceil32(uint255(stor8.length) * 0.5)])
                mem[128] = 256 * stor8.length.field_8
        mem[ceil32(uint255(stor8.length) * 0.5) + 192 len ceil32(uint255(stor8.length) * 0.5)] = mem[128 len ceil32(uint255(stor8.length) * 0.5)]
        if ceil32(uint255(stor8.length) * 0.5) > uint255(stor8.length) * 0.5:
            mem[ceil32(uint255(stor8.length) * 0.5) + (uint255(stor8.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor8.length), data=mem[128 len ceil32(uint255(stor8.length) * 0.5)], mem[(2 * ceil32(uint255(stor8.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor8.length) * 0.5)]), 
    if bool(stor8.length) == stor8.length.field_1 < 32:
        revert with 0, 34
    if bool(stor8.length):
        if bool(stor8.length) == uint255(stor8.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor8.length):
            if 31 < uint255(stor8.length) * 0.5:
                mem[128] = uint256(stor8.field_0)
                idx = 128
                s = 0
                while (uint255(stor8.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor8[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)])
            mem[128] = 256 * stor8.length.field_8
    else:
        if bool(stor8.length) == stor8.length.field_1 < 32:
            revert with 0, 34
        if stor8.length.field_1:
            if 31 < stor8.length.field_1:
                mem[128] = uint256(stor8.field_0)
                idx = 128
                s = 0
                while stor8.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor8[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)])
            mem[128] = 256 * stor8.length.field_8
    mem[ceil32(stor8.length.field_1) + 192 len ceil32(stor8.length.field_1)] = mem[128 len ceil32(stor8.length.field_1)]
    if ceil32(stor8.length.field_1) > stor8.length.field_1:
        mem[ceil32(stor8.length.field_1) + stor8.length.field_1 + 192] = 0
    return Array(len=stor8.length % 128, data=mem[128 len ceil32(stor8.length.field_1)], mem[(2 * ceil32(stor8.length.field_1)) + 192 len 2 * ceil32(stor8.length.field_1)]), 
}

function symbol() payable {
    if bool(stor9.length):
        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor9.length):
            if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor9.length):
                if 31 < uint255(stor9.length) * 0.5:
                    mem[128] = uint256(stor9.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor9.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor9[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor9.length), data=mem[128 len ceil32(uint255(stor9.length) * 0.5)])
                mem[128] = 256 * stor9.length.field_8
        else:
            if bool(stor9.length) == stor9.length.field_1 < 32:
                revert with 0, 34
            if stor9.length.field_1:
                if 31 < stor9.length.field_1:
                    mem[128] = uint256(stor9.field_0)
                    idx = 128
                    s = 0
                    while stor9.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor9[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor9.length), data=mem[128 len ceil32(uint255(stor9.length) * 0.5)])
                mem[128] = 256 * stor9.length.field_8
        mem[ceil32(uint255(stor9.length) * 0.5) + 192 len ceil32(uint255(stor9.length) * 0.5)] = mem[128 len ceil32(uint255(stor9.length) * 0.5)]
        if ceil32(uint255(stor9.length) * 0.5) > uint255(stor9.length) * 0.5:
            mem[ceil32(uint255(stor9.length) * 0.5) + (uint255(stor9.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor9.length), data=mem[128 len ceil32(uint255(stor9.length) * 0.5)], mem[(2 * ceil32(uint255(stor9.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor9.length) * 0.5)]), 
    if bool(stor9.length) == stor9.length.field_1 < 32:
        revert with 0, 34
    if bool(stor9.length):
        if bool(stor9.length) == uint255(stor9.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor9.length):
            if 31 < uint255(stor9.length) * 0.5:
                mem[128] = uint256(stor9.field_0)
                idx = 128
                s = 0
                while (uint255(stor9.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor9[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor9.length % 128, data=mem[128 len ceil32(stor9.length.field_1)])
            mem[128] = 256 * stor9.length.field_8
    else:
        if bool(stor9.length) == stor9.length.field_1 < 32:
            revert with 0, 34
        if stor9.length.field_1:
            if 31 < stor9.length.field_1:
                mem[128] = uint256(stor9.field_0)
                idx = 128
                s = 0
                while stor9.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor9[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor9.length % 128, data=mem[128 len ceil32(stor9.length.field_1)])
            mem[128] = 256 * stor9.length.field_8
    mem[ceil32(stor9.length.field_1) + 192 len ceil32(stor9.length.field_1)] = mem[128 len ceil32(stor9.length.field_1)]
    if ceil32(stor9.length.field_1) > stor9.length.field_1:
        mem[ceil32(stor9.length.field_1) + stor9.length.field_1 + 192] = 0
    return Array(len=stor9.length % 128, data=mem[128 len ceil32(stor9.length.field_1)], mem[(2 * ceil32(stor9.length.field_1)) + 192 len 2 * ceil32(stor9.length.field_1)]), 
}

function tokenFromReflection(uint256 arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    if arg1 > stor6:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = 100000000 * 10^18
    t = stor6
    while idx < stor5.length:
        mem[0] = stor5[idx]
        mem[32] = 1
        if stor1[stor5[idx]] > t:
            _65 = mem[64]
            mem[64] = mem[64] + 64
            mem[_65] = 26
            mem[_65 + 32] = 'SafeMath: division by zero'
            _77 = mem[64]
            mem[64] = mem[64] + 64
            mem[_77] = 26
            mem[_77 + 32] = 'SafeMath: division by zero'
            if stor6 / 100000000 * 10^18:
                return (arg1 / stor6 / 100000000 * 10^18)
            _83 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _83 + 68] = mem[idx + _77 + 32]
                idx = idx + 32
                continue 
            mem[_83 + 94] = 0
            revert with memory
              from mem[64]
               len _83 + -mem[64] + 100
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 2
        if stor2[stor5[idx]] > s:
            _69 = mem[64]
            mem[64] = mem[64] + 64
            mem[_69] = 26
            mem[_69 + 32] = 'SafeMath: division by zero'
            _85 = mem[64]
            mem[64] = mem[64] + 64
            mem[_85] = 26
            mem[_85 + 32] = 'SafeMath: division by zero'
            if stor6 / 100000000 * 10^18:
                return (arg1 / stor6 / 100000000 * 10^18)
            _89 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _89 + 68] = mem[idx + _85 + 32]
                idx = idx + 32
                continue 
            mem[_89 + 94] = 0
            revert with memory
              from mem[64]
               len _89 + -mem[64] + 100
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 1
        _68 = mem[64]
        mem[64] = mem[64] + 64
        mem[_68] = 30
        mem[_68 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor5[idx]] > t:
            _70 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _70 + 68] = mem[idx + _68 + 32]
                idx = idx + 32
                continue 
            mem[_70 + 98] = 0
            revert with memory
              from mem[64]
               len _70 + -mem[64] + 100
        if t < stor1[stor5[idx]]:
            revert with 0, 17
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 2
        _84 = mem[64]
        mem[64] = mem[64] + 64
        mem[_84] = 30
        mem[_84 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor5[idx]] <= s:
            if s < stor2[stor5[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor2[stor5[idx]]
            t = t - stor1[stor5[idx]]
            continue 
        _88 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _88 + 68] = mem[idx + _84 + 32]
            idx = idx + 32
            continue 
        mem[_88 + 98] = 0
        revert with memory
          from mem[64]
           len _88 + -mem[64] + 100
    if t < stor6 / 100000000 * 10^18:
        if not stor6 / 100000000 * 10^18:
            revert with 0, 'SafeMath: division by zero', 0
        return (arg1 / stor6 / 100000000 * 10^18)
    if not s:
        revert with 0, 'SafeMath: division by zero', 0
    if not t / s:
        revert with 0, 'SafeMath: division by zero', 0
    return (arg1 / t / s)
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor4[address(arg1)]:
        return stor2[address(arg1)]
    mem[0] = arg1
    mem[32] = 1
    if stor1[address(arg1)] > stor6:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = 100000000 * 10^18
    t = stor6
    while idx < stor5.length:
        mem[0] = stor5[idx]
        mem[32] = 1
        if stor1[stor5[idx]] > t:
            _70 = mem[64]
            mem[64] = mem[64] + 64
            mem[_70] = 26
            mem[_70 + 32] = 'SafeMath: division by zero'
            _82 = mem[64]
            mem[64] = mem[64] + 64
            mem[_82] = 26
            mem[_82 + 32] = 'SafeMath: division by zero'
            if stor6 / 100000000 * 10^18:
                return (stor1[address(arg1)] / stor6 / 100000000 * 10^18)
            _88 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _88 + 68] = mem[idx + _82 + 32]
                idx = idx + 32
                continue 
            mem[_88 + 94] = 0
            revert with memory
              from mem[64]
               len _88 + -mem[64] + 100
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 2
        if stor2[stor5[idx]] > s:
            _74 = mem[64]
            mem[64] = mem[64] + 64
            mem[_74] = 26
            mem[_74 + 32] = 'SafeMath: division by zero'
            _90 = mem[64]
            mem[64] = mem[64] + 64
            mem[_90] = 26
            mem[_90 + 32] = 'SafeMath: division by zero'
            if stor6 / 100000000 * 10^18:
                return (stor1[address(arg1)] / stor6 / 100000000 * 10^18)
            _94 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _94 + 68] = mem[idx + _90 + 32]
                idx = idx + 32
                continue 
            mem[_94 + 94] = 0
            revert with memory
              from mem[64]
               len _94 + -mem[64] + 100
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 1
        _73 = mem[64]
        mem[64] = mem[64] + 64
        mem[_73] = 30
        mem[_73 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor5[idx]] > t:
            _75 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _75 + 68] = mem[idx + _73 + 32]
                idx = idx + 32
                continue 
            mem[_75 + 98] = 0
            revert with memory
              from mem[64]
               len _75 + -mem[64] + 100
        if t < stor1[stor5[idx]]:
            revert with 0, 17
        if idx >= stor5.length:
            revert with 0, 50
        mem[0] = stor5[idx]
        mem[32] = 2
        _89 = mem[64]
        mem[64] = mem[64] + 64
        mem[_89] = 30
        mem[_89 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor5[idx]] <= s:
            if s < stor2[stor5[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor2[stor5[idx]]
            t = t - stor1[stor5[idx]]
            continue 
        _93 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _93 + 68] = mem[idx + _89 + 32]
            idx = idx + 32
            continue 
        mem[_93 + 98] = 0
        revert with memory
          from mem[64]
           len _93 + -mem[64] + 100
    if t < stor6 / 100000000 * 10^18:
        if not stor6 / 100000000 * 10^18:
            revert with 0, 'SafeMath: division by zero', 0
        return (stor1[address(arg1)] / stor6 / 100000000 * 10^18)
    if not s:
        revert with 0, 'SafeMath: division by zero', 0
    if not t / s:
        revert with 0, 'SafeMath: division by zero', 0
    return (stor1[address(arg1)] / t / s)
}

function excludeAccount(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor4[address(arg1)]:
        revert with 0, 'Account is not excluded'
    if stor1[address(arg1)]:
        mem[0] = arg1
        mem[32] = 1
        if stor1[address(arg1)] > stor6:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
        idx = 0
        s = 100000000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _73 = mem[64]
                mem[64] = mem[64] + 64
                mem[_73] = 26
                mem[_73 + 32] = 'SafeMath: division by zero'
                _85 = mem[64]
                mem[64] = mem[64] + 64
                mem[_85] = 26
                mem[_85 + 32] = 'SafeMath: division by zero'
                if stor6 / 100000000 * 10^18:
                    stor2[address(arg1)] = stor1[address(arg1)] / stor6 / 100000000 * 10^18
                    stor4[address(arg1)] = 1
                    stor5.length++
                    stor36B6[stor5.length] = arg1
                _91 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _91 + 68] = mem[idx + _85 + 32]
                    idx = idx + 32
                    continue 
                mem[_91 + 94] = 0
                revert with memory
                  from mem[64]
                   len _91 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] > s:
                _77 = mem[64]
                mem[64] = mem[64] + 64
                mem[_77] = 26
                mem[_77 + 32] = 'SafeMath: division by zero'
                _93 = mem[64]
                mem[64] = mem[64] + 64
                mem[_93] = 26
                mem[_93 + 32] = 'SafeMath: division by zero'
                if stor6 / 100000000 * 10^18:
                    stor2[address(arg1)] = stor1[address(arg1)] / stor6 / 100000000 * 10^18
                    stor4[address(arg1)] = 1
                    stor5.length++
                    stor36B6[stor5.length] = arg1
                _97 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _97 + 68] = mem[idx + _93 + 32]
                    idx = idx + 32
                    continue 
                mem[_97 + 94] = 0
                revert with memory
                  from mem[64]
                   len _97 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 1
            _76 = mem[64]
            mem[64] = mem[64] + 64
            mem[_76] = 30
            mem[_76 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor5[idx]] > t:
                _78 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _78 + 68] = mem[idx + _76 + 32]
                    idx = idx + 32
                    continue 
                mem[_78 + 98] = 0
                revert with memory
                  from mem[64]
                   len _78 + -mem[64] + 100
            if t < stor1[stor5[idx]]:
                revert with 0, 17
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            _92 = mem[64]
            mem[64] = mem[64] + 64
            mem[_92] = 30
            mem[_92 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor5[idx]] <= s:
                if s < stor2[stor5[idx]]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s - stor2[stor5[idx]]
                t = t - stor1[stor5[idx]]
                continue 
            _96 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _96 + 68] = mem[idx + _92 + 32]
                idx = idx + 32
                continue 
            mem[_96 + 98] = 0
            revert with memory
              from mem[64]
               len _96 + -mem[64] + 100
        if t < stor6 / 100000000 * 10^18:
            if not stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: division by zero', 0
            stor2[address(arg1)] = stor1[address(arg1)] / stor6 / 100000000 * 10^18
        else:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not t / s:
                revert with 0, 'SafeMath: division by zero', 0
            stor2[address(arg1)] = stor1[address(arg1)] / t / s
    stor4[address(arg1)] = 1
    stor5.length++
    stor36B6[stor5.length] = arg1
}

function reflectionFromToken(uint256 arg1, bool arg2) payable {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if arg1 > 100000000 * 10^18:
        revert with 0, 'Amount must be less than supply'
    mem[96] = 26
    mem[128] = 'SafeMath: division by zero'
    if arg2:
        if not arg1 / 100:
            mem[64] = 224
            mem[160] = 30
            mem[192] = 'SafeMath: subtraction overflow'
            if 0 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < 0:
                revert with 0, 17
            idx = 0
            s = 100000000 * 10^18
            t = stor6
            while idx < stor5.length:
                mem[0] = stor5[idx]
                mem[32] = 1
                if stor1[stor5[idx]] > t:
                    _534 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_534] = 26
                    mem[_534 + 32] = 'SafeMath: division by zero'
                    if not arg1:
                        return 0
                    if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _672 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_672] = 30
                    mem[_672 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor6 / 100000000 * 10^18:
                        if arg1 * stor6 / 100000000 * 10^18 < 0:
                            revert with 0, 17
                        return (arg1 * stor6 / 100000000 * 10^18)
                    _699 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _699 + 68] = mem[idx + _672 + 32]
                        idx = idx + 32
                        continue 
                    mem[_699 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _699 + -mem[64] + 100
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 2
                if stor2[stor5[idx]] > s:
                    _548 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_548] = 26
                    mem[_548 + 32] = 'SafeMath: division by zero'
                    if not arg1:
                        return 0
                    if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _700 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_700] = 30
                    mem[_700 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor6 / 100000000 * 10^18:
                        if arg1 * stor6 / 100000000 * 10^18 < 0:
                            revert with 0, 17
                        return (arg1 * stor6 / 100000000 * 10^18)
                    _718 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _718 + 68] = mem[idx + _700 + 32]
                        idx = idx + 32
                        continue 
                    mem[_718 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _718 + -mem[64] + 100
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 1
                _547 = mem[64]
                mem[64] = mem[64] + 64
                mem[_547] = 30
                mem[_547 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _554 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _554 + 68] = mem[idx + _547 + 32]
                        idx = idx + 32
                        continue 
                    mem[_554 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _554 + -mem[64] + 100
                if t < stor1[stor5[idx]]:
                    revert with 0, 17
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 2
                _600 = mem[64]
                mem[64] = mem[64] + 64
                mem[_600] = 30
                mem[_600 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    if s < stor2[stor5[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _608 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _608 + 68] = mem[idx + _600 + 32]
                    idx = idx + 32
                    continue 
                mem[_608 + 98] = 0
                revert with memory
                  from mem[64]
                   len _608 + -mem[64] + 100
            if t < stor6 / 100000000 * 10^18:
                if not arg1:
                    return 0
                if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor6 / 100000000 * 10^18 < 0:
                    revert with 0, 17
                return (arg1 * stor6 / 100000000 * 10^18)
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                return 0
            if arg1 and t / s > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < 0:
                revert with 0, 17
            return (arg1 * t / s)
        if arg1 / 100 and 15 > -1 / arg1 / 100:
            revert with 0, 17
        if not arg1 / 100:
            revert with 0, 18
        if 15 * arg1 / 100 / arg1 / 100 != 15:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 15 * arg1 / 100 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < 15 * arg1 / 100:
            revert with 0, 17
        idx = 0
        s = 100000000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _533 = mem[64]
                mem[64] = mem[64] + 64
                mem[_533] = 26
                mem[_533 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not 15 * arg1 / 100:
                        return 0
                    if 15 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg1 / 100:
                        revert with 0, 17
                    if not 15 * arg1 / 100:
                        revert with 0, 18
                    if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 / 15 * arg1 / 100 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _666 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_666] = 30
                    mem[_666 + 32] = 'SafeMath: subtraction overflow'
                    if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 <= 0:
                        if 0 < 15 * arg1 / 100 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        return (-15 * arg1 / 100 * stor6 / 100000000 * 10^18)
                    _696 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _696 + 68] = mem[idx + _666 + 32]
                        idx = idx + 32
                        continue 
                    mem[_696 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _696 + -mem[64] + 100
                if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 15 * arg1 / 100:
                    _665 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_665] = 30
                    mem[_665 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor6 / 100000000 * 10^18:
                        if arg1 * stor6 / 100000000 * 10^18 < 0:
                            revert with 0, 17
                        return (arg1 * stor6 / 100000000 * 10^18)
                    _695 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _695 + 68] = mem[idx + _665 + 32]
                        idx = idx + 32
                        continue 
                    mem[_695 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _695 + -mem[64] + 100
                if 15 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg1 / 100:
                    revert with 0, 17
                if not 15 * arg1 / 100:
                    revert with 0, 18
                if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 / 15 * arg1 / 100 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _751 = mem[64]
                mem[64] = mem[64] + 64
                mem[_751] = 30
                mem[_751 + 32] = 'SafeMath: subtraction overflow'
                if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 <= arg1 * stor6 / 100000000 * 10^18:
                    if arg1 * stor6 / 100000000 * 10^18 < 15 * arg1 / 100 * stor6 / 100000000 * 10^18:
                        revert with 0, 17
                    return ((arg1 * stor6 / 100000000 * 10^18) - (15 * arg1 / 100 * stor6 / 100000000 * 10^18))
                _789 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _789 + 68] = mem[idx + _751 + 32]
                    idx = idx + 32
                    continue 
                mem[_789 + 98] = 0
                revert with memory
                  from mem[64]
                   len _789 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] <= s:
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 1
                _545 = mem[64]
                mem[64] = mem[64] + 64
                mem[_545] = 30
                mem[_545 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _553 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _553 + 68] = mem[idx + _545 + 32]
                        idx = idx + 32
                        continue 
                    mem[_553 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _553 + -mem[64] + 100
                if t < stor1[stor5[idx]]:
                    revert with 0, 17
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 2
                _598 = mem[64]
                mem[64] = mem[64] + 64
                mem[_598] = 30
                mem[_598 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    if s < stor2[stor5[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _606 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _606 + 68] = mem[idx + _598 + 32]
                    idx = idx + 32
                    continue 
                mem[_606 + 98] = 0
                revert with memory
                  from mem[64]
                   len _606 + -mem[64] + 100
            _546 = mem[64]
            mem[64] = mem[64] + 64
            mem[_546] = 26
            mem[_546 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if not 15 * arg1 / 100:
                    return 0
                if 15 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg1 / 100:
                    revert with 0, 17
                if not 15 * arg1 / 100:
                    revert with 0, 18
                if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 / 15 * arg1 / 100 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _698 = mem[64]
                mem[64] = mem[64] + 64
                mem[_698] = 30
                mem[_698 + 32] = 'SafeMath: subtraction overflow'
                if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 <= 0:
                    if 0 < 15 * arg1 / 100 * stor6 / 100000000 * 10^18:
                        revert with 0, 17
                    return (-15 * arg1 / 100 * stor6 / 100000000 * 10^18)
                _717 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _717 + 68] = mem[idx + _698 + 32]
                    idx = idx + 32
                    continue 
                mem[_717 + 98] = 0
                revert with memory
                  from mem[64]
                   len _717 + -mem[64] + 100
            if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 15 * arg1 / 100:
                _697 = mem[64]
                mem[64] = mem[64] + 64
                mem[_697] = 30
                mem[_697 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= arg1 * stor6 / 100000000 * 10^18:
                    if arg1 * stor6 / 100000000 * 10^18 < 0:
                        revert with 0, 17
                    return (arg1 * stor6 / 100000000 * 10^18)
                _716 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _716 + 68] = mem[idx + _697 + 32]
                    idx = idx + 32
                    continue 
                mem[_716 + 98] = 0
                revert with memory
                  from mem[64]
                   len _716 + -mem[64] + 100
            if 15 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg1 / 100:
                revert with 0, 17
            if not 15 * arg1 / 100:
                revert with 0, 18
            if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 / 15 * arg1 / 100 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            _792 = mem[64]
            mem[64] = mem[64] + 64
            mem[_792] = 30
            mem[_792 + 32] = 'SafeMath: subtraction overflow'
            if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 <= arg1 * stor6 / 100000000 * 10^18:
                if arg1 * stor6 / 100000000 * 10^18 < 15 * arg1 / 100 * stor6 / 100000000 * 10^18:
                    revert with 0, 17
                return ((arg1 * stor6 / 100000000 * 10^18) - (15 * arg1 / 100 * stor6 / 100000000 * 10^18))
            _833 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _833 + 68] = mem[idx + _792 + 32]
                idx = idx + 32
                continue 
            mem[_833 + 98] = 0
            revert with memory
              from mem[64]
               len _833 + -mem[64] + 100
        if t < stor6 / 100000000 * 10^18:
            if not arg1:
                if not 15 * arg1 / 100:
                    return 0
                if 15 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg1 / 100:
                    revert with 0, 17
                if not 15 * arg1 / 100:
                    revert with 0, 18
                if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 / 15 * arg1 / 100 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < 15 * arg1 / 100 * stor6 / 100000000 * 10^18:
                    revert with 0, 17
                return (-15 * arg1 / 100 * stor6 / 100000000 * 10^18)
            if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 15 * arg1 / 100:
                if 0 > arg1 * stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor6 / 100000000 * 10^18 < 0:
                    revert with 0, 17
                return (arg1 * stor6 / 100000000 * 10^18)
            if 15 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg1 / 100:
                revert with 0, 17
            if not 15 * arg1 / 100:
                revert with 0, 18
            if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 / 15 * arg1 / 100 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 > arg1 * stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor6 / 100000000 * 10^18 < 15 * arg1 / 100 * stor6 / 100000000 * 10^18:
                revert with 0, 17
            return ((arg1 * stor6 / 100000000 * 10^18) - (15 * arg1 / 100 * stor6 / 100000000 * 10^18))
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not arg1:
            if not 15 * arg1 / 100:
                return 0
            if 15 * arg1 / 100 and t / s > -1 / 15 * arg1 / 100:
                revert with 0, 17
            if not 15 * arg1 / 100:
                revert with 0, 18
            if 15 * arg1 / 100 * t / s / 15 * arg1 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if 15 * arg1 / 100 * t / s > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < 15 * arg1 / 100 * t / s:
                revert with 0, 17
            return (-15 * arg1 / 100 * t / s)
        if arg1 and t / s > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * t / s / arg1 != t / s:
            revert with 0, 'SafeMath: multiplication overflow'
        if not 15 * arg1 / 100:
            if 0 > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < 0:
                revert with 0, 17
            return (arg1 * t / s)
        if 15 * arg1 / 100 and t / s > -1 / 15 * arg1 / 100:
            revert with 0, 17
        if not 15 * arg1 / 100:
            revert with 0, 18
        if 15 * arg1 / 100 * t / s / 15 * arg1 / 100 != t / s:
            revert with 0, 'SafeMath: multiplication overflow'
        if 15 * arg1 / 100 * t / s > arg1 * t / s:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 * t / s < 15 * arg1 / 100 * t / s:
            revert with 0, 17
        return ((arg1 * t / s) - (15 * arg1 / 100 * t / s))
    if not arg1 / 100:
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 0 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < 0:
            revert with 0, 17
        idx = 0
        s = 100000000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _536 = mem[64]
                mem[64] = mem[64] + 64
                mem[_536] = 26
                mem[_536 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    return 0
                if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _684 = mem[64]
                mem[64] = mem[64] + 64
                mem[_684] = 30
                mem[_684 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= arg1 * stor6 / 100000000 * 10^18:
                    if arg1 * stor6 / 100000000 * 10^18 < 0:
                        revert with 0, 17
                    return (arg1 * stor6 / 100000000 * 10^18)
                _705 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _705 + 68] = mem[idx + _684 + 32]
                    idx = idx + 32
                    continue 
                mem[_705 + 98] = 0
                revert with memory
                  from mem[64]
                   len _705 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] > s:
                _552 = mem[64]
                mem[64] = mem[64] + 64
                mem[_552] = 26
                mem[_552 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    return 0
                if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _706 = mem[64]
                mem[64] = mem[64] + 64
                mem[_706] = 30
                mem[_706 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= arg1 * stor6 / 100000000 * 10^18:
                    if arg1 * stor6 / 100000000 * 10^18 < 0:
                        revert with 0, 17
                    return (arg1 * stor6 / 100000000 * 10^18)
                _724 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _724 + 68] = mem[idx + _706 + 32]
                    idx = idx + 32
                    continue 
                mem[_724 + 98] = 0
                revert with memory
                  from mem[64]
                   len _724 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 1
            _551 = mem[64]
            mem[64] = mem[64] + 64
            mem[_551] = 30
            mem[_551 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor5[idx]] > t:
                _556 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _556 + 68] = mem[idx + _551 + 32]
                    idx = idx + 32
                    continue 
                mem[_556 + 98] = 0
                revert with memory
                  from mem[64]
                   len _556 + -mem[64] + 100
            if t < stor1[stor5[idx]]:
                revert with 0, 17
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            _604 = mem[64]
            mem[64] = mem[64] + 64
            mem[_604] = 30
            mem[_604 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor5[idx]] <= s:
                if s < stor2[stor5[idx]]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s - stor2[stor5[idx]]
                t = t - stor1[stor5[idx]]
                continue 
            _612 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _612 + 68] = mem[idx + _604 + 32]
                idx = idx + 32
                continue 
            mem[_612 + 98] = 0
            revert with memory
              from mem[64]
               len _612 + -mem[64] + 100
        if t < stor6 / 100000000 * 10^18:
            if not arg1:
                return 0
            if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor6 / 100000000 * 10^18 < 0:
                revert with 0, 17
            return (arg1 * stor6 / 100000000 * 10^18)
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not arg1:
            return 0
        if arg1 and t / s > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * t / s / arg1 != t / s:
            revert with 0, 'SafeMath: multiplication overflow'
        if 0 > arg1 * t / s:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 * t / s < 0:
            revert with 0, 17
    else:
        if arg1 / 100 and 15 > -1 / arg1 / 100:
            revert with 0, 17
        if not arg1 / 100:
            revert with 0, 18
        if 15 * arg1 / 100 / arg1 / 100 != 15:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 15 * arg1 / 100 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < 15 * arg1 / 100:
            revert with 0, 17
        idx = 0
        s = 100000000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _535 = mem[64]
                mem[64] = mem[64] + 64
                mem[_535] = 26
                mem[_535 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not 15 * arg1 / 100:
                        return 0
                    if 15 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg1 / 100:
                        revert with 0, 17
                    if not 15 * arg1 / 100:
                        revert with 0, 18
                    if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 / 15 * arg1 / 100 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _678 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_678] = 30
                    mem[_678 + 32] = 'SafeMath: subtraction overflow'
                    if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 <= 0:
                        if 0 < 15 * arg1 / 100 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        else:
                            return 0
                    _702 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _702 + 68] = mem[idx + _678 + 32]
                        idx = idx + 32
                        continue 
                    mem[_702 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _702 + -mem[64] + 100
                if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 15 * arg1 / 100:
                    _677 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_677] = 30
                    mem[_677 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor6 / 100000000 * 10^18:
                        if arg1 * stor6 / 100000000 * 10^18 < 0:
                            revert with 0, 17
                        return (arg1 * stor6 / 100000000 * 10^18)
                    _701 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _701 + 68] = mem[idx + _677 + 32]
                        idx = idx + 32
                        continue 
                    mem[_701 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _701 + -mem[64] + 100
                if 15 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg1 / 100:
                    revert with 0, 17
                if not 15 * arg1 / 100:
                    revert with 0, 18
                if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 / 15 * arg1 / 100 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _761 = mem[64]
                mem[64] = mem[64] + 64
                mem[_761] = 30
                mem[_761 + 32] = 'SafeMath: subtraction overflow'
                if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 <= arg1 * stor6 / 100000000 * 10^18:
                    if arg1 * stor6 / 100000000 * 10^18 < 15 * arg1 / 100 * stor6 / 100000000 * 10^18:
                        revert with 0, 17
                    return (arg1 * stor6 / 100000000 * 10^18)
                _802 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _802 + 68] = mem[idx + _761 + 32]
                    idx = idx + 32
                    continue 
                mem[_802 + 98] = 0
                revert with memory
                  from mem[64]
                   len _802 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] <= s:
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 1
                _549 = mem[64]
                mem[64] = mem[64] + 64
                mem[_549] = 30
                mem[_549 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _555 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _555 + 68] = mem[idx + _549 + 32]
                        idx = idx + 32
                        continue 
                    mem[_555 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _555 + -mem[64] + 100
                if t < stor1[stor5[idx]]:
                    revert with 0, 17
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 2
                _602 = mem[64]
                mem[64] = mem[64] + 64
                mem[_602] = 30
                mem[_602 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    if s < stor2[stor5[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _610 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _610 + 68] = mem[idx + _602 + 32]
                    idx = idx + 32
                    continue 
                mem[_610 + 98] = 0
                revert with memory
                  from mem[64]
                   len _610 + -mem[64] + 100
            _550 = mem[64]
            mem[64] = mem[64] + 64
            mem[_550] = 26
            mem[_550 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if not 15 * arg1 / 100:
                    return 0
                if 15 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg1 / 100:
                    revert with 0, 17
                if not 15 * arg1 / 100:
                    revert with 0, 18
                if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 / 15 * arg1 / 100 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _704 = mem[64]
                mem[64] = mem[64] + 64
                mem[_704] = 30
                mem[_704 + 32] = 'SafeMath: subtraction overflow'
                if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 <= 0:
                    if 0 < 15 * arg1 / 100 * stor6 / 100000000 * 10^18:
                        revert with 0, 17
                    else:
                        return 0
                _723 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _723 + 68] = mem[idx + _704 + 32]
                    idx = idx + 32
                    continue 
                mem[_723 + 98] = 0
                revert with memory
                  from mem[64]
                   len _723 + -mem[64] + 100
            if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 15 * arg1 / 100:
                _703 = mem[64]
                mem[64] = mem[64] + 64
                mem[_703] = 30
                mem[_703 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= arg1 * stor6 / 100000000 * 10^18:
                    if arg1 * stor6 / 100000000 * 10^18 < 0:
                        revert with 0, 17
                    return (arg1 * stor6 / 100000000 * 10^18)
                _722 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _722 + 68] = mem[idx + _703 + 32]
                    idx = idx + 32
                    continue 
                mem[_722 + 98] = 0
                revert with memory
                  from mem[64]
                   len _722 + -mem[64] + 100
            if 15 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg1 / 100:
                revert with 0, 17
            if not 15 * arg1 / 100:
                revert with 0, 18
            if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 / 15 * arg1 / 100 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            _805 = mem[64]
            mem[64] = mem[64] + 64
            mem[_805] = 30
            mem[_805 + 32] = 'SafeMath: subtraction overflow'
            if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 <= arg1 * stor6 / 100000000 * 10^18:
                if arg1 * stor6 / 100000000 * 10^18 < 15 * arg1 / 100 * stor6 / 100000000 * 10^18:
                    revert with 0, 17
                return (arg1 * stor6 / 100000000 * 10^18)
            _839 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _839 + 68] = mem[idx + _805 + 32]
                idx = idx + 32
                continue 
            mem[_839 + 98] = 0
            revert with memory
              from mem[64]
               len _839 + -mem[64] + 100
        if t < stor6 / 100000000 * 10^18:
            if not arg1:
                if 15 * arg1 / 100:
                    if 15 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg1 / 100:
                        revert with 0, 17
                    if not 15 * arg1 / 100:
                        revert with 0, 18
                    if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 / 15 * arg1 / 100 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 15 * arg1 / 100 * stor6 / 100000000 * 10^18:
                        revert with 0, 17
                    else:
                        return 0
                else:
                    return 0
            if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 15 * arg1 / 100:
                if 0 > arg1 * stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor6 / 100000000 * 10^18 < 0:
                    revert with 0, 17
            else:
                if 15 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg1 / 100:
                    revert with 0, 17
                if not 15 * arg1 / 100:
                    revert with 0, 18
                if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 / 15 * arg1 / 100 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 > arg1 * stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor6 / 100000000 * 10^18 < 15 * arg1 / 100 * stor6 / 100000000 * 10^18:
                    revert with 0, 17
            return (arg1 * stor6 / 100000000 * 10^18)
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not arg1:
            if 15 * arg1 / 100:
                if 15 * arg1 / 100 and t / s > -1 / 15 * arg1 / 100:
                    revert with 0, 17
                if not 15 * arg1 / 100:
                    revert with 0, 18
                if 15 * arg1 / 100 * t / s / 15 * arg1 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 15 * arg1 / 100 * t / s > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < 15 * arg1 / 100 * t / s:
                    revert with 0, 17
                else:
                    return 0
            else:
                return 0
        if arg1 and t / s > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * t / s / arg1 != t / s:
            revert with 0, 'SafeMath: multiplication overflow'
        if not 15 * arg1 / 100:
            if 0 > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < 0:
                revert with 0, 17
        else:
            if 15 * arg1 / 100 and t / s > -1 / 15 * arg1 / 100:
                revert with 0, 17
            if not 15 * arg1 / 100:
                revert with 0, 18
            if 15 * arg1 / 100 * t / s / 15 * arg1 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if 15 * arg1 / 100 * t / s > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < 15 * arg1 / 100 * t / s:
                revert with 0, 17
    return (arg1 * t / s)
}

function reflect(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    mem[0] = msg.sender
    mem[32] = 4
    if stor4[msg.sender]:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Excluded addresses cannot call this function'
    mem[96] = 26
    mem[128] = 'SafeMath: division by zero'
    if not arg1 / 100:
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 0 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < 0:
            revert with 0, 17
        idx = 0
        s = 100000000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _606 = mem[64]
                mem[64] = mem[64] + 64
                mem[_606] = 26
                mem[_606 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    _655 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_655] = 30
                    mem[_655 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = msg.sender
                    mem[32] = 1
                    _703 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_703] = 30
                    mem[_703 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor1[address(msg.sender)]:
                        _726 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _726 + 68] = mem[idx + _703 + 32]
                            idx = idx + 32
                            continue 
                        mem[_726 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _726 + -mem[64] + 100
                    if stor1[address(msg.sender)] < 0:
                        revert with 0, 17
                    mem[0] = msg.sender
                    mem[32] = 1
                    _816 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_816] = 30
                    mem[_816 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor6:
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > !arg1:
                            revert with 0, 17
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _852 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _852 + 68] = mem[idx + _816 + 32]
                        idx = idx + 32
                        continue 
                    mem[_852 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _852 + -mem[64] + 100
                if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _680 = mem[64]
                mem[64] = mem[64] + 64
                mem[_680] = 30
                mem[_680 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor6 / 100000000 * 10^18:
                    _690 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _690 + 68] = mem[idx + _680 + 32]
                        idx = idx + 32
                        continue 
                    mem[_690 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _690 + -mem[64] + 100
                if arg1 * stor6 / 100000000 * 10^18 < 0:
                    revert with 0, 17
                mem[0] = msg.sender
                mem[32] = 1
                _782 = mem[64]
                mem[64] = mem[64] + 64
                mem[_782] = 30
                mem[_782 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                    _815 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _815 + 68] = mem[idx + _782 + 32]
                        idx = idx + 32
                        continue 
                    mem[_815 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _815 + -mem[64] + 100
                if stor1[address(msg.sender)] < arg1 * stor6 / 100000000 * 10^18:
                    revert with 0, 17
                mem[0] = msg.sender
                mem[32] = 1
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100000000 * 10^18
                _932 = mem[64]
                mem[64] = mem[64] + 64
                mem[_932] = 30
                mem[_932 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 100000000 * 10^18 <= stor6:
                    if stor6 < arg1 * stor6 / 100000000 * 10^18:
                        revert with 0, 17
                    stor6 += -1 * arg1 * stor6 / 100000000 * 10^18
                    if totalFees > !arg1:
                        revert with 0, 17
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _967 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _967 + 68] = mem[idx + _932 + 32]
                    idx = idx + 32
                    continue 
                mem[_967 + 98] = 0
                revert with memory
                  from mem[64]
                   len _967 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] <= s:
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 1
                _613 = mem[64]
                mem[64] = mem[64] + 64
                mem[_613] = 30
                mem[_613 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _616 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _616 + 68] = mem[idx + _613 + 32]
                        idx = idx + 32
                        continue 
                    mem[_616 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _616 + -mem[64] + 100
                if t < stor1[stor5[idx]]:
                    revert with 0, 17
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 2
                _640 = mem[64]
                mem[64] = mem[64] + 64
                mem[_640] = 30
                mem[_640 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    if s < stor2[stor5[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _644 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _644 + 68] = mem[idx + _640 + 32]
                    idx = idx + 32
                    continue 
                mem[_644 + 98] = 0
                revert with memory
                  from mem[64]
                   len _644 + -mem[64] + 100
            _614 = mem[64]
            mem[64] = mem[64] + 64
            mem[_614] = 26
            mem[_614 + 32] = 'SafeMath: division by zero'
            if not arg1:
                _664 = mem[64]
                mem[64] = mem[64] + 64
                mem[_664] = 30
                mem[_664 + 32] = 'SafeMath: subtraction overflow'
                mem[0] = msg.sender
                mem[32] = 1
                _727 = mem[64]
                mem[64] = mem[64] + 64
                mem[_727] = 30
                mem[_727 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor1[address(msg.sender)]:
                    _749 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _749 + 68] = mem[idx + _727 + 32]
                        idx = idx + 32
                        continue 
                    mem[_749 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _749 + -mem[64] + 100
                if stor1[address(msg.sender)] < 0:
                    revert with 0, 17
                mem[0] = msg.sender
                mem[32] = 1
                _854 = mem[64]
                mem[64] = mem[64] + 64
                mem[_854] = 30
                mem[_854 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor6:
                    if stor6 < 0:
                        revert with 0, 17
                    if totalFees > !arg1:
                        revert with 0, 17
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _887 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _887 + 68] = mem[idx + _854 + 32]
                    idx = idx + 32
                    continue 
                mem[_887 + 98] = 0
                revert with memory
                  from mem[64]
                   len _887 + -mem[64] + 100
            if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            _691 = mem[64]
            mem[64] = mem[64] + 64
            mem[_691] = 30
            mem[_691 + 32] = 'SafeMath: subtraction overflow'
            if 0 > arg1 * stor6 / 100000000 * 10^18:
                _704 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _704 + 68] = mem[idx + _691 + 32]
                    idx = idx + 32
                    continue 
                mem[_704 + 98] = 0
                revert with memory
                  from mem[64]
                   len _704 + -mem[64] + 100
            if arg1 * stor6 / 100000000 * 10^18 < 0:
                revert with 0, 17
            mem[0] = msg.sender
            mem[32] = 1
            _818 = mem[64]
            mem[64] = mem[64] + 64
            mem[_818] = 30
            mem[_818 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                _853 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _853 + 68] = mem[idx + _818 + 32]
                    idx = idx + 32
                    continue 
                mem[_853 + 98] = 0
                revert with memory
                  from mem[64]
                   len _853 + -mem[64] + 100
            if stor1[address(msg.sender)] < arg1 * stor6 / 100000000 * 10^18:
                revert with 0, 17
            mem[0] = msg.sender
            mem[32] = 1
            stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100000000 * 10^18
            _969 = mem[64]
            mem[64] = mem[64] + 64
            mem[_969] = 30
            mem[_969 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 100000000 * 10^18 <= stor6:
                if stor6 < arg1 * stor6 / 100000000 * 10^18:
                    revert with 0, 17
                stor6 += -1 * arg1 * stor6 / 100000000 * 10^18
                if totalFees > !arg1:
                    revert with 0, 17
                if totalFees + arg1 < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += arg1
            _995 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _995 + 68] = mem[idx + _969 + 32]
                idx = idx + 32
                continue 
            mem[_995 + 98] = 0
            revert with memory
              from mem[64]
               len _995 + -mem[64] + 100
        if t < stor6 / 100000000 * 10^18:
            if not arg1:
                if 0 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < 0:
                    revert with 0, 17
                if 0 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < 0:
                    revert with 0, 17
            else:
                if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor6 / 100000000 * 10^18 < 0:
                    revert with 0, 17
                if arg1 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < arg1 * stor6 / 100000000 * 10^18:
                    revert with 0, 17
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100000000 * 10^18
                if arg1 * stor6 / 100000000 * 10^18 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < arg1 * stor6 / 100000000 * 10^18:
                    revert with 0, 17
                stor6 += -1 * arg1 * stor6 / 100000000 * 10^18
        else:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if 0 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < 0:
                    revert with 0, 17
                if 0 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < 0:
                    revert with 0, 17
            else:
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if arg1 * t / s > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < arg1 * t / s:
                    revert with 0, 17
                stor1[address(msg.sender)] += -1 * arg1 * t / s
                if arg1 * t / s > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < arg1 * t / s:
                    revert with 0, 17
                stor6 += -1 * arg1 * t / s
    else:
        if arg1 / 100 and 15 > -1 / arg1 / 100:
            revert with 0, 17
        if not arg1 / 100:
            revert with 0, 18
        if 15 * arg1 / 100 / arg1 / 100 != 15:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[64] = 224
        mem[160] = 30
        mem[192] = 'SafeMath: subtraction overflow'
        if 15 * arg1 / 100 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < 15 * arg1 / 100:
            revert with 0, 17
        idx = 0
        s = 100000000 * 10^18
        t = stor6
        while idx < stor5.length:
            mem[0] = stor5[idx]
            mem[32] = 1
            if stor1[stor5[idx]] > t:
                _605 = mem[64]
                mem[64] = mem[64] + 64
                mem[_605] = 26
                mem[_605 + 32] = 'SafeMath: division by zero'
                if not arg1:
                    if not 15 * arg1 / 100:
                        _652 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_652] = 30
                        mem[_652 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = msg.sender
                        mem[32] = 1
                        _700 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_700] = 30
                        mem[_700 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(msg.sender)]:
                            _721 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _721 + 68] = mem[idx + _700 + 32]
                                idx = idx + 32
                                continue 
                            mem[_721 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _721 + -mem[64] + 100
                        if stor1[address(msg.sender)] < 0:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 1
                        _809 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_809] = 30
                        mem[_809 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > !arg1:
                                revert with 0, 17
                            if totalFees + arg1 < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += arg1
                        _845 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _845 + 68] = mem[idx + _809 + 32]
                            idx = idx + 32
                            continue 
                        mem[_845 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _845 + -mem[64] + 100
                    if 15 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg1 / 100:
                        revert with 0, 17
                    if not 15 * arg1 / 100:
                        revert with 0, 18
                    if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 / 15 * arg1 / 100 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _674 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_674] = 30
                    mem[_674 + 32] = 'SafeMath: subtraction overflow'
                    if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 > 0:
                        _687 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _687 + 68] = mem[idx + _674 + 32]
                            idx = idx + 32
                            continue 
                        mem[_687 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _687 + -mem[64] + 100
                    if 0 < 15 * arg1 / 100 * stor6 / 100000000 * 10^18:
                        revert with 0, 17
                    mem[0] = msg.sender
                    mem[32] = 1
                    _776 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_776] = 30
                    mem[_776 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor1[address(msg.sender)]:
                        _808 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _808 + 68] = mem[idx + _776 + 32]
                            idx = idx + 32
                            continue 
                        mem[_808 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _808 + -mem[64] + 100
                    if stor1[address(msg.sender)] < 0:
                        revert with 0, 17
                    mem[0] = msg.sender
                    mem[32] = 1
                    _923 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_923] = 30
                    mem[_923 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor6:
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > !arg1:
                            revert with 0, 17
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _958 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _958 + 68] = mem[idx + _923 + 32]
                        idx = idx + 32
                        continue 
                    mem[_958 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _958 + -mem[64] + 100
                if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 15 * arg1 / 100:
                    _673 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_673] = 30
                    mem[_673 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor6 / 100000000 * 10^18:
                        _686 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _686 + 68] = mem[idx + _673 + 32]
                            idx = idx + 32
                            continue 
                        mem[_686 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _686 + -mem[64] + 100
                    if arg1 * stor6 / 100000000 * 10^18 < 0:
                        revert with 0, 17
                    mem[0] = msg.sender
                    mem[32] = 1
                    _775 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_775] = 30
                    mem[_775 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                        _807 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _807 + 68] = mem[idx + _775 + 32]
                            idx = idx + 32
                            continue 
                        mem[_807 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _807 + -mem[64] + 100
                    if stor1[address(msg.sender)] < arg1 * stor6 / 100000000 * 10^18:
                        revert with 0, 17
                    mem[0] = msg.sender
                    mem[32] = 1
                    stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100000000 * 10^18
                    _921 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_921] = 30
                    mem[_921 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor6 / 100000000 * 10^18 <= stor6:
                        if stor6 < arg1 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor6 += -1 * arg1 * stor6 / 100000000 * 10^18
                        if totalFees > !arg1:
                            revert with 0, 17
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _957 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _957 + 68] = mem[idx + _921 + 32]
                        idx = idx + 32
                        continue 
                    mem[_957 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _957 + -mem[64] + 100
                if 15 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg1 / 100:
                    revert with 0, 17
                if not 15 * arg1 / 100:
                    revert with 0, 18
                if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 / 15 * arg1 / 100 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _720 = mem[64]
                mem[64] = mem[64] + 64
                mem[_720] = 30
                mem[_720 + 32] = 'SafeMath: subtraction overflow'
                if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 > arg1 * stor6 / 100000000 * 10^18:
                    _741 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _741 + 68] = mem[idx + _720 + 32]
                        idx = idx + 32
                        continue 
                    mem[_741 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _741 + -mem[64] + 100
                if arg1 * stor6 / 100000000 * 10^18 < 15 * arg1 / 100 * stor6 / 100000000 * 10^18:
                    revert with 0, 17
                mem[0] = msg.sender
                mem[32] = 1
                _882 = mem[64]
                mem[64] = mem[64] + 64
                mem[_882] = 30
                mem[_882 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                    _920 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _920 + 68] = mem[idx + _882 + 32]
                        idx = idx + 32
                        continue 
                    mem[_920 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _920 + -mem[64] + 100
                if stor1[address(msg.sender)] < arg1 * stor6 / 100000000 * 10^18:
                    revert with 0, 17
                mem[0] = msg.sender
                mem[32] = 1
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100000000 * 10^18
                _1032 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1032] = 30
                mem[_1032 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 100000000 * 10^18 <= stor6:
                    if stor6 < arg1 * stor6 / 100000000 * 10^18:
                        revert with 0, 17
                    stor6 += -1 * arg1 * stor6 / 100000000 * 10^18
                    if totalFees > !arg1:
                        revert with 0, 17
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _1062 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1062 + 68] = mem[idx + _1032 + 32]
                    idx = idx + 32
                    continue 
                mem[_1062 + 98] = 0
                revert with memory
                  from mem[64]
                   len _1062 + -mem[64] + 100
            if idx >= stor5.length:
                revert with 0, 50
            mem[0] = stor5[idx]
            mem[32] = 2
            if stor2[stor5[idx]] <= s:
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 1
                _611 = mem[64]
                mem[64] = mem[64] + 64
                mem[_611] = 30
                mem[_611 + 32] = 'SafeMath: subtraction overflow'
                if stor1[stor5[idx]] > t:
                    _615 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _615 + 68] = mem[idx + _611 + 32]
                        idx = idx + 32
                        continue 
                    mem[_615 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _615 + -mem[64] + 100
                if t < stor1[stor5[idx]]:
                    revert with 0, 17
                if idx >= stor5.length:
                    revert with 0, 50
                mem[0] = stor5[idx]
                mem[32] = 2
                _638 = mem[64]
                mem[64] = mem[64] + 64
                mem[_638] = 30
                mem[_638 + 32] = 'SafeMath: subtraction overflow'
                if stor2[stor5[idx]] <= s:
                    if s < stor2[stor5[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor2[stor5[idx]]
                    t = t - stor1[stor5[idx]]
                    continue 
                _642 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _642 + 68] = mem[idx + _638 + 32]
                    idx = idx + 32
                    continue 
                mem[_642 + 98] = 0
                revert with memory
                  from mem[64]
                   len _642 + -mem[64] + 100
            _612 = mem[64]
            mem[64] = mem[64] + 64
            mem[_612] = 26
            mem[_612 + 32] = 'SafeMath: division by zero'
            if not arg1:
                if not 15 * arg1 / 100:
                    _662 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_662] = 30
                    mem[_662 + 32] = 'SafeMath: subtraction overflow'
                    mem[0] = msg.sender
                    mem[32] = 1
                    _723 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_723] = 30
                    mem[_723 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor1[address(msg.sender)]:
                        _745 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _745 + 68] = mem[idx + _723 + 32]
                            idx = idx + 32
                            continue 
                        mem[_745 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _745 + -mem[64] + 100
                    if stor1[address(msg.sender)] < 0:
                        revert with 0, 17
                    mem[0] = msg.sender
                    mem[32] = 1
                    _848 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_848] = 30
                    mem[_848 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor6:
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > !arg1:
                            revert with 0, 17
                        if totalFees + arg1 < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += arg1
                    _884 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _884 + 68] = mem[idx + _848 + 32]
                        idx = idx + 32
                        continue 
                    mem[_884 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _884 + -mem[64] + 100
                if 15 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg1 / 100:
                    revert with 0, 17
                if not 15 * arg1 / 100:
                    revert with 0, 18
                if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 / 15 * arg1 / 100 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                _689 = mem[64]
                mem[64] = mem[64] + 64
                mem[_689] = 30
                mem[_689 + 32] = 'SafeMath: subtraction overflow'
                if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 > 0:
                    _702 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _702 + 68] = mem[idx + _689 + 32]
                        idx = idx + 32
                        continue 
                    mem[_702 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _702 + -mem[64] + 100
                if 0 < 15 * arg1 / 100 * stor6 / 100000000 * 10^18:
                    revert with 0, 17
                mem[0] = msg.sender
                mem[32] = 1
                _812 = mem[64]
                mem[64] = mem[64] + 64
                mem[_812] = 30
                mem[_812 + 32] = 'SafeMath: subtraction overflow'
                if 0 > stor1[address(msg.sender)]:
                    _847 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _847 + 68] = mem[idx + _812 + 32]
                        idx = idx + 32
                        continue 
                    mem[_847 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _847 + -mem[64] + 100
                if stor1[address(msg.sender)] < 0:
                    revert with 0, 17
                mem[0] = msg.sender
                mem[32] = 1
                _963 = mem[64]
                mem[64] = mem[64] + 64
                mem[_963] = 30
                mem[_963 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= stor6:
                    if stor6 < 0:
                        revert with 0, 17
                    if totalFees > !arg1:
                        revert with 0, 17
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _993 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _993 + 68] = mem[idx + _963 + 32]
                    idx = idx + 32
                    continue 
                mem[_993 + 98] = 0
                revert with memory
                  from mem[64]
                   len _993 + -mem[64] + 100
            if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            if not 15 * arg1 / 100:
                _688 = mem[64]
                mem[64] = mem[64] + 64
                mem[_688] = 30
                mem[_688 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor6 / 100000000 * 10^18:
                    _701 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _701 + 68] = mem[idx + _688 + 32]
                        idx = idx + 32
                        continue 
                    mem[_701 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _701 + -mem[64] + 100
                if arg1 * stor6 / 100000000 * 10^18 < 0:
                    revert with 0, 17
                mem[0] = msg.sender
                mem[32] = 1
                _811 = mem[64]
                mem[64] = mem[64] + 64
                mem[_811] = 30
                mem[_811 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                    _846 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _846 + 68] = mem[idx + _811 + 32]
                        idx = idx + 32
                        continue 
                    mem[_846 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _846 + -mem[64] + 100
                if stor1[address(msg.sender)] < arg1 * stor6 / 100000000 * 10^18:
                    revert with 0, 17
                mem[0] = msg.sender
                mem[32] = 1
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100000000 * 10^18
                _961 = mem[64]
                mem[64] = mem[64] + 64
                mem[_961] = 30
                mem[_961 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor6 / 100000000 * 10^18 <= stor6:
                    if stor6 < arg1 * stor6 / 100000000 * 10^18:
                        revert with 0, 17
                    stor6 += -1 * arg1 * stor6 / 100000000 * 10^18
                    if totalFees > !arg1:
                        revert with 0, 17
                    if totalFees + arg1 < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += arg1
                _992 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _992 + 68] = mem[idx + _961 + 32]
                    idx = idx + 32
                    continue 
                mem[_992 + 98] = 0
                revert with memory
                  from mem[64]
                   len _992 + -mem[64] + 100
            if 15 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg1 / 100:
                revert with 0, 17
            if not 15 * arg1 / 100:
                revert with 0, 18
            if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 / 15 * arg1 / 100 != stor6 / 100000000 * 10^18:
                revert with 0, 'SafeMath: multiplication overflow'
            _744 = mem[64]
            mem[64] = mem[64] + 64
            mem[_744] = 30
            mem[_744 + 32] = 'SafeMath: subtraction overflow'
            if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 > arg1 * stor6 / 100000000 * 10^18:
                _777 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _777 + 68] = mem[idx + _744 + 32]
                    idx = idx + 32
                    continue 
                mem[_777 + 98] = 0
                revert with memory
                  from mem[64]
                   len _777 + -mem[64] + 100
            if arg1 * stor6 / 100000000 * 10^18 < 15 * arg1 / 100 * stor6 / 100000000 * 10^18:
                revert with 0, 17
            mem[0] = msg.sender
            mem[32] = 1
            _925 = mem[64]
            mem[64] = mem[64] + 64
            mem[_925] = 30
            mem[_925 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                _960 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _960 + 68] = mem[idx + _925 + 32]
                    idx = idx + 32
                    continue 
                mem[_960 + 98] = 0
                revert with memory
                  from mem[64]
                   len _960 + -mem[64] + 100
            if stor1[address(msg.sender)] < arg1 * stor6 / 100000000 * 10^18:
                revert with 0, 17
            mem[0] = msg.sender
            mem[32] = 1
            stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100000000 * 10^18
            _1065 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1065] = 30
            mem[_1065 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * stor6 / 100000000 * 10^18 <= stor6:
                if stor6 < arg1 * stor6 / 100000000 * 10^18:
                    revert with 0, 17
                stor6 += -1 * arg1 * stor6 / 100000000 * 10^18
                if totalFees > !arg1:
                    revert with 0, 17
                if totalFees + arg1 < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += arg1
            _1088 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _1088 + 68] = mem[idx + _1065 + 32]
                idx = idx + 32
                continue 
            mem[_1088 + 98] = 0
            revert with memory
              from mem[64]
               len _1088 + -mem[64] + 100
        if t < stor6 / 100000000 * 10^18:
            if not arg1:
                if 15 * arg1 / 100:
                    if 15 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg1 / 100:
                        revert with 0, 17
                    if not 15 * arg1 / 100:
                        revert with 0, 18
                    if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 / 15 * arg1 / 100 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 15 * arg1 / 100 * stor6 / 100000000 * 10^18:
                        revert with 0, 17
                if 0 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < 0:
                    revert with 0, 17
                if 0 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < 0:
                    revert with 0, 17
            else:
                if arg1 and stor6 / 100000000 * 10^18 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor6 / 100000000 * 10^18 / arg1 != stor6 / 100000000 * 10^18:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 15 * arg1 / 100:
                    if 0 > arg1 * stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor6 / 100000000 * 10^18 < 0:
                        revert with 0, 17
                else:
                    if 15 * arg1 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg1 / 100:
                        revert with 0, 17
                    if not 15 * arg1 / 100:
                        revert with 0, 18
                    if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 / 15 * arg1 / 100 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 15 * arg1 / 100 * stor6 / 100000000 * 10^18 > arg1 * stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor6 / 100000000 * 10^18 < 15 * arg1 / 100 * stor6 / 100000000 * 10^18:
                        revert with 0, 17
                if arg1 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < arg1 * stor6 / 100000000 * 10^18:
                    revert with 0, 17
                stor1[address(msg.sender)] += -1 * arg1 * stor6 / 100000000 * 10^18
                if arg1 * stor6 / 100000000 * 10^18 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < arg1 * stor6 / 100000000 * 10^18:
                    revert with 0, 17
                stor6 += -1 * arg1 * stor6 / 100000000 * 10^18
        else:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if 15 * arg1 / 100:
                    if 15 * arg1 / 100 and t / s > -1 / 15 * arg1 / 100:
                        revert with 0, 17
                    if not 15 * arg1 / 100:
                        revert with 0, 18
                    if 15 * arg1 / 100 * t / s / 15 * arg1 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 15 * arg1 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < 15 * arg1 / 100 * t / s:
                        revert with 0, 17
                if 0 > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < 0:
                    revert with 0, 17
                if 0 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < 0:
                    revert with 0, 17
            else:
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not 15 * arg1 / 100:
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                else:
                    if 15 * arg1 / 100 and t / s > -1 / 15 * arg1 / 100:
                        revert with 0, 17
                    if not 15 * arg1 / 100:
                        revert with 0, 18
                    if 15 * arg1 / 100 * t / s / 15 * arg1 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 15 * arg1 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 15 * arg1 / 100 * t / s:
                        revert with 0, 17
                if arg1 * t / s > stor1[address(msg.sender)]:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor1[address(msg.sender)] < arg1 * t / s:
                    revert with 0, 17
                stor1[address(msg.sender)] += -1 * arg1 * t / s
                if arg1 * t / s > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < arg1 * t / s:
                    revert with 0, 17
                stor6 += -1 * arg1 * t / s
    if totalFees > !arg1:
        revert with 0, 17
    if totalFees + arg1 < totalFees:
        revert with 0, 'SafeMath: addition overflow'
    totalFees += arg1
}

function transfer(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
    if arg2 <= 0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Transfer amount must be greater than zero'
    if not stor4[address(msg.sender)]:
        if stor4[address(msg.sender)]:
            mem[0] = msg.sender
            mem[32] = 4
            if stor4[address(msg.sender)]:
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if not arg2 / 100:
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 0 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg2 < 0:
                        revert with 0, 17
                    idx = 0
                    s = 100000000 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _12301 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12301] = 26
                            mem[_12301 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _12994 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12994] = 30
                                mem[_12994 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _13686 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13686] = 30
                                mem[_13686 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _13975 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13975 + 68] = mem[idx + _13686 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13975 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13975 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1]
                                _17240 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17240] = 30
                                mem[_17240 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _17698 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17698 + 68] = mem[idx + _17240 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17698 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17698 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13271 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13271] = 30
                            mem[_13271 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                _13519 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13519 + 68] = mem[idx + _13271 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13519 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13519 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _14801 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14801] = 30
                            mem[_14801 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _15311 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15311 + 68] = mem[idx + _14801 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15311 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15311 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                            _18893 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18893] = 30
                            mem[_18893 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _19258 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19258 + 68] = mem[idx + _18893 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19258 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19258 + -mem[64] + 100
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _12392 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12392] = 30
                            mem[_12392 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _12451 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12451 + 68] = mem[idx + _12392 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12451 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12451 + -mem[64] + 100
                            if t < stor1[stor5[idx]]:
                                revert with 0, 17
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _12783 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12783] = 30
                            mem[_12783 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                if s < stor2[stor5[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _12843 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12843 + 68] = mem[idx + _12783 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12843 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12843 + -mem[64] + 100
                        _12393 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12393] = 26
                        mem[_12393 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            _13143 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13143] = 30
                            mem[_13143 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 1
                            _13976 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13976] = 30
                            mem[_13976 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _14292 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14292 + 68] = mem[idx + _13976 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14292 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14292 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > -1:
                                revert with 0, 17
                            if stor1[arg1] < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1]
                            _17699 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17699] = 30
                            mem[_17699 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _18095 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18095 + 68] = mem[idx + _17699 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18095 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18095 + -mem[64] + 100
                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _13520 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13520] = 30
                        mem[_13520 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                            _13687 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13687 + 68] = mem[idx + _13520 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13687 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13687 + -mem[64] + 100
                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 1
                        _15313 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15313] = 30
                        mem[_15313 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                            _15839 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15839 + 68] = mem[idx + _15313 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15839 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15839 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                        if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                            revert with 0, 17
                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                        _19260 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19260] = 30
                        mem[_19260 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _19702 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19702 + 68] = mem[idx + _19260 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19702 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19702 + -mem[64] + 100
                    if t < stor6 / 100000000 * 10^18:
                        if not arg2:
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > -1:
                                revert with 0, 17
                            if stor1[arg1] < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1]
                        else:
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                    else:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg2:
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > -1:
                                revert with 0, 17
                            if stor1[arg1] < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1]
                        else:
                            if arg2 and t / s > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * t / s < 0:
                                revert with 0, 17
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * t / s:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor1[arg1] > !(arg2 * t / s):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                    if 0 > stor6:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor6 < 0:
                        revert with 0, 17
                    if totalFees > -1:
                        revert with 0, 17
                    if totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    if arg2 / 100 and 15 > -1 / arg2 / 100:
                        revert with 0, 17
                    if not arg2 / 100:
                        revert with 0, 18
                    if 15 * arg2 / 100 / arg2 / 100 != 15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 15 * arg2 / 100 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg2 < 15 * arg2 / 100:
                        revert with 0, 17
                    idx = 0
                    s = 100000000 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _12300 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12300] = 26
                            mem[_12300 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 15 * arg2 / 100:
                                    _12991 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12991] = 30
                                    mem[_12991 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13683 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13683] = 30
                                    mem[_13683 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _13970 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13970 + 68] = mem[idx + _13683 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13970 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13970 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17229 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17229] = 30
                                    mem[_17229 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _17693 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17693 + 68] = mem[idx + _17229 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17693 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17693 + -mem[64] + 100
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13265 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13265] = 30
                                mem[_13265 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _13516 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13516 + 68] = mem[idx + _13265 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13516 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13516 + -mem[64] + 100
                                if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14795 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14795] = 30
                                mem[_14795 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _15305 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15305 + 68] = mem[idx + _14795 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15305 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15305 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _18883 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18883] = 30
                                mem[_18883 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19252 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19252 + 68] = mem[idx + _18883 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19252 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19252 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg2 / 100:
                                _13264 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13264] = 30
                                mem[_13264 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _13515 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13515 + 68] = mem[idx + _13264 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13515 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13515 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14794 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14794] = 30
                                mem[_14794 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _15304 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15304 + 68] = mem[idx + _14794 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15304 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15304 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                _18882 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18882] = 30
                                mem[_18882 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19251 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19251 + 68] = mem[idx + _18882 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19251 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19251 + -mem[64] + 100
                            if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                revert with 0, 17
                            if not 15 * arg2 / 100:
                                revert with 0, 18
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13969 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13969] = 30
                            mem[_13969 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                _14284 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14284 + 68] = mem[idx + _13969 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14284 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14284 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _16347 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16347] = 30
                            mem[_16347 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _16968 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16968 + 68] = mem[idx + _16347 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16968 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16968 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                            _20276 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20276] = 30
                            mem[_20276 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg2 / 100
                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _20648 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20648 + 68] = mem[idx + _20276 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20648 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20648 + -mem[64] + 100
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _12390 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12390] = 30
                            mem[_12390 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _12450 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12450 + 68] = mem[idx + _12390 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12450 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12450 + -mem[64] + 100
                            if t < stor1[stor5[idx]]:
                                revert with 0, 17
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _12781 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12781] = 30
                            mem[_12781 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                if s < stor2[stor5[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _12841 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12841 + 68] = mem[idx + _12781 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12841 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12841 + -mem[64] + 100
                        _12391 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12391] = 26
                        mem[_12391 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not 15 * arg2 / 100:
                                _13141 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13141] = 30
                                mem[_13141 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _13972 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13972] = 30
                                mem[_13972 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14288 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14288 + 68] = mem[idx + _13972 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14288 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14288 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1]
                                _17695 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17695] = 30
                                mem[_17695 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _18082 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18082 + 68] = mem[idx + _17695 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18082 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18082 + -mem[64] + 100
                            if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                revert with 0, 17
                            if not 15 * arg2 / 100:
                                revert with 0, 18
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13518 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13518] = 30
                            mem[_13518 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                _13685 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13685 + 68] = mem[idx + _13518 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13685 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13685 + -mem[64] + 100
                            if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _15308 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15308] = 30
                            mem[_15308 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _15835 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15835 + 68] = mem[idx + _15308 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15835 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15835 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                            _19255 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19255] = 30
                            mem[_19255 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg2 / 100
                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _19696 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19696 + 68] = mem[idx + _19255 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19696 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19696 + -mem[64] + 100
                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 15 * arg2 / 100:
                            _13517 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13517] = 30
                            mem[_13517 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                _13684 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13684 + 68] = mem[idx + _13517 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13684 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13684 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _15307 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15307] = 30
                            mem[_15307 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _15834 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15834 + 68] = mem[idx + _15307 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15834 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15834 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                            _19254 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19254] = 30
                            mem[_19254 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg2 / 100
                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _19695 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19695 + 68] = mem[idx + _19254 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19695 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19695 + -mem[64] + 100
                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                            revert with 0, 17
                        if not 15 * arg2 / 100:
                            revert with 0, 18
                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14287 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14287] = 30
                        mem[_14287 + 32] = 'SafeMath: subtraction overflow'
                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                            _14796 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14796 + 68] = mem[idx + _14287 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14796 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14796 + -mem[64] + 100
                        if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 1
                        _16971 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16971] = 30
                        mem[_16971 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                            _17586 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17586 + 68] = mem[idx + _16971 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17586 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17586 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                        if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                            revert with 0, 17
                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                        _20652 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20652] = 30
                        mem[_20652 + 32] = 'SafeMath: subtraction overflow'
                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                            if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                            if totalFees > !(15 * arg2 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg2 / 100
                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                            return 1
                        _21149 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21149 + 68] = mem[idx + _20652 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21149 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21149 + -mem[64] + 100
                    if t < stor6 / 100000000 * 10^18:
                        if not arg2:
                            if not 15 * arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1]
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                            else:
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                        else:
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg2 / 100:
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                            else:
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                    else:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg2:
                            if not 15 * arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1]
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                            else:
                                if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 15 * arg2 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 15 * arg2 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > !(-15 * arg2 / 100 * t / s):
                                    revert with 0, 17
                                if stor1[arg1] - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * t / s)
                                if 15 * arg2 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 15 * arg2 / 100 * t / s:
                                    revert with 0, 17
                                stor6 += -15 * arg2 / 100 * t / s
                        else:
                            if arg2 and t / s > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg2 / 100:
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 0, 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[arg1] > !(arg2 * t / s):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                            else:
                                if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 15 * arg2 / 100 * t / s > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 15 * arg2 / 100 * t / s:
                                    revert with 0, 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[arg1] > !((arg2 * t / s) - (15 * arg2 / 100 * t / s)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s)
                                if 15 * arg2 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 15 * arg2 / 100 * t / s:
                                    revert with 0, 17
                                stor6 += -15 * arg2 / 100 * t / s
                    if totalFees > !(15 * arg2 / 100):
                        revert with 0, 17
                    if totalFees + (15 * arg2 / 100) < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += 15 * arg2 / 100
                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
            else:
                mem[0] = arg1
                mem[32] = 4
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if stor4[address(arg1)]:
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 0:
                            revert with 0, 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _12303 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12303] = 26
                                mem[_12303 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _13000 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13000] = 30
                                    mem[_13000 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13694 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13694] = 30
                                    mem[_13694 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _13987 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13987 + 68] = mem[idx + _13694 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13987 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13987 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17264 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17264] = 30
                                    mem[_17264 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _17712 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17712 + 68] = mem[idx + _17264 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17712 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17712 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13283 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13283] = 30
                                mem[_13283 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _13525 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13525 + 68] = mem[idx + _13283 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13525 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13525 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14814 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14814] = 30
                                mem[_14814 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _15325 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15325 + 68] = mem[idx + _14814 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15325 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15325 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                _18911 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18911] = 30
                                mem[_18911 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19272 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19272 + 68] = mem[idx + _18911 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19272 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19272 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _12396 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12396] = 30
                                mem[_12396 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _12453 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12453 + 68] = mem[idx + _12396 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12453 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12453 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _12787 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12787] = 30
                                mem[_12787 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _12847 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12847 + 68] = mem[idx + _12787 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12847 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12847 + -mem[64] + 100
                            _12397 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12397] = 26
                            mem[_12397 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _13147 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13147] = 30
                                mem[_13147 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _13988 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13988] = 30
                                mem[_13988 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14305 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14305 + 68] = mem[idx + _13988 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14305 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14305 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1]
                                _17713 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17713] = 30
                                mem[_17713 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _18133 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18133 + 68] = mem[idx + _17713 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18133 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18133 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13526 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13526] = 30
                            mem[_13526 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                _13695 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13695 + 68] = mem[idx + _13526 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13695 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13695 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _15327 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15327] = 30
                            mem[_15327 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _15853 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15853 + 68] = mem[idx + _15327 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15853 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15853 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                            _19274 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19274] = 30
                            mem[_19274 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _19727 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19727 + 68] = mem[idx + _19274 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19727 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19727 + -mem[64] + 100
                        if t < stor6 / 100000000 * 10^18:
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1]
                            else:
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                        else:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1]
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 0, 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[arg1] > !(arg2 * t / s):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 / 100 and 15 > -1 / arg2 / 100:
                            revert with 0, 17
                        if not arg2 / 100:
                            revert with 0, 18
                        if 15 * arg2 / 100 / arg2 / 100 != 15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 15 * arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 15 * arg2 / 100:
                            revert with 0, 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _12302 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12302] = 26
                                mem[_12302 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 15 * arg2 / 100:
                                        _12997 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12997] = 30
                                        mem[_12997 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13691 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13691] = 30
                                        mem[_13691 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _13982 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13982 + 68] = mem[idx + _13691 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13982 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13982 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17253 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17253] = 30
                                        mem[_17253 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _17707 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17707 + 68] = mem[idx + _17253 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17707 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17707 + -mem[64] + 100
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13277 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13277] = 30
                                    mem[_13277 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _13522 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13522 + 68] = mem[idx + _13277 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13522 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13522 + -mem[64] + 100
                                    if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14808 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14808] = 30
                                    mem[_14808 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _15319 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15319 + 68] = mem[idx + _14808 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15319 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15319 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _18901 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18901] = 30
                                    mem[_18901 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19266 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19266 + 68] = mem[idx + _18901 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19266 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19266 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg2 / 100:
                                    _13276 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13276] = 30
                                    mem[_13276 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _13521 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13521 + 68] = mem[idx + _13276 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13521 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13521 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14807 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14807] = 30
                                    mem[_14807 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _15318 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15318 + 68] = mem[idx + _14807 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15318 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15318 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                    _18900 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18900] = 30
                                    mem[_18900 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19265 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19265 + 68] = mem[idx + _18900 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19265 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19265 + -mem[64] + 100
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13981 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13981] = 30
                                mem[_13981 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    _14297 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14297 + 68] = mem[idx + _13981 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14297 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14297 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16357 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16357] = 30
                                mem[_16357 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _16985 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _16985 + 68] = mem[idx + _16357 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16985 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16985 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _20287 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20287] = 30
                                mem[_20287 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20667 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20667 + 68] = mem[idx + _20287 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20667 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20667 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _12394 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12394] = 30
                                mem[_12394 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _12452 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12452 + 68] = mem[idx + _12394 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12452 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12452 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _12785 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12785] = 30
                                mem[_12785 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _12845 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12845 + 68] = mem[idx + _12785 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12845 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12845 + -mem[64] + 100
                            _12395 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12395] = 26
                            mem[_12395 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 15 * arg2 / 100:
                                    _13145 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13145] = 30
                                    mem[_13145 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13984 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13984] = 30
                                    mem[_13984 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14301 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14301 + 68] = mem[idx + _13984 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14301 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14301 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17709 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17709] = 30
                                    mem[_17709 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _18120 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18120 + 68] = mem[idx + _17709 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18120 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18120 + -mem[64] + 100
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13524 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13524] = 30
                                mem[_13524 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _13693 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13693 + 68] = mem[idx + _13524 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13693 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13693 + -mem[64] + 100
                                if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15322 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15322] = 30
                                mem[_15322 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _15849 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15849 + 68] = mem[idx + _15322 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15849 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15849 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _19269 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19269] = 30
                                mem[_19269 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19721 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19721 + 68] = mem[idx + _19269 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19721 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19721 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg2 / 100:
                                _13523 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13523] = 30
                                mem[_13523 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _13692 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13692 + 68] = mem[idx + _13523 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13692 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13692 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15321 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15321] = 30
                                mem[_15321 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _15848 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15848 + 68] = mem[idx + _15321 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15848 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15848 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                _19268 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19268] = 30
                                mem[_19268 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19720 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19720 + 68] = mem[idx + _19268 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19720 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19720 + -mem[64] + 100
                            if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                revert with 0, 17
                            if not 15 * arg2 / 100:
                                revert with 0, 18
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14300 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14300] = 30
                            mem[_14300 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                _14809 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14809 + 68] = mem[idx + _14300 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14809 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14809 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _16988 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16988] = 30
                            mem[_16988 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _17592 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17592 + 68] = mem[idx + _16988 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17592 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17592 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                            _20671 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20671] = 30
                            mem[_20671 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg2 / 100
                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _21159 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21159 + 68] = mem[idx + _20671 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21159 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21159 + -mem[64] + 100
                        if t < stor6 / 100000000 * 10^18:
                            if not arg2:
                                if not 15 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                            else:
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg2 / 100:
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                        else:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if not 15 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 15 * arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 15 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-15 * arg2 / 100 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * t / s)
                                    if 15 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * t / s
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 15 * arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 15 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !((arg2 * t / s) - (15 * arg2 / 100 * t / s)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s)
                                    if 15 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * t / s
                        if totalFees > !(15 * arg2 / 100):
                            revert with 0, 17
                        if totalFees + (15 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 15 * arg2 / 100
                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                else:
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 0:
                            revert with 0, 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _12305 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12305] = 26
                                mem[_12305 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _13006 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13006] = 30
                                    mem[_13006 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13702 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13702] = 30
                                    mem[_13702 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _13999 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13999 + 68] = mem[idx + _13702 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13999 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13999 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17288 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17288] = 30
                                    mem[_17288 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _17726 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17726 + 68] = mem[idx + _17288 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17726 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17726 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13295 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13295] = 30
                                mem[_13295 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _13531 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13531 + 68] = mem[idx + _13295 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13531 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13531 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14827 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14827] = 30
                                mem[_14827 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _15339 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15339 + 68] = mem[idx + _14827 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15339 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15339 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                _18929 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18929] = 30
                                mem[_18929 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19286 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19286 + 68] = mem[idx + _18929 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19286 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19286 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _12400 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12400] = 30
                                mem[_12400 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _12455 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12455 + 68] = mem[idx + _12400 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12455 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12455 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _12791 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12791] = 30
                                mem[_12791 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _12851 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12851 + 68] = mem[idx + _12791 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12851 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12851 + -mem[64] + 100
                            _12401 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12401] = 26
                            mem[_12401 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _13151 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13151] = 30
                                mem[_13151 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14000 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14000] = 30
                                mem[_14000 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14318 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14318 + 68] = mem[idx + _14000 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14318 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14318 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1]
                                _17727 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17727] = 30
                                mem[_17727 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _18171 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18171 + 68] = mem[idx + _17727 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18171 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18171 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13532 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13532] = 30
                            mem[_13532 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                _13703 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13703 + 68] = mem[idx + _13532 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13703 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13703 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _15341 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15341] = 30
                            mem[_15341 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _15867 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15867 + 68] = mem[idx + _15341 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15867 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15867 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                            _19288 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19288] = 30
                            mem[_19288 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _19752 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19752 + 68] = mem[idx + _19288 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19752 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19752 + -mem[64] + 100
                        if t < stor6 / 100000000 * 10^18:
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1]
                            else:
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                        else:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1]
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 0, 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[arg1] > !(arg2 * t / s):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 / 100 and 15 > -1 / arg2 / 100:
                            revert with 0, 17
                        if not arg2 / 100:
                            revert with 0, 18
                        if 15 * arg2 / 100 / arg2 / 100 != 15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 15 * arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 15 * arg2 / 100:
                            revert with 0, 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _12304 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12304] = 26
                                mem[_12304 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 15 * arg2 / 100:
                                        _13003 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13003] = 30
                                        mem[_13003 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13699 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13699] = 30
                                        mem[_13699 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _13994 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13994 + 68] = mem[idx + _13699 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13994 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13994 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17277 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17277] = 30
                                        mem[_17277 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _17721 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17721 + 68] = mem[idx + _17277 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17721 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17721 + -mem[64] + 100
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13289 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13289] = 30
                                    mem[_13289 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _13528 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13528 + 68] = mem[idx + _13289 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13528 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13528 + -mem[64] + 100
                                    if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14821 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14821] = 30
                                    mem[_14821 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _15333 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15333 + 68] = mem[idx + _14821 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15333 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15333 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _18919 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18919] = 30
                                    mem[_18919 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19280 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19280 + 68] = mem[idx + _18919 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19280 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19280 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg2 / 100:
                                    _13288 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13288] = 30
                                    mem[_13288 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _13527 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13527 + 68] = mem[idx + _13288 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13527 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13527 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14820 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14820] = 30
                                    mem[_14820 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _15332 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15332 + 68] = mem[idx + _14820 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15332 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15332 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                    _18918 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18918] = 30
                                    mem[_18918 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19279 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19279 + 68] = mem[idx + _18918 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19279 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19279 + -mem[64] + 100
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13993 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13993] = 30
                                mem[_13993 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    _14310 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14310 + 68] = mem[idx + _13993 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14310 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14310 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16367 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16367] = 30
                                mem[_16367 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _17002 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17002 + 68] = mem[idx + _16367 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17002 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17002 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _20298 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20298] = 30
                                mem[_20298 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20686 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20686 + 68] = mem[idx + _20298 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20686 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20686 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _12398 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12398] = 30
                                mem[_12398 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _12454 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12454 + 68] = mem[idx + _12398 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12454 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12454 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _12789 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12789] = 30
                                mem[_12789 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _12849 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12849 + 68] = mem[idx + _12789 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12849 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12849 + -mem[64] + 100
                            _12399 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12399] = 26
                            mem[_12399 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 15 * arg2 / 100:
                                    _13149 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13149] = 30
                                    mem[_13149 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13996 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13996] = 30
                                    mem[_13996 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14314 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14314 + 68] = mem[idx + _13996 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14314 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14314 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17723 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17723] = 30
                                    mem[_17723 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _18158 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18158 + 68] = mem[idx + _17723 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18158 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18158 + -mem[64] + 100
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13530 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13530] = 30
                                mem[_13530 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _13701 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13701 + 68] = mem[idx + _13530 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13701 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13701 + -mem[64] + 100
                                if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15336 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15336] = 30
                                mem[_15336 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _15863 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15863 + 68] = mem[idx + _15336 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15863 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15863 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _19283 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19283] = 30
                                mem[_19283 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19746 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19746 + 68] = mem[idx + _19283 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19746 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19746 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg2 / 100:
                                _13529 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13529] = 30
                                mem[_13529 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _13700 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13700 + 68] = mem[idx + _13529 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13700 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13700 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15335 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15335] = 30
                                mem[_15335 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _15862 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15862 + 68] = mem[idx + _15335 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15862 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15862 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                _19282 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19282] = 30
                                mem[_19282 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19745 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19745 + 68] = mem[idx + _19282 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19745 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19745 + -mem[64] + 100
                            if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                revert with 0, 17
                            if not 15 * arg2 / 100:
                                revert with 0, 18
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14313 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14313] = 30
                            mem[_14313 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                _14822 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14822 + 68] = mem[idx + _14313 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14822 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14822 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _17005 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17005] = 30
                            mem[_17005 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _17598 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17598 + 68] = mem[idx + _17005 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17598 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17598 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                            _20690 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20690] = 30
                            mem[_20690 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg2 / 100
                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _21169 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21169 + 68] = mem[idx + _20690 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21169 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21169 + -mem[64] + 100
                        if t < stor6 / 100000000 * 10^18:
                            if not arg2:
                                if not 15 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                            else:
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg2 / 100:
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                        else:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if not 15 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 15 * arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 15 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-15 * arg2 / 100 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * t / s)
                                    if 15 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * t / s
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 15 * arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 15 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !((arg2 * t / s) - (15 * arg2 / 100 * t / s)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s)
                                    if 15 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * t / s
                        if totalFees > !(15 * arg2 / 100):
                            revert with 0, 17
                        if totalFees + (15 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 15 * arg2 / 100
                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
        else:
            mem[0] = arg1
            mem[32] = 4
            if stor4[address(arg1)]:
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if not arg2 / 100:
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 0 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg2 < 0:
                        revert with 0, 17
                    idx = 0
                    s = 100000000 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _12313 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12313] = 26
                            mem[_12313 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _13030 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13030] = 30
                                mem[_13030 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _13734 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13734] = 30
                                mem[_13734 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14047 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14047 + 68] = mem[idx + _13734 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14047 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14047 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _19000 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19000] = 30
                                mem[_19000 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19335 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19335 + 68] = mem[idx + _19000 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19335 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19335 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13343 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13343] = 30
                            mem[_13343 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                _13555 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13555 + 68] = mem[idx + _13343 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13555 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13555 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _14879 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14879] = 30
                            mem[_14879 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _15395 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15395 + 68] = mem[idx + _14879 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15395 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15395 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor2[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > !(arg2 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                            _20351 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20351] = 30
                            mem[_20351 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _20765 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20765 + 68] = mem[idx + _20351 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20765 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20765 + -mem[64] + 100
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _12416 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12416] = 30
                            mem[_12416 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _12463 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12463 + 68] = mem[idx + _12416 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12463 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12463 + -mem[64] + 100
                            if t < stor1[stor5[idx]]:
                                revert with 0, 17
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _12807 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12807] = 30
                            mem[_12807 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                if s < stor2[stor5[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _12867 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12867 + 68] = mem[idx + _12807 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12867 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12867 + -mem[64] + 100
                        _12417 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12417] = 26
                        mem[_12417 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            _13167 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13167] = 30
                            mem[_13167 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 1
                            _14048 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14048] = 30
                            mem[_14048 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _14370 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14370 + 68] = mem[idx + _14048 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14370 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14370 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor2[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > -1:
                                revert with 0, 17
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _19336 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19336] = 30
                            mem[_19336 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _19871 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19871 + 68] = mem[idx + _19336 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19871 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19871 + -mem[64] + 100
                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _13556 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13556] = 30
                        mem[_13556 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                            _13735 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13735 + 68] = mem[idx + _13556 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13735 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13735 + -mem[64] + 100
                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 1
                        _15397 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15397] = 30
                        mem[_15397 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                            _15923 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15923 + 68] = mem[idx + _15397 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15923 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15923 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                        if stor2[address(arg1)] > !arg2:
                            revert with 0, 17
                        if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[address(arg1)] += arg2
                        if stor1[address(arg1)] > !(arg2 * stor6 / 100000000 * 10^18):
                            revert with 0, 17
                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                        _20767 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20767] = 30
                        mem[_20767 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _21228 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21228 + 68] = mem[idx + _20767 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21228 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21228 + -mem[64] + 100
                    if t < stor6 / 100000000 * 10^18:
                        if not arg2:
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor2[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > -1:
                                revert with 0, 17
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor2[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > !(arg2 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                    else:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg2:
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor2[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > -1:
                                revert with 0, 17
                            if stor1[address(arg1)] < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if arg2 and t / s > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * t / s < 0:
                                revert with 0, 17
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * t / s:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor2[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > !(arg2 * t / s):
                                revert with 0, 17
                            if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] += arg2 * t / s
                    if 0 > stor6:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if stor6 < 0:
                        revert with 0, 17
                    if totalFees > -1:
                        revert with 0, 17
                    if totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(arg2, msg.sender, arg1);
                else:
                    if arg2 / 100 and 15 > -1 / arg2 / 100:
                        revert with 0, 17
                    if not arg2 / 100:
                        revert with 0, 18
                    if 15 * arg2 / 100 / arg2 / 100 != 15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 15 * arg2 / 100 > arg2:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg2 < 15 * arg2 / 100:
                        revert with 0, 17
                    idx = 0
                    s = 100000000 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _12312 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12312] = 26
                            mem[_12312 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 15 * arg2 / 100:
                                    _13027 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13027] = 30
                                    mem[_13027 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13731 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13731] = 30
                                    mem[_13731 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14042 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14042 + 68] = mem[idx + _13731 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14042 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14042 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                    if stor1[address(arg1)] > -1:
                                        revert with 0, 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _18988 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18988] = 30
                                    mem[_18988 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19333 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19333 + 68] = mem[idx + _18988 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19333 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19333 + -mem[64] + 100
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13337 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13337] = 30
                                mem[_13337 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _13552 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13552 + 68] = mem[idx + _13337 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13552 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13552 + -mem[64] + 100
                                if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14873 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14873] = 30
                                mem[_14873 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _15389 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15389 + 68] = mem[idx + _14873 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15389 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15389 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                if stor1[address(arg1)] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg1)] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                _20341 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20341] = 30
                                mem[_20341 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20759 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20759 + 68] = mem[idx + _20341 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20759 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20759 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg2 / 100:
                                _13336 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13336] = 30
                                mem[_13336 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _13551 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13551 + 68] = mem[idx + _13336 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13551 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13551 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14872 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14872] = 30
                                mem[_14872 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _15388 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15388 + 68] = mem[idx + _14872 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15388 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15388 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                if stor1[address(arg1)] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                _20340 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20340] = 30
                                mem[_20340 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20758 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20758 + 68] = mem[idx + _20340 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20758 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20758 + -mem[64] + 100
                            if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                revert with 0, 17
                            if not 15 * arg2 / 100:
                                revert with 0, 18
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14041 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14041] = 30
                            mem[_14041 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                _14362 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14362 + 68] = mem[idx + _14041 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14362 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14362 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _16407 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16407] = 30
                            mem[_16407 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _17070 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17070 + 68] = mem[idx + _16407 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17070 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17070 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                            if stor1[address(arg1)] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                revert with 0, 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                            _21545 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21545] = 30
                            mem[_21545 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg2 / 100
                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _22015 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22015 + 68] = mem[idx + _21545 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22015 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22015 + -mem[64] + 100
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _12414 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12414] = 30
                            mem[_12414 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _12462 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12462 + 68] = mem[idx + _12414 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12462 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12462 + -mem[64] + 100
                            if t < stor1[stor5[idx]]:
                                revert with 0, 17
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _12805 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12805] = 30
                            mem[_12805 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                if s < stor2[stor5[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _12865 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12865 + 68] = mem[idx + _12805 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12865 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12865 + -mem[64] + 100
                        _12415 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12415] = 26
                        mem[_12415 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not 15 * arg2 / 100:
                                _13165 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13165] = 30
                                mem[_13165 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14044 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14044] = 30
                                mem[_14044 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14366 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14366 + 68] = mem[idx + _14044 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14366 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14366 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                if stor1[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _19334 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19334] = 30
                                mem[_19334 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19858 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19858 + 68] = mem[idx + _19334 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19858 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19858 + -mem[64] + 100
                            if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                revert with 0, 17
                            if not 15 * arg2 / 100:
                                revert with 0, 18
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13554 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13554] = 30
                            mem[_13554 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                _13733 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13733 + 68] = mem[idx + _13554 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13733 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13733 + -mem[64] + 100
                            if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _15392 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15392] = 30
                            mem[_15392 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _15919 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15919 + 68] = mem[idx + _15392 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15919 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15919 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                            if stor1[address(arg1)] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[address(arg1)] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                            _20762 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20762] = 30
                            mem[_20762 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg2 / 100
                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _21222 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21222 + 68] = mem[idx + _20762 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21222 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21222 + -mem[64] + 100
                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 15 * arg2 / 100:
                            _13553 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13553] = 30
                            mem[_13553 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                _13732 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13732 + 68] = mem[idx + _13553 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13732 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13732 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _15391 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15391] = 30
                            mem[_15391 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _15918 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15918 + 68] = mem[idx + _15391 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15918 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15918 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                            if stor1[address(arg1)] > !(arg2 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                            _20761 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20761] = 30
                            mem[_20761 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg2 / 100
                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _21221 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21221 + 68] = mem[idx + _20761 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21221 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21221 + -mem[64] + 100
                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                            revert with 0, 17
                        if not 15 * arg2 / 100:
                            revert with 0, 18
                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14365 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14365] = 30
                        mem[_14365 + 32] = 'SafeMath: subtraction overflow'
                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                            _14874 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14874 + 68] = mem[idx + _14365 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14874 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14874 + -mem[64] + 100
                        if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 1
                        _17073 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17073] = 30
                        mem[_17073 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                            _17622 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17622 + 68] = mem[idx + _17073 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17622 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17622 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                        if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                            revert with 0, 17
                        if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                        if stor1[address(arg1)] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                            revert with 0, 17
                        if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                        _22019 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22019] = 30
                        mem[_22019 + 32] = 'SafeMath: subtraction overflow'
                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                            if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                            if totalFees > !(15 * arg2 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg2 / 100
                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                            return 1
                        _22448 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _22448 + 68] = mem[idx + _22019 + 32]
                            idx = idx + 32
                            continue 
                        mem[_22448 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _22448 + -mem[64] + 100
                    if t < stor6 / 100000000 * 10^18:
                        if not arg2:
                            if not 15 * arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                if stor1[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                            else:
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                if stor1[address(arg1)] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg1)] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                        else:
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg2 / 100:
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                if stor1[address(arg1)] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                            else:
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                if stor1[address(arg1)] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                    else:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg2:
                            if not 15 * arg2 / 100:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                if stor1[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                            else:
                                if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 15 * arg2 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 15 * arg2 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                if stor1[address(arg1)] > !(-15 * arg2 / 100 * t / s):
                                    revert with 0, 17
                                if stor1[address(arg1)] - (15 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += -15 * arg2 / 100 * t / s
                                if 15 * arg2 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 15 * arg2 / 100 * t / s:
                                    revert with 0, 17
                                stor6 += -15 * arg2 / 100 * t / s
                        else:
                            if arg2 and t / s > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * t / s / arg2 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg2 / 100:
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 0, 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                if stor1[address(arg1)] > !(arg2 * t / s):
                                    revert with 0, 17
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                            else:
                                if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 15 * arg2 / 100 * t / s > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 15 * arg2 / 100 * t / s:
                                    revert with 0, 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                if stor1[address(arg1)] > !((arg2 * t / s) - (15 * arg2 / 100 * t / s)):
                                    revert with 0, 17
                                if stor1[address(arg1)] + (arg2 * t / s) - (15 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (15 * arg2 / 100 * t / s)
                                if 15 * arg2 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 15 * arg2 / 100 * t / s:
                                    revert with 0, 17
                                stor6 += -15 * arg2 / 100 * t / s
                    if totalFees > !(15 * arg2 / 100):
                        revert with 0, 17
                    if totalFees + (15 * arg2 / 100) < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += 15 * arg2 / 100
                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
            else:
                mem[0] = msg.sender
                mem[32] = 4
                if stor4[address(msg.sender)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 0:
                            revert with 0, 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _12307 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12307] = 26
                                mem[_12307 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _13012 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13012] = 30
                                    mem[_13012 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13710 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13710] = 30
                                    mem[_13710 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14011 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14011 + 68] = mem[idx + _13710 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14011 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14011 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17312 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17312] = 30
                                    mem[_17312 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _17740 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17740 + 68] = mem[idx + _17312 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17740 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17740 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13307 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13307] = 30
                                mem[_13307 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _13537 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13537 + 68] = mem[idx + _13307 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13537 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13537 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14840 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14840] = 30
                                mem[_14840 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _15353 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15353 + 68] = mem[idx + _14840 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15353 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15353 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                _18947 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18947] = 30
                                mem[_18947 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19300 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19300 + 68] = mem[idx + _18947 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19300 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19300 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _12404 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12404] = 30
                                mem[_12404 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _12457 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12457 + 68] = mem[idx + _12404 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12457 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12457 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _12795 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12795] = 30
                                mem[_12795 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _12855 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12855 + 68] = mem[idx + _12795 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12855 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12855 + -mem[64] + 100
                            _12405 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12405] = 26
                            mem[_12405 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _13155 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13155] = 30
                                mem[_13155 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14012 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14012] = 30
                                mem[_14012 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14331 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14331 + 68] = mem[idx + _14012 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14331 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14331 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1]
                                _17741 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17741] = 30
                                mem[_17741 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _18209 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18209 + 68] = mem[idx + _17741 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18209 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18209 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13538 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13538] = 30
                            mem[_13538 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                _13711 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13711 + 68] = mem[idx + _13538 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13711 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13711 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _15355 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15355] = 30
                            mem[_15355 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _15881 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15881 + 68] = mem[idx + _15355 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15881 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15881 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                            _19302 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19302] = 30
                            mem[_19302 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _19777 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19777 + 68] = mem[idx + _19302 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19777 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19777 + -mem[64] + 100
                        if t < stor6 / 100000000 * 10^18:
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1]
                            else:
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                        else:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1]
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 0, 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[arg1] > !(arg2 * t / s):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 / 100 and 15 > -1 / arg2 / 100:
                            revert with 0, 17
                        if not arg2 / 100:
                            revert with 0, 18
                        if 15 * arg2 / 100 / arg2 / 100 != 15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 15 * arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 15 * arg2 / 100:
                            revert with 0, 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _12306 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12306] = 26
                                mem[_12306 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 15 * arg2 / 100:
                                        _13009 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13009] = 30
                                        mem[_13009 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13707 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13707] = 30
                                        mem[_13707 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14006 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14006 + 68] = mem[idx + _13707 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14006 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14006 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17301 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17301] = 30
                                        mem[_17301 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _17735 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17735 + 68] = mem[idx + _17301 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17735 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17735 + -mem[64] + 100
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13301 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13301] = 30
                                    mem[_13301 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _13534 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13534 + 68] = mem[idx + _13301 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13534 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13534 + -mem[64] + 100
                                    if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14834 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14834] = 30
                                    mem[_14834 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _15347 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15347 + 68] = mem[idx + _14834 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15347 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15347 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _18937 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18937] = 30
                                    mem[_18937 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19294 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19294 + 68] = mem[idx + _18937 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19294 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19294 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg2 / 100:
                                    _13300 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13300] = 30
                                    mem[_13300 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _13533 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13533 + 68] = mem[idx + _13300 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13533 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13533 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14833 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14833] = 30
                                    mem[_14833 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _15346 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15346 + 68] = mem[idx + _14833 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15346 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15346 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                    _18936 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18936] = 30
                                    mem[_18936 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19293 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19293 + 68] = mem[idx + _18936 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19293 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19293 + -mem[64] + 100
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14005 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14005] = 30
                                mem[_14005 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    _14323 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14323 + 68] = mem[idx + _14005 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14323 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14323 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16377 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16377] = 30
                                mem[_16377 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _17019 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17019 + 68] = mem[idx + _16377 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17019 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17019 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _20309 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20309] = 30
                                mem[_20309 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20705 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20705 + 68] = mem[idx + _20309 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20705 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20705 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _12402 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12402] = 30
                                mem[_12402 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _12456 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12456 + 68] = mem[idx + _12402 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12456 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12456 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _12793 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12793] = 30
                                mem[_12793 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _12853 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12853 + 68] = mem[idx + _12793 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12853 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12853 + -mem[64] + 100
                            _12403 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12403] = 26
                            mem[_12403 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 15 * arg2 / 100:
                                    _13153 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13153] = 30
                                    mem[_13153 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14008 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14008] = 30
                                    mem[_14008 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14327 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14327 + 68] = mem[idx + _14008 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14327 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14327 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17737 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17737] = 30
                                    mem[_17737 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _18196 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18196 + 68] = mem[idx + _17737 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18196 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18196 + -mem[64] + 100
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13536 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13536] = 30
                                mem[_13536 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _13709 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13709 + 68] = mem[idx + _13536 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13709 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13709 + -mem[64] + 100
                                if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15350 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15350] = 30
                                mem[_15350 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _15877 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15877 + 68] = mem[idx + _15350 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15877 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15877 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _19297 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19297] = 30
                                mem[_19297 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19771 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19771 + 68] = mem[idx + _19297 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19771 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19771 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg2 / 100:
                                _13535 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13535] = 30
                                mem[_13535 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _13708 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13708 + 68] = mem[idx + _13535 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13708 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13708 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15349 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15349] = 30
                                mem[_15349 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _15876 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15876 + 68] = mem[idx + _15349 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15876 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15876 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                _19296 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19296] = 30
                                mem[_19296 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19770 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19770 + 68] = mem[idx + _19296 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19770 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19770 + -mem[64] + 100
                            if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                revert with 0, 17
                            if not 15 * arg2 / 100:
                                revert with 0, 18
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14326 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14326] = 30
                            mem[_14326 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                _14835 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14835 + 68] = mem[idx + _14326 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14835 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14835 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _17022 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17022] = 30
                            mem[_17022 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _17604 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17604 + 68] = mem[idx + _17022 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17604 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17604 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                            _20709 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20709] = 30
                            mem[_20709 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg2 / 100
                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _21179 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21179 + 68] = mem[idx + _20709 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21179 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21179 + -mem[64] + 100
                        if t < stor6 / 100000000 * 10^18:
                            if not arg2:
                                if not 15 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                            else:
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg2 / 100:
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                        else:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if not 15 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 15 * arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 15 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-15 * arg2 / 100 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * t / s)
                                    if 15 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * t / s
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 15 * arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 15 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !((arg2 * t / s) - (15 * arg2 / 100 * t / s)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s)
                                    if 15 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * t / s
                        if totalFees > !(15 * arg2 / 100):
                            revert with 0, 17
                        if totalFees + (15 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 15 * arg2 / 100
                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                else:
                    mem[0] = arg1
                    mem[32] = 4
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if stor4[address(arg1)]:
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 0:
                                revert with 0, 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _12309 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12309] = 26
                                    mem[_12309 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _13018 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13018] = 30
                                        mem[_13018 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13718 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13718] = 30
                                        mem[_13718 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14023 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14023 + 68] = mem[idx + _13718 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14023 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14023 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17336 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17336] = 30
                                        mem[_17336 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _17754 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17754 + 68] = mem[idx + _17336 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17754 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17754 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13319 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13319] = 30
                                    mem[_13319 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _13543 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13543 + 68] = mem[idx + _13319 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13543 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13543 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14853 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14853] = 30
                                    mem[_14853 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _15367 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15367 + 68] = mem[idx + _14853 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15367 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15367 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                    _18965 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18965] = 30
                                    mem[_18965 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _19314 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19314 + 68] = mem[idx + _18965 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19314 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19314 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _12408 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12408] = 30
                                    mem[_12408 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _12459 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12459 + 68] = mem[idx + _12408 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12459 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12459 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _12799 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12799] = 30
                                    mem[_12799 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _12859 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12859 + 68] = mem[idx + _12799 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12859 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12859 + -mem[64] + 100
                                _12409 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12409] = 26
                                mem[_12409 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _13159 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13159] = 30
                                    mem[_13159 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14024 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14024] = 30
                                    mem[_14024 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14344 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14344 + 68] = mem[idx + _14024 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14344 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14344 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17755 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17755] = 30
                                    mem[_17755 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _18247 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18247 + 68] = mem[idx + _17755 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18247 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18247 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13544 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13544] = 30
                                mem[_13544 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _13719 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13719 + 68] = mem[idx + _13544 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13719 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13719 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15369 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15369] = 30
                                mem[_15369 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _15895 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15895 + 68] = mem[idx + _15369 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15895 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15895 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                _19316 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19316] = 30
                                mem[_19316 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19802 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19802 + 68] = mem[idx + _19316 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19802 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19802 + -mem[64] + 100
                            if t < stor6 / 100000000 * 10^18:
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                else:
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                            else:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if arg2 / 100 and 15 > -1 / arg2 / 100:
                                revert with 0, 17
                            if not arg2 / 100:
                                revert with 0, 18
                            if 15 * arg2 / 100 / arg2 / 100 != 15:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 15 * arg2 / 100:
                                revert with 0, 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _12308 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12308] = 26
                                    mem[_12308 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 15 * arg2 / 100:
                                            _13015 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13015] = 30
                                            mem[_13015 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _13715 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13715] = 30
                                            mem[_13715 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _14018 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _14018 + 68] = mem[idx + _13715 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14018 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14018 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1]
                                            _17325 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17325] = 30
                                            mem[_17325 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(15 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (15 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 15 * arg2 / 100
                                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _17749 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17749 + 68] = mem[idx + _17325 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17749 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17749 + -mem[64] + 100
                                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _13313 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13313] = 30
                                        mem[_13313 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _13540 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13540 + 68] = mem[idx + _13313 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13540 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13540 + -mem[64] + 100
                                        if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14847 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14847] = 30
                                        mem[_14847 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _15361 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15361 + 68] = mem[idx + _14847 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15361 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15361 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        _18955 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18955] = 30
                                        mem[_18955 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                            if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19308 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19308 + 68] = mem[idx + _18955 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19308 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19308 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg2 / 100:
                                        _13312 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13312] = 30
                                        mem[_13312 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            _13539 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13539 + 68] = mem[idx + _13312 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13539 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13539 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14846 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14846] = 30
                                        mem[_14846 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _15360 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15360 + 68] = mem[idx + _14846 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15360 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15360 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                        _18954 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18954] = 30
                                        mem[_18954 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19307 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19307 + 68] = mem[idx + _18954 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19307 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19307 + -mem[64] + 100
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _14017 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14017] = 30
                                    mem[_14017 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        _14336 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14336 + 68] = mem[idx + _14017 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14336 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14336 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16387 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16387] = 30
                                    mem[_16387 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _17036 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17036 + 68] = mem[idx + _16387 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17036 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17036 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _20320 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20320] = 30
                                    mem[_20320 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20724 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20724 + 68] = mem[idx + _20320 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20724 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20724 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _12406 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12406] = 30
                                    mem[_12406 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _12458 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12458 + 68] = mem[idx + _12406 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12458 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12458 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _12797 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12797] = 30
                                    mem[_12797 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _12857 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12857 + 68] = mem[idx + _12797 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12857 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12857 + -mem[64] + 100
                                _12407 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12407] = 26
                                mem[_12407 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 15 * arg2 / 100:
                                        _13157 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13157] = 30
                                        mem[_13157 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14020 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14020] = 30
                                        mem[_14020 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14340 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14340 + 68] = mem[idx + _14020 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14340 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14340 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17751 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17751] = 30
                                        mem[_17751 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _18234 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18234 + 68] = mem[idx + _17751 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18234 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18234 + -mem[64] + 100
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13542 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13542] = 30
                                    mem[_13542 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _13717 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13717 + 68] = mem[idx + _13542 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13717 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13717 + -mem[64] + 100
                                    if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15364 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15364] = 30
                                    mem[_15364 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _15891 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15891 + 68] = mem[idx + _15364 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15891 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15891 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _19311 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19311] = 30
                                    mem[_19311 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19796 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19796 + 68] = mem[idx + _19311 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19796 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19796 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg2 / 100:
                                    _13541 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13541] = 30
                                    mem[_13541 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _13716 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13716 + 68] = mem[idx + _13541 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13716 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13716 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15363 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15363] = 30
                                    mem[_15363 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _15890 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15890 + 68] = mem[idx + _15363 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15890 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15890 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                    _19310 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19310] = 30
                                    mem[_19310 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19795 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19795 + 68] = mem[idx + _19310 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19795 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19795 + -mem[64] + 100
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14339 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14339] = 30
                                mem[_14339 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    _14848 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14848 + 68] = mem[idx + _14339 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14848 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14848 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17039 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17039] = 30
                                mem[_17039 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _17610 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17610 + 68] = mem[idx + _17039 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17610 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17610 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _20728 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20728] = 30
                                mem[_20728 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _21189 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21189 + 68] = mem[idx + _20728 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21189 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21189 + -mem[64] + 100
                            if t < stor6 / 100000000 * 10^18:
                                if not arg2:
                                    if not 15 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                else:
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg2 / 100:
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                            else:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if not 15 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 15 * arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 15 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-15 * arg2 / 100 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * t / s)
                                        if 15 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * t / s
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !(arg2 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 15 * arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 15 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !((arg2 * t / s) - (15 * arg2 / 100 * t / s)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s)
                                        if 15 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * t / s
                            if totalFees > !(15 * arg2 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg2 / 100
                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                    else:
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 0:
                                revert with 0, 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _12311 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12311] = 26
                                    mem[_12311 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _13024 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13024] = 30
                                        mem[_13024 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13726 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13726] = 30
                                        mem[_13726 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14035 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14035 + 68] = mem[idx + _13726 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14035 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14035 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17360 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17360] = 30
                                        mem[_17360 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _17768 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17768 + 68] = mem[idx + _17360 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17768 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17768 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13331 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13331] = 30
                                    mem[_13331 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _13549 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13549 + 68] = mem[idx + _13331 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13549 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13549 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14866 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14866] = 30
                                    mem[_14866 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _15381 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15381 + 68] = mem[idx + _14866 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15381 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15381 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                    _18983 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18983] = 30
                                    mem[_18983 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _19328 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19328 + 68] = mem[idx + _18983 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19328 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19328 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _12412 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12412] = 30
                                    mem[_12412 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _12461 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12461 + 68] = mem[idx + _12412 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12461 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12461 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _12803 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12803] = 30
                                    mem[_12803 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _12863 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12863 + 68] = mem[idx + _12803 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12863 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12863 + -mem[64] + 100
                                _12413 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12413] = 26
                                mem[_12413 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _13163 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13163] = 30
                                    mem[_13163 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14036 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14036] = 30
                                    mem[_14036 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14357 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14357 + 68] = mem[idx + _14036 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14357 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14357 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17769 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17769] = 30
                                    mem[_17769 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _18285 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18285 + 68] = mem[idx + _17769 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18285 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18285 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13550 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13550] = 30
                                mem[_13550 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _13727 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13727 + 68] = mem[idx + _13550 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13727 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13727 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15383 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15383] = 30
                                mem[_15383 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _15909 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15909 + 68] = mem[idx + _15383 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15909 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15909 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                _19330 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19330] = 30
                                mem[_19330 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19827 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19827 + 68] = mem[idx + _19330 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19827 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19827 + -mem[64] + 100
                            if t < stor6 / 100000000 * 10^18:
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                else:
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                            else:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if arg2 / 100 and 15 > -1 / arg2 / 100:
                                revert with 0, 17
                            if not arg2 / 100:
                                revert with 0, 18
                            if 15 * arg2 / 100 / arg2 / 100 != 15:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 15 * arg2 / 100:
                                revert with 0, 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _12310 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12310] = 26
                                    mem[_12310 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 15 * arg2 / 100:
                                            _13021 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13021] = 30
                                            mem[_13021 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _13723 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13723] = 30
                                            mem[_13723 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _14030 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _14030 + 68] = mem[idx + _13723 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14030 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14030 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1]
                                            _17349 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17349] = 30
                                            mem[_17349 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(15 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (15 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 15 * arg2 / 100
                                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _17763 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17763 + 68] = mem[idx + _17349 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17763 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17763 + -mem[64] + 100
                                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _13325 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13325] = 30
                                        mem[_13325 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _13546 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13546 + 68] = mem[idx + _13325 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13546 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13546 + -mem[64] + 100
                                        if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14860 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14860] = 30
                                        mem[_14860 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _15375 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15375 + 68] = mem[idx + _14860 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15375 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15375 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        _18973 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18973] = 30
                                        mem[_18973 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                            if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19322 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19322 + 68] = mem[idx + _18973 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19322 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19322 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg2 / 100:
                                        _13324 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13324] = 30
                                        mem[_13324 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            _13545 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13545 + 68] = mem[idx + _13324 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13545 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13545 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14859 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14859] = 30
                                        mem[_14859 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _15374 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15374 + 68] = mem[idx + _14859 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15374 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15374 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                        _18972 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18972] = 30
                                        mem[_18972 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19321 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19321 + 68] = mem[idx + _18972 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19321 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19321 + -mem[64] + 100
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _14029 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14029] = 30
                                    mem[_14029 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        _14349 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14349 + 68] = mem[idx + _14029 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14349 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14349 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16397 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16397] = 30
                                    mem[_16397 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _17053 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17053 + 68] = mem[idx + _16397 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17053 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17053 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _20331 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20331] = 30
                                    mem[_20331 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20743 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20743 + 68] = mem[idx + _20331 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20743 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20743 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _12410 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12410] = 30
                                    mem[_12410 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _12460 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12460 + 68] = mem[idx + _12410 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12460 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12460 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _12801 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12801] = 30
                                    mem[_12801 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _12861 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12861 + 68] = mem[idx + _12801 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12861 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12861 + -mem[64] + 100
                                _12411 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12411] = 26
                                mem[_12411 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 15 * arg2 / 100:
                                        _13161 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13161] = 30
                                        mem[_13161 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14032 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14032] = 30
                                        mem[_14032 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14353 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14353 + 68] = mem[idx + _14032 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14353 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14353 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17765 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17765] = 30
                                        mem[_17765 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _18272 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18272 + 68] = mem[idx + _17765 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18272 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18272 + -mem[64] + 100
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13548 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13548] = 30
                                    mem[_13548 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _13725 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13725 + 68] = mem[idx + _13548 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13725 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13725 + -mem[64] + 100
                                    if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15378 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15378] = 30
                                    mem[_15378 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _15905 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15905 + 68] = mem[idx + _15378 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15905 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15905 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _19325 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19325] = 30
                                    mem[_19325 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19821 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19821 + 68] = mem[idx + _19325 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19821 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19821 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg2 / 100:
                                    _13547 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13547] = 30
                                    mem[_13547 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _13724 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13724 + 68] = mem[idx + _13547 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13724 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13724 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15377 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15377] = 30
                                    mem[_15377 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _15904 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15904 + 68] = mem[idx + _15377 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15904 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15904 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                    _19324 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19324] = 30
                                    mem[_19324 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19820 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19820 + 68] = mem[idx + _19324 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19820 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19820 + -mem[64] + 100
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14352 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14352] = 30
                                mem[_14352 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    _14861 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14861 + 68] = mem[idx + _14352 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14861 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14861 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17056 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17056] = 30
                                mem[_17056 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _17616 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17616 + 68] = mem[idx + _17056 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17616 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17616 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _20747 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20747] = 30
                                mem[_20747 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _21199 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21199 + 68] = mem[idx + _20747 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21199 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21199 + -mem[64] + 100
                            if t < stor6 / 100000000 * 10^18:
                                if not arg2:
                                    if not 15 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                else:
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg2 / 100:
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                            else:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if not 15 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 15 * arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 15 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-15 * arg2 / 100 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * t / s)
                                        if 15 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * t / s
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !(arg2 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 15 * arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 15 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !((arg2 * t / s) - (15 * arg2 / 100 * t / s)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s)
                                        if 15 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * t / s
                            if totalFees > !(15 * arg2 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg2 / 100
                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
    else:
        mem[0] = arg1
        mem[32] = 4
        if not stor4[address(arg1)]:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            if not arg2 / 100:
                mem[64] = 224
                mem[160] = 30
                mem[192] = 'SafeMath: subtraction overflow'
                if 0 > arg2:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg2 < 0:
                    revert with 0, 17
                idx = 0
                s = 100000000 * 10^18
                t = stor6
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _12329 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12329] = 26
                        mem[_12329 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            _13078 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13078] = 30
                            mem[_13078 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 2
                            _13798 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13798] = 30
                            mem[_13798 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _14143 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14143 + 68] = mem[idx + _13798 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14143 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14143 + -mem[64] + 100
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            mem[0] = msg.sender
                            stor2[address(msg.sender)] -= arg2
                            mem[32] = 1
                            _15509 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15509] = 30
                            mem[_15509 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _16037 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16037 + 68] = mem[idx + _15509 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16037 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16037 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > -1:
                                revert with 0, 17
                            if stor1[arg1] < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1]
                            _19445 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19445] = 30
                            mem[_19445 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _20081 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20081 + 68] = mem[idx + _19445 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20081 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20081 + -mem[64] + 100
                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _13439 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13439] = 30
                        mem[_13439 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                            _13603 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13603 + 68] = mem[idx + _13439 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13603 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13603 + -mem[64] + 100
                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 2
                        _14983 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14983] = 30
                        mem[_14983 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _15508 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15508 + 68] = mem[idx + _14983 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15508 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15508 + -mem[64] + 100
                        if stor2[address(msg.sender)] < arg2:
                            revert with 0, 17
                        mem[0] = msg.sender
                        stor2[address(msg.sender)] -= arg2
                        mem[32] = 1
                        _17220 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17220] = 30
                        mem[_17220 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                            _17682 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17682 + 68] = mem[idx + _17220 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17682 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17682 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                        if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                            revert with 0, 17
                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                        _20909 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20909] = 30
                        mem[_20909 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _21326 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21326 + 68] = mem[idx + _20909 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21326 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21326 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _12448 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12448] = 30
                        mem[_12448 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _12479 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12479 + 68] = mem[idx + _12448 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12479 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12479 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _12839 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12839] = 30
                        mem[_12839 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _12899 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12899 + 68] = mem[idx + _12839 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12899 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12899 + -mem[64] + 100
                    _12449 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12449] = 26
                    mem[_12449 + 32] = 'SafeMath: division by zero'
                    if not arg2:
                        _13199 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13199] = 30
                        mem[_13199 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = msg.sender
                        mem[32] = 2
                        _14144 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14144] = 30
                        mem[_14144 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _14474 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14474 + 68] = mem[idx + _14144 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14474 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14474 + -mem[64] + 100
                        if stor2[address(msg.sender)] < arg2:
                            revert with 0, 17
                        mem[0] = msg.sender
                        stor2[address(msg.sender)] -= arg2
                        mem[32] = 1
                        _16039 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16039] = 30
                        mem[_16039 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(msg.sender)]:
                            _16492 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16492 + 68] = mem[idx + _16039 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16492 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16492 + -mem[64] + 100
                        if stor1[address(msg.sender)] < 0:
                            revert with 0, 17
                        if stor1[arg1] > -1:
                            revert with 0, 17
                        if stor1[arg1] < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[arg1]
                        _20082 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20082] = 30
                        mem[_20082 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                            return 1
                        _20473 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _20473 + 68] = mem[idx + _20082 + 32]
                            idx = idx + 32
                            continue 
                        mem[_20473 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _20473 + -mem[64] + 100
                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                        revert with 0, 17
                    if not arg2:
                        revert with 0, 18
                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _13604 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13604] = 30
                    mem[_13604 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                        _13799 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13799 + 68] = mem[idx + _13604 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13799 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13799 + -mem[64] + 100
                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                        revert with 0, 17
                    mem[0] = msg.sender
                    mem[32] = 2
                    _15511 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15511] = 30
                    mem[_15511 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 > stor2[address(msg.sender)]:
                        _16038 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16038 + 68] = mem[idx + _15511 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16038 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16038 + -mem[64] + 100
                    if stor2[address(msg.sender)] < arg2:
                        revert with 0, 17
                    mem[0] = msg.sender
                    stor2[address(msg.sender)] -= arg2
                    mem[32] = 1
                    _17684 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_17684] = 30
                    mem[_17684 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                        _18056 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18056 + 68] = mem[idx + _17684 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18056 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18056 + -mem[64] + 100
                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                        revert with 0, 17
                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                        revert with 0, 17
                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg1
                    mem[32] = 1
                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                    _21328 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21328] = 30
                    mem[_21328 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= stor6:
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                        return 1
                    _21640 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _21640 + 68] = mem[idx + _21328 + 32]
                        idx = idx + 32
                        continue 
                    mem[_21640 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _21640 + -mem[64] + 100
                if t < stor6 / 100000000 * 10^18:
                    if not arg2:
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(msg.sender)] < arg2:
                            revert with 0, 17
                        stor2[address(msg.sender)] -= arg2
                        if 0 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor1[address(msg.sender)] < 0:
                            revert with 0, 17
                        if stor1[arg1] > -1:
                            revert with 0, 17
                        if stor1[arg1] < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor1[address(arg1)] = stor1[arg1]
                    else:
                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                            revert with 0, 17
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(msg.sender)] < arg2:
                            revert with 0, 17
                        stor2[address(msg.sender)] -= arg2
                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                        if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                            revert with 0, 17
                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                else:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg2:
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(msg.sender)] < arg2:
                            revert with 0, 17
                        stor2[address(msg.sender)] -= arg2
                        if 0 > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor1[address(msg.sender)] < 0:
                            revert with 0, 17
                        if stor1[arg1] > -1:
                            revert with 0, 17
                        if stor1[arg1] < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor1[address(arg1)] = stor1[arg1]
                    else:
                        if arg2 and t / s > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * t / s / arg2 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg2 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 * t / s < 0:
                            revert with 0, 17
                        if arg2 > stor2[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(msg.sender)] < arg2:
                            revert with 0, 17
                        stor2[address(msg.sender)] -= arg2
                        if arg2 * t / s > stor1[address(msg.sender)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor1[address(msg.sender)] < arg2 * t / s:
                            revert with 0, 17
                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                        if stor1[arg1] > !(arg2 * t / s):
                            revert with 0, 17
                        if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                if 0 > stor6:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if stor6 < 0:
                    revert with 0, 17
                if totalFees > -1:
                    revert with 0, 17
                if totalFees < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                emit Transfer(arg2, msg.sender, arg1);
            else:
                if arg2 / 100 and 15 > -1 / arg2 / 100:
                    revert with 0, 17
                if not arg2 / 100:
                    revert with 0, 18
                if 15 * arg2 / 100 / arg2 / 100 != 15:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[64] = 224
                mem[160] = 30
                mem[192] = 'SafeMath: subtraction overflow'
                if 15 * arg2 / 100 > arg2:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg2 < 15 * arg2 / 100:
                    revert with 0, 17
                idx = 0
                s = 100000000 * 10^18
                t = stor6
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _12328 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12328] = 26
                        mem[_12328 + 32] = 'SafeMath: division by zero'
                        if not arg2:
                            if not 15 * arg2 / 100:
                                _13075 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13075] = 30
                                mem[_13075 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 2
                                _13795 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13795] = 30
                                mem[_13795 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 > stor2[address(msg.sender)]:
                                    _14138 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14138 + 68] = mem[idx + _13795 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14138 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14138 + -mem[64] + 100
                                if stor2[address(msg.sender)] < arg2:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                stor2[address(msg.sender)] -= arg2
                                mem[32] = 1
                                _15502 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15502] = 30
                                mem[_15502 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _16030 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _16030 + 68] = mem[idx + _15502 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16030 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16030 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1]
                                _19434 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19434] = 30
                                mem[_19434 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20076 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20076 + 68] = mem[idx + _19434 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20076 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20076 + -mem[64] + 100
                            if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                revert with 0, 17
                            if not 15 * arg2 / 100:
                                revert with 0, 18
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13433 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13433] = 30
                            mem[_13433 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                _13600 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13600 + 68] = mem[idx + _13433 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13600 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13600 + -mem[64] + 100
                            if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 2
                            _14977 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14977] = 30
                            mem[_14977 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _15501 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15501 + 68] = mem[idx + _14977 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15501 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15501 + -mem[64] + 100
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            mem[0] = msg.sender
                            stor2[address(msg.sender)] -= arg2
                            mem[32] = 1
                            _17211 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17211] = 30
                            mem[_17211 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _17673 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17673 + 68] = mem[idx + _17211 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17673 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17673 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                            _20899 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20899] = 30
                            mem[_20899 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg2 / 100
                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _21320 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21320 + 68] = mem[idx + _20899 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21320 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21320 + -mem[64] + 100
                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 15 * arg2 / 100:
                            _13432 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13432] = 30
                            mem[_13432 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                _13599 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13599 + 68] = mem[idx + _13432 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13599 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13599 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 2
                            _14976 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14976] = 30
                            mem[_14976 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _15500 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15500 + 68] = mem[idx + _14976 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15500 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15500 + -mem[64] + 100
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            mem[0] = msg.sender
                            stor2[address(msg.sender)] -= arg2
                            mem[32] = 1
                            _17209 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17209] = 30
                            mem[_17209 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _17672 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17672 + 68] = mem[idx + _17209 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17672 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17672 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                            _20898 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20898] = 30
                            mem[_20898 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg2 / 100
                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _21319 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21319 + 68] = mem[idx + _20898 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21319 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21319 + -mem[64] + 100
                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                            revert with 0, 17
                        if not 15 * arg2 / 100:
                            revert with 0, 18
                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14137 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14137] = 30
                        mem[_14137 + 32] = 'SafeMath: subtraction overflow'
                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                            _14466 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14466 + 68] = mem[idx + _14137 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14466 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14466 + -mem[64] + 100
                        if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 2
                        _16487 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16487] = 30
                        mem[_16487 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _17208 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17208 + 68] = mem[idx + _16487 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17208 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17208 + -mem[64] + 100
                        if stor2[address(msg.sender)] < arg2:
                            revert with 0, 17
                        mem[0] = msg.sender
                        stor2[address(msg.sender)] -= arg2
                        mem[32] = 1
                        _18870 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18870] = 30
                        mem[_18870 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                            _19235 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19235 + 68] = mem[idx + _18870 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19235 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19235 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                        if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                            revert with 0, 17
                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                        _22177 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22177] = 30
                        mem[_22177 + 32] = 'SafeMath: subtraction overflow'
                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                            if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                            if totalFees > !(15 * arg2 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg2 / 100
                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                            return 1
                        _22506 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _22506 + 68] = mem[idx + _22177 + 32]
                            idx = idx + 32
                            continue 
                        mem[_22506 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _22506 + -mem[64] + 100
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _12446 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12446] = 30
                        mem[_12446 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _12478 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12478 + 68] = mem[idx + _12446 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12478 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12478 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _12837 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12837] = 30
                        mem[_12837 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _12897 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12897 + 68] = mem[idx + _12837 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12897 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12897 + -mem[64] + 100
                    _12447 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12447] = 26
                    mem[_12447 + 32] = 'SafeMath: division by zero'
                    if not arg2:
                        if not 15 * arg2 / 100:
                            _13197 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13197] = 30
                            mem[_13197 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = msg.sender
                            mem[32] = 2
                            _14140 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14140] = 30
                            mem[_14140 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 > stor2[address(msg.sender)]:
                                _14470 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14470 + 68] = mem[idx + _14140 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14470 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14470 + -mem[64] + 100
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            mem[0] = msg.sender
                            stor2[address(msg.sender)] -= arg2
                            mem[32] = 1
                            _16033 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16033] = 30
                            mem[_16033 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(msg.sender)]:
                                _16489 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16489 + 68] = mem[idx + _16033 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16489 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16489 + -mem[64] + 100
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > -1:
                                revert with 0, 17
                            if stor1[arg1] < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1]
                            _20078 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20078] = 30
                            mem[_20078 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg2 / 100
                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _20460 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20460 + 68] = mem[idx + _20078 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20460 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20460 + -mem[64] + 100
                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                            revert with 0, 17
                        if not 15 * arg2 / 100:
                            revert with 0, 18
                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _13602 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13602] = 30
                        mem[_13602 + 32] = 'SafeMath: subtraction overflow'
                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                            _13797 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13797 + 68] = mem[idx + _13602 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13797 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13797 + -mem[64] + 100
                        if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 2
                        _15505 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15505] = 30
                        mem[_15505 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _16032 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16032 + 68] = mem[idx + _15505 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16032 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16032 + -mem[64] + 100
                        if stor2[address(msg.sender)] < arg2:
                            revert with 0, 17
                        mem[0] = msg.sender
                        stor2[address(msg.sender)] -= arg2
                        mem[32] = 1
                        _17678 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17678] = 30
                        mem[_17678 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(msg.sender)]:
                            _18054 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18054 + 68] = mem[idx + _17678 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18054 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18054 + -mem[64] + 100
                        if stor1[address(msg.sender)] < 0:
                            revert with 0, 17
                        if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                            revert with 0, 17
                        if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                        _21323 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21323] = 30
                        mem[_21323 + 32] = 'SafeMath: subtraction overflow'
                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                            if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                            if totalFees > !(15 * arg2 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg2 / 100
                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                            return 1
                        _21634 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21634 + 68] = mem[idx + _21323 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21634 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21634 + -mem[64] + 100
                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                        revert with 0, 17
                    if not arg2:
                        revert with 0, 18
                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 15 * arg2 / 100:
                        _13601 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13601] = 30
                        mem[_13601 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                            _13796 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13796 + 68] = mem[idx + _13601 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13796 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13796 + -mem[64] + 100
                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                            revert with 0, 17
                        mem[0] = msg.sender
                        mem[32] = 2
                        _15504 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15504] = 30
                        mem[_15504 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 > stor2[address(msg.sender)]:
                            _16031 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16031 + 68] = mem[idx + _15504 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16031 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16031 + -mem[64] + 100
                        if stor2[address(msg.sender)] < arg2:
                            revert with 0, 17
                        mem[0] = msg.sender
                        stor2[address(msg.sender)] -= arg2
                        mem[32] = 1
                        _17676 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17676] = 30
                        mem[_17676 + 32] = 'SafeMath: subtraction overflow'
                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                            _18053 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18053 + 68] = mem[idx + _17676 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18053 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18053 + -mem[64] + 100
                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                        if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                            revert with 0, 17
                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg1
                        mem[32] = 1
                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                        _21322 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21322] = 30
                        mem[_21322 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= stor6:
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > !(15 * arg2 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg2 / 100
                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                            return 1
                        _21633 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21633 + 68] = mem[idx + _21322 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21633 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21633 + -mem[64] + 100
                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                        revert with 0, 17
                    if not 15 * arg2 / 100:
                        revert with 0, 18
                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _14469 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14469] = 30
                    mem[_14469 + 32] = 'SafeMath: subtraction overflow'
                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                        _14978 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14978 + 68] = mem[idx + _14469 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14978 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14978 + -mem[64] + 100
                    if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                        revert with 0, 17
                    mem[0] = msg.sender
                    mem[32] = 2
                    _17213 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_17213] = 30
                    mem[_17213 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 > stor2[address(msg.sender)]:
                        _17675 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _17675 + 68] = mem[idx + _17213 + 32]
                            idx = idx + 32
                            continue 
                        mem[_17675 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _17675 + -mem[64] + 100
                    if stor2[address(msg.sender)] < arg2:
                        revert with 0, 17
                    mem[0] = msg.sender
                    stor2[address(msg.sender)] -= arg2
                    mem[32] = 1
                    _19238 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19238] = 30
                    mem[_19238 + 32] = 'SafeMath: subtraction overflow'
                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                        _19675 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19675 + 68] = mem[idx + _19238 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19675 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19675 + -mem[64] + 100
                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                        revert with 0, 17
                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                    if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                        revert with 0, 17
                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg1
                    mem[32] = 1
                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                    _22510 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_22510] = 30
                    mem[_22510 + 32] = 'SafeMath: subtraction overflow'
                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                        if totalFees > !(15 * arg2 / 100):
                            revert with 0, 17
                        if totalFees + (15 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 15 * arg2 / 100
                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                        return 1
                    _22721 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _22721 + 68] = mem[idx + _22510 + 32]
                        idx = idx + 32
                        continue 
                    mem[_22721 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _22721 + -mem[64] + 100
                if t < stor6 / 100000000 * 10^18:
                    if not arg2:
                        if not 15 * arg2 / 100:
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            stor2[address(msg.sender)] -= arg2
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > -1:
                                revert with 0, 17
                            if stor1[arg1] < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1]
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                        else:
                            if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                revert with 0, 17
                            if not 15 * arg2 / 100:
                                revert with 0, 18
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            stor2[address(msg.sender)] -= arg2
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                    else:
                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 15 * arg2 / 100:
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            stor2[address(msg.sender)] -= arg2
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                        else:
                            if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                revert with 0, 17
                            if not 15 * arg2 / 100:
                                revert with 0, 18
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            stor2[address(msg.sender)] -= arg2
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                else:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg2:
                        if not 15 * arg2 / 100:
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            stor2[address(msg.sender)] -= arg2
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > -1:
                                revert with 0, 17
                            if stor1[arg1] < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1]
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                        else:
                            if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                revert with 0, 17
                            if not 15 * arg2 / 100:
                                revert with 0, 18
                            if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 15 * arg2 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 15 * arg2 / 100 * t / s:
                                revert with 0, 17
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            stor2[address(msg.sender)] -= arg2
                            if 0 > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < 0:
                                revert with 0, 17
                            if stor1[arg1] > !(-15 * arg2 / 100 * t / s):
                                revert with 0, 17
                            if stor1[arg1] - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * t / s)
                            if 15 * arg2 / 100 * t / s > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 15 * arg2 / 100 * t / s:
                                revert with 0, 17
                            stor6 += -15 * arg2 / 100 * t / s
                    else:
                        if arg2 and t / s > -1 / arg2:
                            revert with 0, 17
                        if not arg2:
                            revert with 0, 18
                        if arg2 * t / s / arg2 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 15 * arg2 / 100:
                            if 0 > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * t / s < 0:
                                revert with 0, 17
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            stor2[address(msg.sender)] -= arg2
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * t / s:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor1[arg1] > !(arg2 * t / s):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                        else:
                            if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                revert with 0, 17
                            if not 15 * arg2 / 100:
                                revert with 0, 18
                            if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 15 * arg2 / 100 * t / s > arg2 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 * t / s < 15 * arg2 / 100 * t / s:
                                revert with 0, 17
                            if arg2 > stor2[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(msg.sender)] < arg2:
                                revert with 0, 17
                            stor2[address(msg.sender)] -= arg2
                            if arg2 * t / s > stor1[address(msg.sender)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(msg.sender)] < arg2 * t / s:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                            if stor1[arg1] > !((arg2 * t / s) - (15 * arg2 / 100 * t / s)):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s)
                            if 15 * arg2 / 100 * t / s > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 15 * arg2 / 100 * t / s:
                                revert with 0, 17
                            stor6 += -15 * arg2 / 100 * t / s
                if totalFees > !(15 * arg2 / 100):
                    revert with 0, 17
                if totalFees + (15 * arg2 / 100) < totalFees:
                    revert with 0, 'SafeMath: addition overflow'
                totalFees += 15 * arg2 / 100
                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
        else:
            if stor4[address(msg.sender)]:
                mem[0] = msg.sender
                mem[32] = 4
                if stor4[address(msg.sender)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 0:
                            revert with 0, 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _12315 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12315] = 26
                                mem[_12315 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _13036 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13036] = 30
                                    mem[_13036 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13742 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13742] = 30
                                    mem[_13742 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14059 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14059 + 68] = mem[idx + _13742 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14059 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14059 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17408 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17408] = 30
                                    mem[_17408 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _17792 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17792 + 68] = mem[idx + _17408 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17792 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17792 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13355 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13355] = 30
                                mem[_13355 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _13561 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13561 + 68] = mem[idx + _13355 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13561 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13561 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14892 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14892] = 30
                                mem[_14892 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _15409 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15409 + 68] = mem[idx + _14892 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15409 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15409 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                _19021 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19021] = 30
                                mem[_19021 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19348 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19348 + 68] = mem[idx + _19021 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19348 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19348 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _12420 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12420] = 30
                                mem[_12420 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _12465 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12465 + 68] = mem[idx + _12420 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12465 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12465 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _12811 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12811] = 30
                                mem[_12811 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _12871 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12871 + 68] = mem[idx + _12811 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12871 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12871 + -mem[64] + 100
                            _12421 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12421] = 26
                            mem[_12421 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _13171 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13171] = 30
                                mem[_13171 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14060 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14060] = 30
                                mem[_14060 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14383 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14383 + 68] = mem[idx + _14060 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14383 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14383 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1]
                                _17793 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17793] = 30
                                mem[_17793 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _18370 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18370 + 68] = mem[idx + _17793 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18370 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18370 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13562 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13562] = 30
                            mem[_13562 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                _13743 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13743 + 68] = mem[idx + _13562 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13743 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13743 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _15411 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15411] = 30
                            mem[_15411 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _15937 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15937 + 68] = mem[idx + _15411 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15937 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15937 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                            _19350 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19350] = 30
                            mem[_19350 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _19895 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19895 + 68] = mem[idx + _19350 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19895 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19895 + -mem[64] + 100
                        if t < stor6 / 100000000 * 10^18:
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1]
                            else:
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                        else:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > -1:
                                    revert with 0, 17
                                if stor1[arg1] < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1]
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 0, 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor1[arg1] > !(arg2 * t / s):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 / 100 and 15 > -1 / arg2 / 100:
                            revert with 0, 17
                        if not arg2 / 100:
                            revert with 0, 18
                        if 15 * arg2 / 100 / arg2 / 100 != 15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 15 * arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 15 * arg2 / 100:
                            revert with 0, 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _12314 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12314] = 26
                                mem[_12314 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 15 * arg2 / 100:
                                        _13033 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13033] = 30
                                        mem[_13033 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13739 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13739] = 30
                                        mem[_13739 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14054 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14054 + 68] = mem[idx + _13739 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14054 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14054 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17397 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17397] = 30
                                        mem[_17397 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _17787 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17787 + 68] = mem[idx + _17397 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17787 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17787 + -mem[64] + 100
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13349 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13349] = 30
                                    mem[_13349 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _13558 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13558 + 68] = mem[idx + _13349 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13558 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13558 + -mem[64] + 100
                                    if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14886 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14886] = 30
                                    mem[_14886 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _15403 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15403 + 68] = mem[idx + _14886 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15403 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15403 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _19011 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19011] = 30
                                    mem[_19011 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19342 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19342 + 68] = mem[idx + _19011 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19342 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19342 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg2 / 100:
                                    _13348 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13348] = 30
                                    mem[_13348 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _13557 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13557 + 68] = mem[idx + _13348 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13557 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13557 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14885 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14885] = 30
                                    mem[_14885 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _15402 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15402 + 68] = mem[idx + _14885 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15402 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15402 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                    _19010 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19010] = 30
                                    mem[_19010 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19341 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19341 + 68] = mem[idx + _19010 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19341 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19341 + -mem[64] + 100
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14053 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14053] = 30
                                mem[_14053 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    _14375 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14375 + 68] = mem[idx + _14053 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14375 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14375 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16417 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16417] = 30
                                mem[_16417 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _17087 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17087 + 68] = mem[idx + _16417 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17087 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17087 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _20358 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20358] = 30
                                mem[_20358 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _20774 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20774 + 68] = mem[idx + _20358 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20774 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20774 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _12418 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12418] = 30
                                mem[_12418 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _12464 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12464 + 68] = mem[idx + _12418 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12464 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12464 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _12809 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12809] = 30
                                mem[_12809 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _12869 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12869 + 68] = mem[idx + _12809 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12869 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12869 + -mem[64] + 100
                            _12419 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12419] = 26
                            mem[_12419 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 15 * arg2 / 100:
                                    _13169 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13169] = 30
                                    mem[_13169 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14056 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14056] = 30
                                    mem[_14056 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14379 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14379 + 68] = mem[idx + _14056 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14379 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14379 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17789 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17789] = 30
                                    mem[_17789 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _18357 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18357 + 68] = mem[idx + _17789 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18357 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18357 + -mem[64] + 100
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13560 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13560] = 30
                                mem[_13560 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _13741 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13741 + 68] = mem[idx + _13560 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13741 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13741 + -mem[64] + 100
                                if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15406 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15406] = 30
                                mem[_15406 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _15933 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15933 + 68] = mem[idx + _15406 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15933 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15933 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _19345 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19345] = 30
                                mem[_19345 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19889 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19889 + 68] = mem[idx + _19345 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19889 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19889 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg2 / 100:
                                _13559 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13559] = 30
                                mem[_13559 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _13740 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13740 + 68] = mem[idx + _13559 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13740 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13740 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15405 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15405] = 30
                                mem[_15405 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _15932 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15932 + 68] = mem[idx + _15405 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15932 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15932 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                _19344 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19344] = 30
                                mem[_19344 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _19888 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19888 + 68] = mem[idx + _19344 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19888 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19888 + -mem[64] + 100
                            if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                revert with 0, 17
                            if not 15 * arg2 / 100:
                                revert with 0, 18
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14378 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14378] = 30
                            mem[_14378 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                _14887 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14887 + 68] = mem[idx + _14378 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14887 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14887 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _17090 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17090] = 30
                            mem[_17090 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _17628 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17628 + 68] = mem[idx + _17090 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17628 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17628 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                revert with 0, 17
                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                            _20778 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20778] = 30
                            mem[_20778 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg2 / 100
                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _21234 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21234 + 68] = mem[idx + _20778 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21234 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21234 + -mem[64] + 100
                        if t < stor6 / 100000000 * 10^18:
                            if not arg2:
                                if not 15 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                            else:
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg2 / 100:
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                        else:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if not 15 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 15 * arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 15 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-15 * arg2 / 100 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * t / s)
                                    if 15 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * t / s
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 15 * arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 15 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !((arg2 * t / s) - (15 * arg2 / 100 * t / s)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s)
                                    if 15 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * t / s
                        if totalFees > !(15 * arg2 / 100):
                            revert with 0, 17
                        if totalFees + (15 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 15 * arg2 / 100
                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                else:
                    mem[0] = arg1
                    mem[32] = 4
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if stor4[address(arg1)]:
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 0:
                                revert with 0, 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _12317 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12317] = 26
                                    mem[_12317 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _13042 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13042] = 30
                                        mem[_13042 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13750 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13750] = 30
                                        mem[_13750 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14071 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14071 + 68] = mem[idx + _13750 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14071 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14071 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17432 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17432] = 30
                                        mem[_17432 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _17806 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17806 + 68] = mem[idx + _17432 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17806 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17806 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13367 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13367] = 30
                                    mem[_13367 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _13567 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13567 + 68] = mem[idx + _13367 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13567 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13567 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14905 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14905] = 30
                                    mem[_14905 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _15423 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15423 + 68] = mem[idx + _14905 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15423 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15423 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                    _19039 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19039] = 30
                                    mem[_19039 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _19362 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19362 + 68] = mem[idx + _19039 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19362 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19362 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _12424 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12424] = 30
                                    mem[_12424 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _12467 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12467 + 68] = mem[idx + _12424 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12467 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12467 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _12815 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12815] = 30
                                    mem[_12815 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _12875 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12875 + 68] = mem[idx + _12815 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12875 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12875 + -mem[64] + 100
                                _12425 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12425] = 26
                                mem[_12425 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _13175 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13175] = 30
                                    mem[_13175 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14072 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14072] = 30
                                    mem[_14072 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14396 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14396 + 68] = mem[idx + _14072 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14396 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14396 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17807 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17807] = 30
                                    mem[_17807 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _18408 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18408 + 68] = mem[idx + _17807 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18408 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18408 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13568 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13568] = 30
                                mem[_13568 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _13751 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13751 + 68] = mem[idx + _13568 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13751 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13751 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15425 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15425] = 30
                                mem[_15425 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _15951 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15951 + 68] = mem[idx + _15425 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15951 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15951 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                _19364 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19364] = 30
                                mem[_19364 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19920 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19920 + 68] = mem[idx + _19364 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19920 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19920 + -mem[64] + 100
                            if t < stor6 / 100000000 * 10^18:
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                else:
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                            else:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if arg2 / 100 and 15 > -1 / arg2 / 100:
                                revert with 0, 17
                            if not arg2 / 100:
                                revert with 0, 18
                            if 15 * arg2 / 100 / arg2 / 100 != 15:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 15 * arg2 / 100:
                                revert with 0, 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _12316 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12316] = 26
                                    mem[_12316 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 15 * arg2 / 100:
                                            _13039 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13039] = 30
                                            mem[_13039 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _13747 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13747] = 30
                                            mem[_13747 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _14066 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _14066 + 68] = mem[idx + _13747 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14066 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14066 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1]
                                            _17421 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17421] = 30
                                            mem[_17421 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(15 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (15 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 15 * arg2 / 100
                                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _17801 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17801 + 68] = mem[idx + _17421 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17801 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17801 + -mem[64] + 100
                                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _13361 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13361] = 30
                                        mem[_13361 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _13564 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13564 + 68] = mem[idx + _13361 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13564 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13564 + -mem[64] + 100
                                        if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14899 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14899] = 30
                                        mem[_14899 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _15417 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15417 + 68] = mem[idx + _14899 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15417 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15417 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        _19029 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19029] = 30
                                        mem[_19029 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                            if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19356 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19356 + 68] = mem[idx + _19029 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19356 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19356 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg2 / 100:
                                        _13360 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13360] = 30
                                        mem[_13360 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            _13563 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13563 + 68] = mem[idx + _13360 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13563 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13563 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14898 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14898] = 30
                                        mem[_14898 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _15416 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15416 + 68] = mem[idx + _14898 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15416 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15416 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                        _19028 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19028] = 30
                                        mem[_19028 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19355 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19355 + 68] = mem[idx + _19028 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19355 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19355 + -mem[64] + 100
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _14065 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14065] = 30
                                    mem[_14065 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        _14388 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14388 + 68] = mem[idx + _14065 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14388 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14388 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16427 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16427] = 30
                                    mem[_16427 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _17104 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17104 + 68] = mem[idx + _16427 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17104 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17104 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _20369 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20369] = 30
                                    mem[_20369 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20793 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20793 + 68] = mem[idx + _20369 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20793 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20793 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _12422 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12422] = 30
                                    mem[_12422 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _12466 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12466 + 68] = mem[idx + _12422 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12466 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12466 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _12813 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12813] = 30
                                    mem[_12813 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _12873 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12873 + 68] = mem[idx + _12813 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12873 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12873 + -mem[64] + 100
                                _12423 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12423] = 26
                                mem[_12423 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 15 * arg2 / 100:
                                        _13173 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13173] = 30
                                        mem[_13173 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14068 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14068] = 30
                                        mem[_14068 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14392 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14392 + 68] = mem[idx + _14068 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14392 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14392 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17803 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17803] = 30
                                        mem[_17803 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _18395 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18395 + 68] = mem[idx + _17803 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18395 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18395 + -mem[64] + 100
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13566 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13566] = 30
                                    mem[_13566 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _13749 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13749 + 68] = mem[idx + _13566 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13749 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13749 + -mem[64] + 100
                                    if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15420 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15420] = 30
                                    mem[_15420 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _15947 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15947 + 68] = mem[idx + _15420 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15947 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15947 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _19359 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19359] = 30
                                    mem[_19359 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19914 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19914 + 68] = mem[idx + _19359 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19914 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19914 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg2 / 100:
                                    _13565 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13565] = 30
                                    mem[_13565 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _13748 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13748 + 68] = mem[idx + _13565 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13748 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13748 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15419 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15419] = 30
                                    mem[_15419 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _15946 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15946 + 68] = mem[idx + _15419 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15946 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15946 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                    _19358 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19358] = 30
                                    mem[_19358 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19913 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19913 + 68] = mem[idx + _19358 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19913 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19913 + -mem[64] + 100
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14391 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14391] = 30
                                mem[_14391 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    _14900 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14900 + 68] = mem[idx + _14391 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14900 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14900 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17107 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17107] = 30
                                mem[_17107 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _17634 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17634 + 68] = mem[idx + _17107 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17634 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17634 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _20797 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20797] = 30
                                mem[_20797 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _21244 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21244 + 68] = mem[idx + _20797 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21244 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21244 + -mem[64] + 100
                            if t < stor6 / 100000000 * 10^18:
                                if not arg2:
                                    if not 15 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                else:
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg2 / 100:
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                            else:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if not 15 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 15 * arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 15 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-15 * arg2 / 100 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * t / s)
                                        if 15 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * t / s
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !(arg2 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 15 * arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 15 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !((arg2 * t / s) - (15 * arg2 / 100 * t / s)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s)
                                        if 15 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * t / s
                            if totalFees > !(15 * arg2 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg2 / 100
                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                    else:
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 0:
                                revert with 0, 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _12319 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12319] = 26
                                    mem[_12319 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _13048 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13048] = 30
                                        mem[_13048 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13758 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13758] = 30
                                        mem[_13758 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14083 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14083 + 68] = mem[idx + _13758 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14083 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14083 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17456 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17456] = 30
                                        mem[_17456 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _17820 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17820 + 68] = mem[idx + _17456 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17820 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17820 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13379 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13379] = 30
                                    mem[_13379 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _13573 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13573 + 68] = mem[idx + _13379 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13573 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13573 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14918 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14918] = 30
                                    mem[_14918 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _15437 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15437 + 68] = mem[idx + _14918 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15437 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15437 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                    _19057 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19057] = 30
                                    mem[_19057 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _19376 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19376 + 68] = mem[idx + _19057 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19376 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19376 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _12428 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12428] = 30
                                    mem[_12428 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _12469 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12469 + 68] = mem[idx + _12428 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12469 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12469 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _12819 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12819] = 30
                                    mem[_12819 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _12879 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12879 + 68] = mem[idx + _12819 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12879 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12879 + -mem[64] + 100
                                _12429 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12429] = 26
                                mem[_12429 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _13179 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13179] = 30
                                    mem[_13179 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14084 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14084] = 30
                                    mem[_14084 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14409 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14409 + 68] = mem[idx + _14084 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14409 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14409 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17821 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17821] = 30
                                    mem[_17821 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _18446 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18446 + 68] = mem[idx + _17821 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18446 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18446 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13574 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13574] = 30
                                mem[_13574 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _13759 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13759 + 68] = mem[idx + _13574 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13759 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13759 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15439 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15439] = 30
                                mem[_15439 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _15965 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15965 + 68] = mem[idx + _15439 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15965 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15965 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                _19378 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19378] = 30
                                mem[_19378 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19945 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19945 + 68] = mem[idx + _19378 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19945 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19945 + -mem[64] + 100
                            if t < stor6 / 100000000 * 10^18:
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                else:
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                            else:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if arg2 / 100 and 15 > -1 / arg2 / 100:
                                revert with 0, 17
                            if not arg2 / 100:
                                revert with 0, 18
                            if 15 * arg2 / 100 / arg2 / 100 != 15:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 15 * arg2 / 100:
                                revert with 0, 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _12318 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12318] = 26
                                    mem[_12318 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 15 * arg2 / 100:
                                            _13045 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13045] = 30
                                            mem[_13045 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _13755 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13755] = 30
                                            mem[_13755 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _14078 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _14078 + 68] = mem[idx + _13755 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14078 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14078 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1]
                                            _17445 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17445] = 30
                                            mem[_17445 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(15 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (15 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 15 * arg2 / 100
                                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _17815 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17815 + 68] = mem[idx + _17445 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17815 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17815 + -mem[64] + 100
                                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _13373 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13373] = 30
                                        mem[_13373 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _13570 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13570 + 68] = mem[idx + _13373 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13570 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13570 + -mem[64] + 100
                                        if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14912 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14912] = 30
                                        mem[_14912 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _15431 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15431 + 68] = mem[idx + _14912 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15431 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15431 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        _19047 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19047] = 30
                                        mem[_19047 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                            if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19370 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19370 + 68] = mem[idx + _19047 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19370 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19370 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg2 / 100:
                                        _13372 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13372] = 30
                                        mem[_13372 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            _13569 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13569 + 68] = mem[idx + _13372 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13569 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13569 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14911 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14911] = 30
                                        mem[_14911 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _15430 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15430 + 68] = mem[idx + _14911 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15430 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15430 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                        _19046 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19046] = 30
                                        mem[_19046 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19369 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19369 + 68] = mem[idx + _19046 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19369 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19369 + -mem[64] + 100
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _14077 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14077] = 30
                                    mem[_14077 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        _14401 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14401 + 68] = mem[idx + _14077 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14401 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14401 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16437 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16437] = 30
                                    mem[_16437 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _17121 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17121 + 68] = mem[idx + _16437 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17121 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17121 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _20380 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20380] = 30
                                    mem[_20380 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20812 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20812 + 68] = mem[idx + _20380 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20812 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20812 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _12426 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12426] = 30
                                    mem[_12426 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _12468 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12468 + 68] = mem[idx + _12426 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12468 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12468 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _12817 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12817] = 30
                                    mem[_12817 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _12877 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12877 + 68] = mem[idx + _12817 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12877 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12877 + -mem[64] + 100
                                _12427 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12427] = 26
                                mem[_12427 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 15 * arg2 / 100:
                                        _13177 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13177] = 30
                                        mem[_13177 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14080 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14080] = 30
                                        mem[_14080 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14405 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14405 + 68] = mem[idx + _14080 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14405 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14405 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17817 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17817] = 30
                                        mem[_17817 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _18433 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18433 + 68] = mem[idx + _17817 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18433 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18433 + -mem[64] + 100
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13572 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13572] = 30
                                    mem[_13572 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _13757 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13757 + 68] = mem[idx + _13572 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13757 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13757 + -mem[64] + 100
                                    if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15434 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15434] = 30
                                    mem[_15434 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _15961 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15961 + 68] = mem[idx + _15434 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15961 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15961 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _19373 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19373] = 30
                                    mem[_19373 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19939 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19939 + 68] = mem[idx + _19373 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19939 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19939 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg2 / 100:
                                    _13571 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13571] = 30
                                    mem[_13571 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _13756 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13756 + 68] = mem[idx + _13571 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13756 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13756 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15433 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15433] = 30
                                    mem[_15433 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _15960 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15960 + 68] = mem[idx + _15433 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15960 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15960 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                    _19372 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19372] = 30
                                    mem[_19372 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19938 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19938 + 68] = mem[idx + _19372 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19938 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19938 + -mem[64] + 100
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14404 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14404] = 30
                                mem[_14404 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    _14913 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14913 + 68] = mem[idx + _14404 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14913 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14913 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17124 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17124] = 30
                                mem[_17124 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _17640 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17640 + 68] = mem[idx + _17124 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17640 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17640 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _20816 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20816] = 30
                                mem[_20816 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _21254 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21254 + 68] = mem[idx + _20816 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21254 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21254 + -mem[64] + 100
                            if t < stor6 / 100000000 * 10^18:
                                if not arg2:
                                    if not 15 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                else:
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg2 / 100:
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                            else:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if not 15 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 15 * arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 15 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-15 * arg2 / 100 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * t / s)
                                        if 15 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * t / s
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !(arg2 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 15 * arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 15 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !((arg2 * t / s) - (15 * arg2 / 100 * t / s)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s)
                                        if 15 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * t / s
                            if totalFees > !(15 * arg2 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg2 / 100
                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
            else:
                mem[0] = arg1
                mem[32] = 4
                if stor4[address(arg1)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not arg2 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 0:
                            revert with 0, 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _12327 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12327] = 26
                                mem[_12327 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _13072 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13072] = 30
                                    mem[_13072 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _13790 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13790] = 30
                                    mem[_13790 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14131 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14131 + 68] = mem[idx + _13790 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14131 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14131 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg1)] > !arg2:
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] += arg2
                                    if stor1[address(arg1)] > -1:
                                        revert with 0, 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19128 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19128] = 30
                                    mem[_19128 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _19425 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19425 + 68] = mem[idx + _19128 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19425 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19425 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13427 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13427] = 30
                                mem[_13427 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _13597 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13597 + 68] = mem[idx + _13427 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13597 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13597 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14970 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14970] = 30
                                mem[_14970 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _15493 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15493 + 68] = mem[idx + _14970 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15493 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15493 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor2[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                _20433 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20433] = 30
                                mem[_20433 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _20891 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20891 + 68] = mem[idx + _20433 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20891 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20891 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _12444 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12444] = 30
                                mem[_12444 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _12477 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12477 + 68] = mem[idx + _12444 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12477 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12477 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _12835 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12835] = 30
                                mem[_12835 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _12895 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12895 + 68] = mem[idx + _12835 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12895 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12895 + -mem[64] + 100
                            _12445 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12445] = 26
                            mem[_12445 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                _13195 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13195] = 30
                                mem[_13195 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = msg.sender
                                mem[32] = 1
                                _14132 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14132] = 30
                                mem[_14132 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _14461 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14461 + 68] = mem[idx + _14132 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14461 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14461 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _19426 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19426] = 30
                                mem[_19426 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _20064 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20064 + 68] = mem[idx + _19426 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20064 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20064 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13598 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13598] = 30
                            mem[_13598 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                _13791 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13791 + 68] = mem[idx + _13598 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13791 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13791 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _15495 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15495] = 30
                            mem[_15495 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _16021 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16021 + 68] = mem[idx + _15495 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16021 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16021 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor2[address(arg1)] > !arg2:
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] += arg2
                            if stor1[address(arg1)] > !(arg2 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                            _20893 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20893] = 30
                            mem[_20893 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= stor6:
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                                return 1
                            _21313 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21313 + 68] = mem[idx + _20893 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21313 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21313 + -mem[64] + 100
                        if t < stor6 / 100000000 * 10^18:
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor2[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                        else:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if 0 > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg1)] < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg2 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 * t / s < 0:
                                    revert with 0, 17
                                if arg2 * t / s > stor1[address(msg.sender)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(msg.sender)] < arg2 * t / s:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * t / s
                                if stor2[address(arg1)] > !arg2:
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] += arg2
                                if stor1[address(arg1)] > !(arg2 * t / s):
                                    revert with 0, 17
                                if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor1[address(arg1)] += arg2 * t / s
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg2, msg.sender, arg1);
                    else:
                        if arg2 / 100 and 15 > -1 / arg2 / 100:
                            revert with 0, 17
                        if not arg2 / 100:
                            revert with 0, 18
                        if 15 * arg2 / 100 / arg2 / 100 != 15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 15 * arg2 / 100 > arg2:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg2 < 15 * arg2 / 100:
                            revert with 0, 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _12326 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12326] = 26
                                mem[_12326 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 15 * arg2 / 100:
                                        _13069 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13069] = 30
                                        mem[_13069 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13787 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13787] = 30
                                        mem[_13787 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14126 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14126 + 68] = mem[idx + _13787 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14126 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14126 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                            revert with 0, 17
                                        if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                        if stor1[address(arg1)] > -1:
                                            revert with 0, 17
                                        if stor1[address(arg1)] < stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _19116 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19116] = 30
                                        mem[_19116 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19423 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19423 + 68] = mem[idx + _19116 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19423 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19423 + -mem[64] + 100
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13421 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13421] = 30
                                    mem[_13421 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _13594 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13594 + 68] = mem[idx + _13421 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13594 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13594 + -mem[64] + 100
                                    if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14964 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14964] = 30
                                    mem[_14964 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _15487 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15487 + 68] = mem[idx + _14964 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15487 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15487 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                    if stor1[address(arg1)] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[address(arg1)] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    _20423 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20423] = 30
                                    mem[_20423 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20885 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20885 + 68] = mem[idx + _20423 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20885 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20885 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg2 / 100:
                                    _13420 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13420] = 30
                                    mem[_13420 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _13593 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13593 + 68] = mem[idx + _13420 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13593 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13593 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14963 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14963] = 30
                                    mem[_14963 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _15486 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15486 + 68] = mem[idx + _14963 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15486 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15486 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                    if stor1[address(arg1)] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    _20422 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20422] = 30
                                    mem[_20422 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20884 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20884 + 68] = mem[idx + _20422 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20884 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20884 + -mem[64] + 100
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14125 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14125] = 30
                                mem[_14125 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    _14453 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14453 + 68] = mem[idx + _14125 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14453 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14453 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _16477 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16477] = 30
                                mem[_16477 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _17189 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17189 + 68] = mem[idx + _16477 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17189 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17189 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                if stor1[address(arg1)] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _21610 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21610] = 30
                                mem[_21610 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _22160 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22160 + 68] = mem[idx + _21610 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22160 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22160 + -mem[64] + 100
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _12442 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12442] = 30
                                mem[_12442 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _12476 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12476 + 68] = mem[idx + _12442 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12476 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12476 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _12833 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12833] = 30
                                mem[_12833 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _12893 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12893 + 68] = mem[idx + _12833 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12893 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12893 + -mem[64] + 100
                            _12443 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12443] = 26
                            mem[_12443 + 32] = 'SafeMath: division by zero'
                            if not arg2:
                                if not 15 * arg2 / 100:
                                    _13193 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13193] = 30
                                    mem[_13193 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14128 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14128] = 30
                                    mem[_14128 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14457 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14457 + 68] = mem[idx + _14128 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14457 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14457 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                    if stor1[address(arg1)] > -1:
                                        revert with 0, 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19424 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19424] = 30
                                    mem[_19424 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20051 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20051 + 68] = mem[idx + _19424 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20051 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20051 + -mem[64] + 100
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13596 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13596] = 30
                                mem[_13596 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _13789 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13789 + 68] = mem[idx + _13596 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13789 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13789 + -mem[64] + 100
                                if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15490 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15490] = 30
                                mem[_15490 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(msg.sender)]:
                                    _16017 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _16017 + 68] = mem[idx + _15490 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16017 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16017 + -mem[64] + 100
                                if stor1[address(msg.sender)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                if stor1[address(arg1)] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg1)] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                _20888 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20888] = 30
                                mem[_20888 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _21307 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21307 + 68] = mem[idx + _20888 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21307 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21307 + -mem[64] + 100
                            if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                revert with 0, 17
                            if not arg2:
                                revert with 0, 18
                            if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg2 / 100:
                                _13595 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13595] = 30
                                mem[_13595 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _13788 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13788 + 68] = mem[idx + _13595 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13788 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13788 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15489 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15489] = 30
                                mem[_15489 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _16016 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _16016 + 68] = mem[idx + _15489 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_16016 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _16016 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                if stor1[address(arg1)] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                _20887 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20887] = 30
                                mem[_20887 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _21306 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21306 + 68] = mem[idx + _20887 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21306 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21306 + -mem[64] + 100
                            if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                revert with 0, 17
                            if not 15 * arg2 / 100:
                                revert with 0, 18
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14456 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14456] = 30
                            mem[_14456 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                _14965 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14965 + 68] = mem[idx + _14456 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14965 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14965 + -mem[64] + 100
                            if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = msg.sender
                            mem[32] = 1
                            _17192 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17192] = 30
                            mem[_17192 + 32] = 'SafeMath: subtraction overflow'
                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                _17664 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17664 + 68] = mem[idx + _17192 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17664 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17664 + -mem[64] + 100
                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                            if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                revert with 0, 17
                            if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                            if stor1[address(arg1)] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                revert with 0, 17
                            if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                            _22164 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22164] = 30
                            mem[_22164 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg2 / 100
                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                return 1
                            _22494 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22494 + 68] = mem[idx + _22164 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22494 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22494 + -mem[64] + 100
                        if t < stor6 / 100000000 * 10^18:
                            if not arg2:
                                if not 15 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                    if stor1[address(arg1)] > -1:
                                        revert with 0, 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                    if stor1[address(arg1)] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[address(arg1)] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                            else:
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg2 / 100:
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                    if stor1[address(arg1)] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * stor6 / 100000000 * 10^18
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                    if stor1[address(arg1)] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                        else:
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg2:
                                if not 15 * arg2 / 100:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                    if stor1[address(arg1)] > -1:
                                        revert with 0, 17
                                    if stor1[address(arg1)] < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 15 * arg2 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 15 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                    if stor1[address(arg1)] > !(-15 * arg2 / 100 * t / s):
                                        revert with 0, 17
                                    if stor1[address(arg1)] - (15 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += -15 * arg2 / 100 * t / s
                                    if 15 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * t / s
                            else:
                                if arg2 and t / s > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * t / s / arg2 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg2 / 100:
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                    if stor1[address(arg1)] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor1[address(arg1)] + (arg2 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] += arg2 * t / s
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                else:
                                    if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 15 * arg2 / 100 * t / s > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 15 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor2[address(arg1)] > !(arg2 - (15 * arg2 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg1)] + arg2 - (15 * arg2 / 100) < stor2[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg1)] = stor2[address(arg1)] + arg2 - (15 * arg2 / 100)
                                    if stor1[address(arg1)] > !((arg2 * t / s) - (15 * arg2 / 100 * t / s)):
                                        revert with 0, 17
                                    if stor1[address(arg1)] + (arg2 * t / s) - (15 * arg2 / 100 * t / s) < stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[address(arg1)] + (arg2 * t / s) - (15 * arg2 / 100 * t / s)
                                    if 15 * arg2 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg2 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * t / s
                        if totalFees > !(15 * arg2 / 100):
                            revert with 0, 17
                        if totalFees + (15 * arg2 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 15 * arg2 / 100
                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                else:
                    mem[0] = msg.sender
                    mem[32] = 4
                    if stor4[address(msg.sender)]:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        if not arg2 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 0:
                                revert with 0, 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _12321 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12321] = 26
                                    mem[_12321 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _13054 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13054] = 30
                                        mem[_13054 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _13766 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13766] = 30
                                        mem[_13766 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14095 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14095 + 68] = mem[idx + _13766 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14095 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14095 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17480 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17480] = 30
                                        mem[_17480 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _17834 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17834 + 68] = mem[idx + _17480 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17834 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17834 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13391 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13391] = 30
                                    mem[_13391 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _13579 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13579 + 68] = mem[idx + _13391 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13579 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13579 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14931 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14931] = 30
                                    mem[_14931 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _15451 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15451 + 68] = mem[idx + _14931 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15451 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15451 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                    _19075 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19075] = 30
                                    mem[_19075 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _19390 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19390 + 68] = mem[idx + _19075 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19390 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19390 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _12432 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12432] = 30
                                    mem[_12432 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _12471 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12471 + 68] = mem[idx + _12432 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12471 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12471 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _12823 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12823] = 30
                                    mem[_12823 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _12883 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12883 + 68] = mem[idx + _12823 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12883 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12883 + -mem[64] + 100
                                _12433 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12433] = 26
                                mem[_12433 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    _13183 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13183] = 30
                                    mem[_13183 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _14096 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14096] = 30
                                    mem[_14096 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _14422 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14422 + 68] = mem[idx + _14096 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14422 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14422 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1]
                                    _17835 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17835] = 30
                                    mem[_17835 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _18484 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18484 + 68] = mem[idx + _17835 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18484 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18484 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13580 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13580] = 30
                                mem[_13580 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg2 * stor6 / 100000000 * 10^18:
                                    _13767 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13767 + 68] = mem[idx + _13580 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13767 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13767 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _15453 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15453] = 30
                                mem[_15453 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _15979 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15979 + 68] = mem[idx + _15453 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15979 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15979 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                _19392 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19392] = 30
                                mem[_19392 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= stor6:
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg2, msg.sender, arg1);
                                    return 1
                                _19970 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19970 + 68] = mem[idx + _19392 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19970 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19970 + -mem[64] + 100
                            if t < stor6 / 100000000 * 10^18:
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                else:
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                            else:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if 0 > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > -1:
                                        revert with 0, 17
                                    if stor1[arg1] < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1]
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if 0 > arg2 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg2 * t / s < 0:
                                        revert with 0, 17
                                    if arg2 * t / s > stor1[address(msg.sender)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(msg.sender)] < arg2 * t / s:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * t / s
                                    if stor1[arg1] > !(arg2 * t / s):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg2, msg.sender, arg1);
                        else:
                            if arg2 / 100 and 15 > -1 / arg2 / 100:
                                revert with 0, 17
                            if not arg2 / 100:
                                revert with 0, 18
                            if 15 * arg2 / 100 / arg2 / 100 != 15:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 15 * arg2 / 100 > arg2:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg2 < 15 * arg2 / 100:
                                revert with 0, 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _12320 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12320] = 26
                                    mem[_12320 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 15 * arg2 / 100:
                                            _13051 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13051] = 30
                                            mem[_13051 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _13763 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13763] = 30
                                            mem[_13763 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _14090 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _14090 + 68] = mem[idx + _13763 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14090 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14090 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1]
                                            _17469 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17469] = 30
                                            mem[_17469 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(15 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (15 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 15 * arg2 / 100
                                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _17829 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17829 + 68] = mem[idx + _17469 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17829 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17829 + -mem[64] + 100
                                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _13385 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13385] = 30
                                        mem[_13385 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _13576 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13576 + 68] = mem[idx + _13385 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13576 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13576 + -mem[64] + 100
                                        if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14925 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14925] = 30
                                        mem[_14925 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _15445 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15445 + 68] = mem[idx + _14925 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15445 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15445 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        _19065 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19065] = 30
                                        mem[_19065 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                            if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19384 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19384 + 68] = mem[idx + _19065 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19384 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19384 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg2 / 100:
                                        _13384 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13384] = 30
                                        mem[_13384 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            _13575 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13575 + 68] = mem[idx + _13384 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13575 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13575 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14924 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14924] = 30
                                        mem[_14924 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _15444 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15444 + 68] = mem[idx + _14924 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15444 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15444 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                        _19064 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19064] = 30
                                        mem[_19064 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19383 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19383 + 68] = mem[idx + _19064 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19383 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19383 + -mem[64] + 100
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _14089 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14089] = 30
                                    mem[_14089 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        _14414 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14414 + 68] = mem[idx + _14089 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14414 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14414 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _16447 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_16447] = 30
                                    mem[_16447 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _17138 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17138 + 68] = mem[idx + _16447 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17138 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17138 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _20391 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20391] = 30
                                    mem[_20391 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _20831 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20831 + 68] = mem[idx + _20391 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20831 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20831 + -mem[64] + 100
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _12430 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12430] = 30
                                    mem[_12430 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _12470 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12470 + 68] = mem[idx + _12430 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12470 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12470 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _12821 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12821] = 30
                                    mem[_12821 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _12881 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12881 + 68] = mem[idx + _12821 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12881 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12881 + -mem[64] + 100
                                _12431 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12431] = 26
                                mem[_12431 + 32] = 'SafeMath: division by zero'
                                if not arg2:
                                    if not 15 * arg2 / 100:
                                        _13181 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13181] = 30
                                        mem[_13181 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14092 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14092] = 30
                                        mem[_14092 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14418 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14418 + 68] = mem[idx + _14092 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14418 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14418 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17831 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17831] = 30
                                        mem[_17831 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _18471 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18471 + 68] = mem[idx + _17831 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18471 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18471 + -mem[64] + 100
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13578 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13578] = 30
                                    mem[_13578 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _13765 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13765 + 68] = mem[idx + _13578 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13765 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13765 + -mem[64] + 100
                                    if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15448 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15448] = 30
                                    mem[_15448 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(msg.sender)]:
                                        _15975 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15975 + 68] = mem[idx + _15448 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15975 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15975 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < 0:
                                        revert with 0, 17
                                    if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _19387 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19387] = 30
                                    mem[_19387 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19964 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19964 + 68] = mem[idx + _19387 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19964 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19964 + -mem[64] + 100
                                if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                    revert with 0, 17
                                if not arg2:
                                    revert with 0, 18
                                if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg2 / 100:
                                    _13577 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13577] = 30
                                    mem[_13577 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _13764 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13764 + 68] = mem[idx + _13577 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13764 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13764 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15447 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15447] = 30
                                    mem[_15447 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _15974 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15974 + 68] = mem[idx + _15447 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15974 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15974 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                    _19386 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19386] = 30
                                    mem[_19386 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _19963 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19963 + 68] = mem[idx + _19386 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19963 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19963 + -mem[64] + 100
                                if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                    revert with 0, 17
                                if not 15 * arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14417 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14417] = 30
                                mem[_14417 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                    _14926 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14926 + 68] = mem[idx + _14417 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14926 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14926 + -mem[64] + 100
                                if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = msg.sender
                                mem[32] = 1
                                _17141 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17141] = 30
                                mem[_17141 + 32] = 'SafeMath: subtraction overflow'
                                if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                    _17646 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _17646 + 68] = mem[idx + _17141 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17646 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17646 + -mem[64] + 100
                                if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                _20835 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20835] = 30
                                mem[_20835 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                    if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg2 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg2 / 100
                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                    return 1
                                _21264 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21264 + 68] = mem[idx + _20835 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21264 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21264 + -mem[64] + 100
                            if t < stor6 / 100000000 * 10^18:
                                if not arg2:
                                    if not 15 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                else:
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg2 / 100:
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                            else:
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg2:
                                    if not 15 * arg2 / 100:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 15 * arg2 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 15 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-15 * arg2 / 100 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * t / s)
                                        if 15 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * t / s
                                else:
                                    if arg2 and t / s > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * t / s / arg2 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg2 / 100:
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !(arg2 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                    else:
                                        if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 15 * arg2 / 100 * t / s > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 15 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !((arg2 * t / s) - (15 * arg2 / 100 * t / s)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s)
                                        if 15 * arg2 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg2 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * t / s
                            if totalFees > !(15 * arg2 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg2 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg2 / 100
                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                    else:
                        mem[0] = arg1
                        mem[32] = 4
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        if stor4[address(arg1)]:
                            if not arg2 / 100:
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 < 0:
                                    revert with 0, 17
                                idx = 0
                                s = 100000000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _12323 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12323] = 26
                                        mem[_12323 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _13060 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13060] = 30
                                            mem[_13060 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _13774 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13774] = 30
                                            mem[_13774 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _14107 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _14107 + 68] = mem[idx + _13774 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14107 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14107 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1]
                                            _17504 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17504] = 30
                                            mem[_17504 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _17848 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17848 + 68] = mem[idx + _17504 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17848 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17848 + -mem[64] + 100
                                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _13403 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13403] = 30
                                        mem[_13403 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            _13585 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13585 + 68] = mem[idx + _13403 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13585 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13585 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14944 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14944] = 30
                                        mem[_14944 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _15465 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15465 + 68] = mem[idx + _14944 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15465 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15465 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                        _19093 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19093] = 30
                                        mem[_19093 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _19404 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19404 + 68] = mem[idx + _19093 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19404 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19404 + -mem[64] + 100
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _12436 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12436] = 30
                                        mem[_12436 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _12473 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _12473 + 68] = mem[idx + _12436 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12473 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12473 + -mem[64] + 100
                                        if t < stor1[stor5[idx]]:
                                            revert with 0, 17
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _12827 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12827] = 30
                                        mem[_12827 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            if s < stor2[stor5[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _12887 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12887 + 68] = mem[idx + _12827 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12887 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12887 + -mem[64] + 100
                                    _12437 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12437] = 26
                                    mem[_12437 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _13187 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13187] = 30
                                        mem[_13187 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14108 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14108] = 30
                                        mem[_14108 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14435 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14435 + 68] = mem[idx + _14108 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14435 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14435 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17849 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17849] = 30
                                        mem[_17849 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _18522 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18522 + 68] = mem[idx + _17849 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18522 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18522 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13586 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13586] = 30
                                    mem[_13586 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _13775 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13775 + 68] = mem[idx + _13586 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13775 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13775 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15467 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15467] = 30
                                    mem[_15467 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _15993 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _15993 + 68] = mem[idx + _15467 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_15993 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _15993 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                    _19406 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19406] = 30
                                    mem[_19406 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _19995 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19995 + 68] = mem[idx + _19406 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19995 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19995 + -mem[64] + 100
                                if t < stor6 / 100000000 * 10^18:
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                    else:
                                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                else:
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                    else:
                                        if arg2 and t / s > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !(arg2 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if arg2 / 100 and 15 > -1 / arg2 / 100:
                                    revert with 0, 17
                                if not arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 / arg2 / 100 != 15:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 < 15 * arg2 / 100:
                                    revert with 0, 17
                                idx = 0
                                s = 100000000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _12322 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12322] = 26
                                        mem[_12322 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not 15 * arg2 / 100:
                                                _13057 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_13057] = 30
                                                mem[_13057 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _13771 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_13771] = 30
                                                mem[_13771 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _14102 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _14102 + 68] = mem[idx + _13771 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_14102 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _14102 + -mem[64] + 100
                                                if stor1[address(msg.sender)] < 0:
                                                    revert with 0, 17
                                                if stor1[arg1] > -1:
                                                    revert with 0, 17
                                                if stor1[arg1] < stor1[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] = stor1[arg1]
                                                _17493 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_17493] = 30
                                                mem[_17493 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > !(15 * arg2 / 100):
                                                        revert with 0, 17
                                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += 15 * arg2 / 100
                                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _17843 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _17843 + 68] = mem[idx + _17493 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17843 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17843 + -mem[64] + 100
                                            if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                                revert with 0, 17
                                            if not 15 * arg2 / 100:
                                                revert with 0, 18
                                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _13397 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13397] = 30
                                            mem[_13397 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                                _13582 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _13582 + 68] = mem[idx + _13397 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13582 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13582 + -mem[64] + 100
                                            if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _14938 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14938] = 30
                                            mem[_14938 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _15459 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _15459 + 68] = mem[idx + _14938 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_15459 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _15459 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                            _19083 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19083] = 30
                                            mem[_19083 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                                if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                    revert with 0, 17
                                                stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                                if totalFees > !(15 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (15 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 15 * arg2 / 100
                                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _19398 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19398 + 68] = mem[idx + _19083 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19398 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19398 + -mem[64] + 100
                                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 15 * arg2 / 100:
                                            _13396 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13396] = 30
                                            mem[_13396 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                                _13581 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _13581 + 68] = mem[idx + _13396 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13581 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13581 + -mem[64] + 100
                                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                                revert with 0, 17
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _14937 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14937] = 30
                                            mem[_14937 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                                _15458 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _15458 + 68] = mem[idx + _14937 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_15458 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _15458 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                            if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                            _19082 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19082] = 30
                                            mem[_19082 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(15 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (15 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 15 * arg2 / 100
                                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _19397 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19397 + 68] = mem[idx + _19082 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19397 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19397 + -mem[64] + 100
                                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _14101 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14101] = 30
                                        mem[_14101 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                            _14427 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14427 + 68] = mem[idx + _14101 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14427 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14427 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _16457 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16457] = 30
                                        mem[_16457 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _17155 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17155 + 68] = mem[idx + _16457 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17155 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17155 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        _20402 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20402] = 30
                                        mem[_20402 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                            if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _20850 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20850 + 68] = mem[idx + _20402 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20850 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20850 + -mem[64] + 100
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _12434 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12434] = 30
                                        mem[_12434 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _12472 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _12472 + 68] = mem[idx + _12434 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12472 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12472 + -mem[64] + 100
                                        if t < stor1[stor5[idx]]:
                                            revert with 0, 17
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _12825 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12825] = 30
                                        mem[_12825 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            if s < stor2[stor5[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _12885 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12885 + 68] = mem[idx + _12825 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12885 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12885 + -mem[64] + 100
                                    _12435 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12435] = 26
                                    mem[_12435 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 15 * arg2 / 100:
                                            _13185 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13185] = 30
                                            mem[_13185 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _14104 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14104] = 30
                                            mem[_14104 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _14431 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _14431 + 68] = mem[idx + _14104 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14431 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14431 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1]
                                            _17845 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17845] = 30
                                            mem[_17845 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(15 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (15 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 15 * arg2 / 100
                                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _18509 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18509 + 68] = mem[idx + _17845 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18509 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18509 + -mem[64] + 100
                                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _13584 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13584] = 30
                                        mem[_13584 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _13773 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13773 + 68] = mem[idx + _13584 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13773 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13773 + -mem[64] + 100
                                        if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _15462 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15462] = 30
                                        mem[_15462 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _15989 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15989 + 68] = mem[idx + _15462 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15989 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15989 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        _19401 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19401] = 30
                                        mem[_19401 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                            if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19989 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19989 + 68] = mem[idx + _19401 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19989 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19989 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg2 / 100:
                                        _13583 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13583] = 30
                                        mem[_13583 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            _13772 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13772 + 68] = mem[idx + _13583 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13772 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13772 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _15461 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15461] = 30
                                        mem[_15461 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _15988 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15988 + 68] = mem[idx + _15461 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15988 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15988 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                        _19400 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19400] = 30
                                        mem[_19400 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _19988 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19988 + 68] = mem[idx + _19400 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19988 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19988 + -mem[64] + 100
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _14430 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14430] = 30
                                    mem[_14430 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        _14939 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14939 + 68] = mem[idx + _14430 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14939 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14939 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17158 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17158] = 30
                                    mem[_17158 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _17652 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17652 + 68] = mem[idx + _17158 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17652 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17652 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _20854 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20854] = 30
                                    mem[_20854 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _21274 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21274 + 68] = mem[idx + _20854 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21274 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21274 + -mem[64] + 100
                                if t < stor6 / 100000000 * 10^18:
                                    if not arg2:
                                        if not 15 * arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1]
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                        else:
                                            if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                                revert with 0, 17
                                            if not 15 * arg2 / 100:
                                                revert with 0, 18
                                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    else:
                                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 15 * arg2 / 100:
                                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                                revert with 0, 17
                                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                            if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                        else:
                                            if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                                revert with 0, 17
                                            if not 15 * arg2 / 100:
                                                revert with 0, 18
                                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                            if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                                revert with 0, 17
                                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                else:
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg2:
                                        if not 15 * arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1]
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                        else:
                                            if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                                revert with 0, 17
                                            if not 15 * arg2 / 100:
                                                revert with 0, 18
                                            if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 15 * arg2 / 100 * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if 0 < 15 * arg2 / 100 * t / s:
                                                revert with 0, 17
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > !(-15 * arg2 / 100 * t / s):
                                                revert with 0, 17
                                            if stor1[arg1] - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * t / s)
                                            if 15 * arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 15 * arg2 / 100 * t / s:
                                                revert with 0, 17
                                            stor6 += -15 * arg2 / 100 * t / s
                                    else:
                                        if arg2 and t / s > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 15 * arg2 / 100:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * t / s < 0:
                                                revert with 0, 17
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * t / s:
                                                revert with 0, 17
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[arg1] > !(arg2 * t / s):
                                                revert with 0, 17
                                            if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                        else:
                                            if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                                revert with 0, 17
                                            if not 15 * arg2 / 100:
                                                revert with 0, 18
                                            if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 15 * arg2 / 100 * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * t / s < 15 * arg2 / 100 * t / s:
                                                revert with 0, 17
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * t / s:
                                                revert with 0, 17
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[arg1] > !((arg2 * t / s) - (15 * arg2 / 100 * t / s)):
                                                revert with 0, 17
                                            if stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s)
                                            if 15 * arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 15 * arg2 / 100 * t / s:
                                                revert with 0, 17
                                            stor6 += -15 * arg2 / 100 * t / s
                                if totalFees > !(15 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg2 / 100
                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                        else:
                            if not arg2 / 100:
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 < 0:
                                    revert with 0, 17
                                idx = 0
                                s = 100000000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _12325 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12325] = 26
                                        mem[_12325 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            _13066 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13066] = 30
                                            mem[_13066 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _13782 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13782] = 30
                                            mem[_13782 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _14119 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _14119 + 68] = mem[idx + _13782 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14119 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14119 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1]
                                            _17528 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17528] = 30
                                            mem[_17528 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > -1:
                                                    revert with 0, 17
                                                if totalFees < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                emit Transfer(arg2, msg.sender, arg1);
                                                return 1
                                            _17862 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17862 + 68] = mem[idx + _17528 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17862 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17862 + -mem[64] + 100
                                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _13415 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13415] = 30
                                        mem[_13415 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            _13591 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13591 + 68] = mem[idx + _13415 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13591 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13591 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14957 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14957] = 30
                                        mem[_14957 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _15479 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _15479 + 68] = mem[idx + _14957 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_15479 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _15479 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                        _19111 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19111] = 30
                                        mem[_19111 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _19418 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19418 + 68] = mem[idx + _19111 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19418 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19418 + -mem[64] + 100
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _12440 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12440] = 30
                                        mem[_12440 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _12475 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _12475 + 68] = mem[idx + _12440 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12475 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12475 + -mem[64] + 100
                                        if t < stor1[stor5[idx]]:
                                            revert with 0, 17
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _12831 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12831] = 30
                                        mem[_12831 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            if s < stor2[stor5[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _12891 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12891 + 68] = mem[idx + _12831 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12891 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12891 + -mem[64] + 100
                                    _12441 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12441] = 26
                                    mem[_12441 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        _13191 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13191] = 30
                                        mem[_13191 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _14120 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14120] = 30
                                        mem[_14120 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _14448 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14448 + 68] = mem[idx + _14120 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14448 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14448 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1]
                                        _17863 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17863] = 30
                                        mem[_17863 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg2, msg.sender, arg1);
                                            return 1
                                        _18560 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18560 + 68] = mem[idx + _17863 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18560 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18560 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13592 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13592] = 30
                                    mem[_13592 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg2 * stor6 / 100000000 * 10^18:
                                        _13783 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13783 + 68] = mem[idx + _13592 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13783 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13783 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _15481 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15481] = 30
                                    mem[_15481 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _16007 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _16007 + 68] = mem[idx + _15481 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_16007 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _16007 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                    _19420 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19420] = 30
                                    mem[_19420 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= stor6:
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg2, msg.sender, arg1);
                                        return 1
                                    _20020 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20020 + 68] = mem[idx + _19420 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20020 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20020 + -mem[64] + 100
                                if t < stor6 / 100000000 * 10^18:
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                    else:
                                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                else:
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg2:
                                        if 0 > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > -1:
                                            revert with 0, 17
                                        if stor1[arg1] < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1]
                                    else:
                                        if arg2 and t / s > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if 0 > arg2 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg2 * t / s < 0:
                                            revert with 0, 17
                                        if arg2 * t / s > stor1[address(msg.sender)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(msg.sender)] < arg2 * t / s:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * t / s
                                        if stor1[arg1] > !(arg2 * t / s):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg2, msg.sender, arg1);
                            else:
                                if arg2 / 100 and 15 > -1 / arg2 / 100:
                                    revert with 0, 17
                                if not arg2 / 100:
                                    revert with 0, 18
                                if 15 * arg2 / 100 / arg2 / 100 != 15:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 15 * arg2 / 100 > arg2:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg2 < 15 * arg2 / 100:
                                    revert with 0, 17
                                idx = 0
                                s = 100000000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _12324 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12324] = 26
                                        mem[_12324 + 32] = 'SafeMath: division by zero'
                                        if not arg2:
                                            if not 15 * arg2 / 100:
                                                _13063 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_13063] = 30
                                                mem[_13063 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = msg.sender
                                                mem[32] = 1
                                                _13779 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_13779] = 30
                                                mem[_13779 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(msg.sender)]:
                                                    _14114 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _14114 + 68] = mem[idx + _13779 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_14114 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _14114 + -mem[64] + 100
                                                if stor1[address(msg.sender)] < 0:
                                                    revert with 0, 17
                                                if stor1[arg1] > -1:
                                                    revert with 0, 17
                                                if stor1[arg1] < stor1[arg1]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                stor1[address(arg1)] = stor1[arg1]
                                                _17517 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_17517] = 30
                                                mem[_17517 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 <= stor6:
                                                    if stor6 < 0:
                                                        revert with 0, 17
                                                    if totalFees > !(15 * arg2 / 100):
                                                        revert with 0, 17
                                                    if totalFees + (15 * arg2 / 100) < totalFees:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    totalFees += 15 * arg2 / 100
                                                    emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                                    return 1
                                                _17857 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _17857 + 68] = mem[idx + _17517 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_17857 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _17857 + -mem[64] + 100
                                            if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                                revert with 0, 17
                                            if not 15 * arg2 / 100:
                                                revert with 0, 18
                                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _13409 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13409] = 30
                                            mem[_13409 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                                _13588 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _13588 + 68] = mem[idx + _13409 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13588 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13588 + -mem[64] + 100
                                            if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _14951 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14951] = 30
                                            mem[_14951 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _15473 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _15473 + 68] = mem[idx + _14951 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_15473 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _15473 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                            _19101 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19101] = 30
                                            mem[_19101 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                                if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                    revert with 0, 17
                                                stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                                if totalFees > !(15 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (15 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 15 * arg2 / 100
                                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _19412 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19412 + 68] = mem[idx + _19101 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19412 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19412 + -mem[64] + 100
                                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 15 * arg2 / 100:
                                            _13408 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13408] = 30
                                            mem[_13408 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                                _13587 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _13587 + 68] = mem[idx + _13408 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_13587 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _13587 + -mem[64] + 100
                                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                                revert with 0, 17
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _14950 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14950] = 30
                                            mem[_14950 + 32] = 'SafeMath: subtraction overflow'
                                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                                _15472 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _15472 + 68] = mem[idx + _14950 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_15472 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _15472 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                            if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                            _19100 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19100] = 30
                                            mem[_19100 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(15 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (15 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 15 * arg2 / 100
                                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _19411 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19411 + 68] = mem[idx + _19100 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19411 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19411 + -mem[64] + 100
                                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _14113 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_14113] = 30
                                        mem[_14113 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                            _14440 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _14440 + 68] = mem[idx + _14113 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_14440 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _14440 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _16467 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_16467] = 30
                                        mem[_16467 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _17172 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _17172 + 68] = mem[idx + _16467 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17172 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17172 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        _20413 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20413] = 30
                                        mem[_20413 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                            if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _20869 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20869 + 68] = mem[idx + _20413 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20869 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20869 + -mem[64] + 100
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _12438 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12438] = 30
                                        mem[_12438 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _12474 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _12474 + 68] = mem[idx + _12438 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_12474 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _12474 + -mem[64] + 100
                                        if t < stor1[stor5[idx]]:
                                            revert with 0, 17
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _12829 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_12829] = 30
                                        mem[_12829 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            if s < stor2[stor5[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _12889 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _12889 + 68] = mem[idx + _12829 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_12889 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _12889 + -mem[64] + 100
                                    _12439 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12439] = 26
                                    mem[_12439 + 32] = 'SafeMath: division by zero'
                                    if not arg2:
                                        if not 15 * arg2 / 100:
                                            _13189 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_13189] = 30
                                            mem[_13189 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = msg.sender
                                            mem[32] = 1
                                            _14116 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_14116] = 30
                                            mem[_14116 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(msg.sender)]:
                                                _14444 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _14444 + 68] = mem[idx + _14116 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_14444 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _14444 + -mem[64] + 100
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            stor1[address(arg1)] = stor1[arg1]
                                            _17859 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_17859] = 30
                                            mem[_17859 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 <= stor6:
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(15 * arg2 / 100):
                                                    revert with 0, 17
                                                if totalFees + (15 * arg2 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 15 * arg2 / 100
                                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                                return 1
                                            _18547 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18547 + 68] = mem[idx + _17859 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18547 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18547 + -mem[64] + 100
                                        if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                            revert with 0, 17
                                        if not 15 * arg2 / 100:
                                            revert with 0, 18
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _13590 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13590] = 30
                                        mem[_13590 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _13781 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13781 + 68] = mem[idx + _13590 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13781 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13781 + -mem[64] + 100
                                        if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _15476 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15476] = 30
                                        mem[_15476 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(msg.sender)]:
                                            _16003 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _16003 + 68] = mem[idx + _15476 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16003 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16003 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < 0:
                                            revert with 0, 17
                                        if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                        _19415 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19415] = 30
                                        mem[_19415 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                            if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _20014 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20014 + 68] = mem[idx + _19415 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20014 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20014 + -mem[64] + 100
                                    if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                        revert with 0, 17
                                    if not arg2:
                                        revert with 0, 18
                                    if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg2 / 100:
                                        _13589 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_13589] = 30
                                        mem[_13589 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg2 * stor6 / 100000000 * 10^18:
                                            _13780 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _13780 + 68] = mem[idx + _13589 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_13780 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _13780 + -mem[64] + 100
                                        if arg2 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = msg.sender
                                        mem[32] = 1
                                        _15475 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_15475] = 30
                                        mem[_15475 + 32] = 'SafeMath: subtraction overflow'
                                        if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                            _16002 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _16002 + 68] = mem[idx + _15475 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_16002 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _16002 + -mem[64] + 100
                                        if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                        if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                        _19414 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19414] = 30
                                        mem[_19414 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 <= stor6:
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg2 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg2 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg2 / 100
                                            emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                            return 1
                                        _20013 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20013 + 68] = mem[idx + _19414 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20013 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20013 + -mem[64] + 100
                                    if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                        revert with 0, 17
                                    if not 15 * arg2 / 100:
                                        revert with 0, 18
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _14443 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14443] = 30
                                    mem[_14443 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                        _14952 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _14952 + 68] = mem[idx + _14443 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14952 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14952 + -mem[64] + 100
                                    if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = msg.sender
                                    mem[32] = 1
                                    _17175 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17175] = 30
                                    mem[_17175 + 32] = 'SafeMath: subtraction overflow'
                                    if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                        _17658 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _17658 + 68] = mem[idx + _17175 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17658 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17658 + -mem[64] + 100
                                    if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                    if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                    _20873 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20873] = 30
                                    mem[_20873 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 <= stor6:
                                        if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg2 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg2 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg2 / 100
                                        emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
                                        return 1
                                    _21284 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21284 + 68] = mem[idx + _20873 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21284 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21284 + -mem[64] + 100
                                if t < stor6 / 100000000 * 10^18:
                                    if not arg2:
                                        if not 15 * arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1]
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                        else:
                                            if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                                revert with 0, 17
                                            if not 15 * arg2 / 100:
                                                revert with 0, 18
                                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if 0 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > !(-15 * arg2 / 100 * stor6 / 100000000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                    else:
                                        if arg2 and stor6 / 100000000 * 10^18 > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * stor6 / 100000000 * 10^18 / arg2 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 15 * arg2 / 100:
                                            if 0 > arg2 * stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * stor6 / 100000000 * 10^18 < 0:
                                                revert with 0, 17
                                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                            if stor1[arg1] > !(arg2 * stor6 / 100000000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18)
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                        else:
                                            if 15 * arg2 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg2 / 100:
                                                revert with 0, 17
                                            if not 15 * arg2 / 100:
                                                revert with 0, 18
                                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 / 15 * arg2 / 100 != stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > arg2 * stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * stor6 / 100000000 * 10^18 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            if arg2 * stor6 / 100000000 * 10^18 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor1[address(msg.sender)] += -1 * arg2 * stor6 / 100000000 * 10^18
                                            if stor1[arg1] > !((arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)):
                                                revert with 0, 17
                                            if stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] + (arg2 * stor6 / 100000000 * 10^18) - (15 * arg2 / 100 * stor6 / 100000000 * 10^18)
                                            if 15 * arg2 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 15 * arg2 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -15 * arg2 / 100 * stor6 / 100000000 * 10^18
                                else:
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg2:
                                        if not 15 * arg2 / 100:
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > -1:
                                                revert with 0, 17
                                            if stor1[arg1] < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1]
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                        else:
                                            if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                                revert with 0, 17
                                            if not 15 * arg2 / 100:
                                                revert with 0, 18
                                            if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 15 * arg2 / 100 * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if 0 < 15 * arg2 / 100 * t / s:
                                                revert with 0, 17
                                            if 0 > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < 0:
                                                revert with 0, 17
                                            if stor1[arg1] > !(-15 * arg2 / 100 * t / s):
                                                revert with 0, 17
                                            if stor1[arg1] - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] - (15 * arg2 / 100 * t / s)
                                            if 15 * arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 15 * arg2 / 100 * t / s:
                                                revert with 0, 17
                                            stor6 += -15 * arg2 / 100 * t / s
                                    else:
                                        if arg2 and t / s > -1 / arg2:
                                            revert with 0, 17
                                        if not arg2:
                                            revert with 0, 18
                                        if arg2 * t / s / arg2 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 15 * arg2 / 100:
                                            if 0 > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * t / s < 0:
                                                revert with 0, 17
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * t / s:
                                                revert with 0, 17
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[arg1] > !(arg2 * t / s):
                                                revert with 0, 17
                                            if stor1[arg1] + (arg2 * t / s) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s)
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                        else:
                                            if 15 * arg2 / 100 and t / s > -1 / 15 * arg2 / 100:
                                                revert with 0, 17
                                            if not 15 * arg2 / 100:
                                                revert with 0, 18
                                            if 15 * arg2 / 100 * t / s / 15 * arg2 / 100 != t / s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if 15 * arg2 / 100 * t / s > arg2 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg2 * t / s < 15 * arg2 / 100 * t / s:
                                                revert with 0, 17
                                            if arg2 * t / s > stor1[address(msg.sender)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(msg.sender)] < arg2 * t / s:
                                                revert with 0, 17
                                            stor1[address(msg.sender)] += -1 * arg2 * t / s
                                            if stor1[arg1] > !((arg2 * t / s) - (15 * arg2 / 100 * t / s)):
                                                revert with 0, 17
                                            if stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s) < stor1[arg1]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            stor1[address(arg1)] = stor1[arg1] + (arg2 * t / s) - (15 * arg2 / 100 * t / s)
                                            if 15 * arg2 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 15 * arg2 / 100 * t / s:
                                                revert with 0, 17
                                            stor6 += -15 * arg2 / 100 * t / s
                                if totalFees > !(15 * arg2 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg2 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg2 / 100
                                emit Transfer((arg2 - (15 * arg2 / 100)), msg.sender, arg1);
    return 1
}

function transferFrom(address arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer from the zero address'
    if not arg2:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'ERC20: transfer to the zero address'
    if arg3 <= 0:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Transfer amount must be greater than zero'
    if not stor4[address(arg1)]:
        if stor4[address(arg1)]:
            mem[0] = arg1
            mem[32] = 4
            if stor4[address(arg1)]:
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if not arg3 / 100:
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 0 > arg3:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg3 < 0:
                        revert with 0, 17
                    idx = 0
                    s = 100000000 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _18061 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18061] = 26
                            mem[_18061 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                _18754 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18754] = 30
                                mem[_18754 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _19446 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19446] = 30
                                mem[_19446 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    _19735 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19735 + 68] = mem[idx + _19446 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19735 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19735 + -mem[64] + 100
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > -1:
                                    revert with 0, 17
                                if stor1[arg2] < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2]
                                _23000 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23000] = 30
                                mem[_23000 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _23458 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23458 + 68] = mem[idx + _23000 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23458 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23458 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _27101 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_27101] = 40
                                mem[_27101 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _27493 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _27493 + 68] = mem[idx + _27101 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27493 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _27493 + -mem[64] + 132
                            if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _19031 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19031] = 30
                            mem[_19031 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg3 * stor6 / 100000000 * 10^18:
                                _19279 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19279 + 68] = mem[idx + _19031 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19279 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19279 + -mem[64] + 100
                            if arg3 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _20561 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20561] = 30
                            mem[_20561 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                _21071 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21071 + 68] = mem[idx + _20561 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21071 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21071 + -mem[64] + 100
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                            _24653 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24653] = 30
                            mem[_24653 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                _25018 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25018 + 68] = mem[idx + _24653 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25018 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25018 + -mem[64] + 100
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg3, arg1, arg2);
                            _28469 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_28469] = 40
                            mem[_28469 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _28990 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _28990 + 68] = mem[idx + _28469 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28990 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _28990 + -mem[64] + 132
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _18152 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18152] = 30
                            mem[_18152 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _18211 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18211 + 68] = mem[idx + _18152 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18211 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18211 + -mem[64] + 100
                            if t < stor1[stor5[idx]]:
                                revert with 0, 17
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _18543 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18543] = 30
                            mem[_18543 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                if s < stor2[stor5[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _18603 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18603 + 68] = mem[idx + _18543 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18603 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18603 + -mem[64] + 100
                        _18153 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18153] = 26
                        mem[_18153 + 32] = 'SafeMath: division by zero'
                        if not arg3:
                            _18903 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18903] = 30
                            mem[_18903 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _19736 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19736] = 30
                            mem[_19736 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(arg1)]:
                                _20052 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20052 + 68] = mem[idx + _19736 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20052 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20052 + -mem[64] + 100
                            if stor1[address(arg1)] < 0:
                                revert with 0, 17
                            if stor1[arg2] > -1:
                                revert with 0, 17
                            if stor1[arg2] < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2]
                            _23459 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23459] = 30
                            mem[_23459 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                _23855 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23855 + 68] = mem[idx + _23459 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23855 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23855 + -mem[64] + 100
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg3, arg1, arg2);
                            _27494 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_27494] = 40
                            mem[_27494 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _28102 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _28102 + 68] = mem[idx + _27494 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28102 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _28102 + -mem[64] + 132
                        if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _19280 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19280] = 30
                        mem[_19280 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                            _19447 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19447 + 68] = mem[idx + _19280 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19447 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19447 + -mem[64] + 100
                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                            revert with 0, 17
                        mem[0] = arg1
                        mem[32] = 1
                        _21073 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21073] = 30
                        mem[_21073 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                            _21599 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21599 + 68] = mem[idx + _21073 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21599 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21599 + -mem[64] + 100
                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                        if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                            revert with 0, 17
                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 1
                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                        _25020 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25020] = 30
                        mem[_25020 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor6:
                            _25462 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _25462 + 68] = mem[idx + _25020 + 32]
                                idx = idx + 32
                                continue 
                            mem[_25462 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _25462 + -mem[64] + 100
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg3, arg1, arg2);
                        _28993 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_28993] = 40
                        mem[_28993 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                        mem[32] = sha3(address(arg1), 3)
                        if arg3 <= allowance[address(arg1)][msg.sender]:
                            if allowance[address(arg1)][msg.sender] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                            return 1
                        _29814 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _29814 + 68] = mem[idx + _28993 + 32]
                            idx = idx + 32
                            continue 
                        mem[_29814 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _29814 + -mem[64] + 132
                    _17853 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_17853] = 26
                    mem[_17853 + 32] = 'SafeMath: division by zero'
                    if t < stor6 / 100000000 * 10^18:
                        _18273 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18273] = 26
                        mem[_18273 + 32] = 'SafeMath: division by zero'
                        if not arg3:
                            _19030 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19030] = 30
                            mem[_19030 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _20560 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20560] = 30
                            mem[_20560 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(arg1)] < 0:
                                revert with 0, 17
                            if stor1[arg2] > -1:
                                revert with 0, 17
                            if stor1[arg2] < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2]
                            _24652 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24652] = 30
                            mem[_24652 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg3, arg1, arg2);
                            _28466 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_28466] = 40
                            mem[_28466 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            if arg3 > allowance[address(arg1)][msg.sender]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28466 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _19734 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19734] = 30
                            mem[_19734 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg3 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _22111 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22111] = 30
                            mem[_22111 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                            _26041 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26041] = 30
                            mem[_26041 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg3, arg1, arg2);
                            _30415 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_30415] = 40
                            mem[_30415 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            if arg3 > allowance[address(arg1)][msg.sender]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30415 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        _18272 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18272] = 26
                        mem[_18272 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            _19028 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19028] = 30
                            mem[_19028 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _20559 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20559] = 30
                            mem[_20559 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(arg1)] < 0:
                                revert with 0, 17
                            if stor1[arg2] > -1:
                                revert with 0, 17
                            if stor1[arg2] < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2]
                            _24651 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24651] = 30
                            mem[_24651 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg3, arg1, arg2);
                            _28463 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_28463] = 40
                            mem[_28463 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            if arg3 > allowance[address(arg1)][msg.sender]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28463 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and t / s > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * t / s / arg3 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _19733 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19733] = 30
                            mem[_19733 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg3 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg3 * t / s < 0:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _22110 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22110] = 30
                            mem[_22110 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * t / s > stor1[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(arg1)] < arg3 * t / s:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * t / s
                            if stor1[arg2] > !(arg3 * t / s):
                                revert with 0, 17
                            if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                            _26040 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26040] = 30
                            mem[_26040 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg3, arg1, arg2);
                            _30412 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_30412] = 40
                            mem[_30412 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            if arg3 > allowance[address(arg1)][msg.sender]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30412 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    if arg3 / 100 and 15 > -1 / arg3 / 100:
                        revert with 0, 17
                    if not arg3 / 100:
                        revert with 0, 18
                    if 15 * arg3 / 100 / arg3 / 100 != 15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 15 * arg3 / 100 > arg3:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg3 < 15 * arg3 / 100:
                        revert with 0, 17
                    idx = 0
                    s = 100000000 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _18060 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18060] = 26
                            mem[_18060 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                if not 15 * arg3 / 100:
                                    _18751 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18751] = 30
                                    mem[_18751 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19443 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19443] = 30
                                    mem[_19443 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _19730 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19730 + 68] = mem[idx + _19443 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19730 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19730 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _22989 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22989] = 30
                                    mem[_22989 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _23453 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _23453 + 68] = mem[idx + _22989 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23453 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23453 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _27094 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_27094] = 40
                                    mem[_27094 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _27483 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _27483 + 68] = mem[idx + _27094 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27483 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _27483 + -mem[64] + 132
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19025 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19025] = 30
                                mem[_19025 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _19276 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19276 + 68] = mem[idx + _19025 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19276 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19276 + -mem[64] + 100
                                if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _20555 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20555] = 30
                                mem[_20555 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    _21065 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21065 + 68] = mem[idx + _20555 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21065 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21065 + -mem[64] + 100
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                _24643 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24643] = 30
                                mem[_24643 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    _25012 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25012 + 68] = mem[idx + _24643 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25012 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25012 + -mem[64] + 100
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _28458 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28458] = 40
                                mem[_28458 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _28977 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _28977 + 68] = mem[idx + _28458 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28977 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _28977 + -mem[64] + 132
                            if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg3 / 100:
                                _19024 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19024] = 30
                                mem[_19024 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    _19275 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19275 + 68] = mem[idx + _19024 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19275 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19275 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _20554 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20554] = 30
                                mem[_20554 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _21064 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21064 + 68] = mem[idx + _20554 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21064 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21064 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                _24642 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24642] = 30
                                mem[_24642 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _25011 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25011 + 68] = mem[idx + _24642 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25011 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25011 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _28455 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28455] = 40
                                mem[_28455 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _28976 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _28976 + 68] = mem[idx + _28455 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28976 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _28976 + -mem[64] + 132
                            if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                revert with 0, 17
                            if not 15 * arg3 / 100:
                                revert with 0, 18
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _19729 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19729] = 30
                            mem[_19729 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                _20044 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20044 + 68] = mem[idx + _19729 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20044 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20044 + -mem[64] + 100
                            if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _22107 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22107] = 30
                            mem[_22107 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                _22728 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22728 + 68] = mem[idx + _22107 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22728 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22728 + -mem[64] + 100
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                revert with 0, 17
                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                            _26036 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26036] = 30
                            mem[_26036 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                _26408 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26408 + 68] = mem[idx + _26036 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26408 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26408 + -mem[64] + 100
                            if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _30406 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_30406] = 40
                            mem[_30406 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _30981 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _30981 + 68] = mem[idx + _30406 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30981 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _30981 + -mem[64] + 132
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _18150 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18150] = 30
                            mem[_18150 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _18210 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18210 + 68] = mem[idx + _18150 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18210 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18210 + -mem[64] + 100
                            if t < stor1[stor5[idx]]:
                                revert with 0, 17
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _18541 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18541] = 30
                            mem[_18541 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                if s < stor2[stor5[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _18601 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18601 + 68] = mem[idx + _18541 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18601 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18601 + -mem[64] + 100
                        _18151 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18151] = 26
                        mem[_18151 + 32] = 'SafeMath: division by zero'
                        if not arg3:
                            if not 15 * arg3 / 100:
                                _18901 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18901] = 30
                                mem[_18901 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _19732 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19732] = 30
                                mem[_19732 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    _20048 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20048 + 68] = mem[idx + _19732 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20048 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20048 + -mem[64] + 100
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > -1:
                                    revert with 0, 17
                                if stor1[arg2] < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2]
                                _23455 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23455] = 30
                                mem[_23455 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _23842 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23842 + 68] = mem[idx + _23455 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23842 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23842 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _27485 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_27485] = 40
                                mem[_27485 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _28097 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _28097 + 68] = mem[idx + _27485 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28097 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _28097 + -mem[64] + 132
                            if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                revert with 0, 17
                            if not 15 * arg3 / 100:
                                revert with 0, 18
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _19278 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19278] = 30
                            mem[_19278 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                _19445 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19445 + 68] = mem[idx + _19278 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19445 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19445 + -mem[64] + 100
                            if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _21068 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21068] = 30
                            mem[_21068 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(arg1)]:
                                _21595 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21595 + 68] = mem[idx + _21068 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21595 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21595 + -mem[64] + 100
                            if stor1[address(arg1)] < 0:
                                revert with 0, 17
                            if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                            _25015 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25015] = 30
                            mem[_25015 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                _25456 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25456 + 68] = mem[idx + _25015 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25456 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25456 + -mem[64] + 100
                            if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _28983 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_28983] = 40
                            mem[_28983 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _29808 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _29808 + 68] = mem[idx + _28983 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29808 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _29808 + -mem[64] + 132
                        if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 15 * arg3 / 100:
                            _19277 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19277] = 30
                            mem[_19277 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg3 * stor6 / 100000000 * 10^18:
                                _19444 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19444 + 68] = mem[idx + _19277 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19444 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19444 + -mem[64] + 100
                            if arg3 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _21067 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21067] = 30
                            mem[_21067 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                _21594 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21594 + 68] = mem[idx + _21067 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21594 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21594 + -mem[64] + 100
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                            _25014 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25014] = 30
                            mem[_25014 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                _25455 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25455 + 68] = mem[idx + _25014 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25455 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25455 + -mem[64] + 100
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _28980 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_28980] = 40
                            mem[_28980 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _29807 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _29807 + 68] = mem[idx + _28980 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29807 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _29807 + -mem[64] + 132
                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                            revert with 0, 17
                        if not 15 * arg3 / 100:
                            revert with 0, 18
                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _20047 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20047] = 30
                        mem[_20047 + 32] = 'SafeMath: subtraction overflow'
                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                            _20556 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20556 + 68] = mem[idx + _20047 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20556 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20556 + -mem[64] + 100
                        if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        mem[0] = arg1
                        mem[32] = 1
                        _22731 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22731] = 30
                        mem[_22731 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                            _23346 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23346 + 68] = mem[idx + _22731 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23346 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23346 + -mem[64] + 100
                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                        if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                            revert with 0, 17
                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 1
                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                        _26412 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26412] = 30
                        mem[_26412 + 32] = 'SafeMath: subtraction overflow'
                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                            _26909 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26909 + 68] = mem[idx + _26412 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26909 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26909 + -mem[64] + 100
                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                        if totalFees > !(15 * arg3 / 100):
                            revert with 0, 17
                        if totalFees + (15 * arg3 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 15 * arg3 / 100
                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                        _30986 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_30986] = 40
                        mem[_30986 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                        mem[32] = sha3(address(arg1), 3)
                        if arg3 <= allowance[address(arg1)][msg.sender]:
                            if allowance[address(arg1)][msg.sender] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                            return 1
                        _32118 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _32118 + 68] = mem[idx + _30986 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32118 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _32118 + -mem[64] + 132
                    _17850 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_17850] = 26
                    mem[_17850 + 32] = 'SafeMath: division by zero'
                    if t < stor6 / 100000000 * 10^18:
                        _18271 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18271] = 26
                        mem[_18271 + 32] = 'SafeMath: division by zero'
                        if not arg3:
                            if not 15 * arg3 / 100:
                                _19023 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19023] = 30
                                mem[_19023 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _20553 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20553] = 30
                                mem[_20553 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > -1:
                                    revert with 0, 17
                                if stor1[arg2] < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2]
                                _24641 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24641] = 30
                                mem[_24641 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _28452 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28452] = 40
                                mem[_28452 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28452 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19728 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19728] = 30
                                mem[_19728 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22106 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22106] = 30
                                mem[_22106 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                _26035 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26035] = 30
                                mem[_26035 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _30403 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30403] = 40
                                mem[_30403 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30403 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg3 / 100:
                                _19727 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19727] = 30
                                mem[_19727 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22105 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22105] = 30
                                mem[_22105 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                _26034 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26034] = 30
                                mem[_26034 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _30400 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30400] = 40
                                mem[_30400 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30400 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21062 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21062] = 30
                                mem[_21062 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _23659 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23659] = 30
                                mem[_23659 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                _27321 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27321] = 30
                                mem[_27321 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _32848 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_32848] = 40
                                mem[_32848 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32848 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        _18270 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18270] = 26
                        mem[_18270 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            if not 15 * arg3 / 100:
                                _19021 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19021] = 30
                                mem[_19021 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _20551 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20551] = 30
                                mem[_20551 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > -1:
                                    revert with 0, 17
                                if stor1[arg2] < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2]
                                _24639 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24639] = 30
                                mem[_24639 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _28448 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28448] = 40
                                mem[_28448 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28448 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19726 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19726] = 30
                                mem[_19726 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 15 * arg3 / 100 * t / s:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22104 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22104] = 30
                                mem[_22104 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > !(-15 * arg3 / 100 * t / s):
                                    revert with 0, 17
                                if stor1[arg2] - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * t / s)
                                _26033 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26033] = 30
                                mem[_26033 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 15 * arg3 / 100 * t / s:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * t / s
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _30397 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30397] = 40
                                mem[_30397 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30397 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and t / s > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * t / s / arg3 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg3 / 100:
                                _19725 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19725] = 30
                                mem[_19725 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 * t / s < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22103 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22103] = 30
                                mem[_22103 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * t / s
                                if stor1[arg2] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                _26032 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26032] = 30
                                mem[_26032 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _30394 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30394] = 40
                                mem[_30394 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30394 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21060 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21060] = 30
                                mem[_21060 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * t / s > arg3 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 * t / s < 15 * arg3 / 100 * t / s:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _23657 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23657] = 30
                                mem[_23657 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * t / s
                                if stor1[arg2] > !((arg3 * t / s) - (15 * arg3 / 100 * t / s)):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s)
                                _27319 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27319] = 30
                                mem[_27319 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 15 * arg3 / 100 * t / s:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * t / s
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _32844 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_32844] = 40
                                mem[_32844 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32844 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
            else:
                mem[0] = arg2
                mem[32] = 4
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if stor4[address(arg2)]:
                    if not arg3 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg3:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg3 < 0:
                            revert with 0, 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _18063 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18063] = 26
                                mem[_18063 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    _18760 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18760] = 30
                                    mem[_18760 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19454 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19454] = 30
                                    mem[_19454 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _19747 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19747 + 68] = mem[idx + _19454 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19747 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19747 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _23024 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23024] = 30
                                    mem[_23024 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _23472 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _23472 + 68] = mem[idx + _23024 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23472 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23472 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _27117 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_27117] = 40
                                    mem[_27117 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _27516 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _27516 + 68] = mem[idx + _27117 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27516 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _27516 + -mem[64] + 132
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19043 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19043] = 30
                                mem[_19043 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    _19285 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19285 + 68] = mem[idx + _19043 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19285 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19285 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _20574 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20574] = 30
                                mem[_20574 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _21085 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21085 + 68] = mem[idx + _20574 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21085 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21085 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                _24671 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24671] = 30
                                mem[_24671 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _25032 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25032 + 68] = mem[idx + _24671 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25032 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25032 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _28495 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28495] = 40
                                mem[_28495 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _29019 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29019 + 68] = mem[idx + _28495 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29019 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29019 + -mem[64] + 132
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _18156 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18156] = 30
                                mem[_18156 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _18213 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18213 + 68] = mem[idx + _18156 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18213 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18213 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _18547 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18547] = 30
                                mem[_18547 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _18607 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18607 + 68] = mem[idx + _18547 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18607 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18607 + -mem[64] + 100
                            _18157 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18157] = 26
                            mem[_18157 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                _18907 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18907] = 30
                                mem[_18907 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _19748 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19748] = 30
                                mem[_19748 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    _20065 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20065 + 68] = mem[idx + _19748 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20065 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20065 + -mem[64] + 100
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > -1:
                                    revert with 0, 17
                                if stor1[arg2] < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2]
                                _23473 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23473] = 30
                                mem[_23473 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _23893 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23893 + 68] = mem[idx + _23473 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23893 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23893 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _27517 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_27517] = 40
                                mem[_27517 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _28117 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _28117 + 68] = mem[idx + _27517 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28117 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _28117 + -mem[64] + 132
                            if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _19286 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19286] = 30
                            mem[_19286 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg3 * stor6 / 100000000 * 10^18:
                                _19455 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19455 + 68] = mem[idx + _19286 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19455 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19455 + -mem[64] + 100
                            if arg3 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _21087 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21087] = 30
                            mem[_21087 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                _21613 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21613 + 68] = mem[idx + _21087 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21613 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21613 + -mem[64] + 100
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                            _25034 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25034] = 30
                            mem[_25034 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                _25487 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25487 + 68] = mem[idx + _25034 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25487 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25487 + -mem[64] + 100
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg3, arg1, arg2);
                            _29022 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_29022] = 40
                            mem[_29022 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _29831 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _29831 + 68] = mem[idx + _29022 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29831 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _29831 + -mem[64] + 132
                        _17859 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17859] = 26
                        mem[_17859 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 100000000 * 10^18:
                            _18277 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18277] = 26
                            mem[_18277 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                _19042 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19042] = 30
                                mem[_19042 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _20573 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20573] = 30
                                mem[_20573 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > -1:
                                    revert with 0, 17
                                if stor1[arg2] < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2]
                                _24670 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24670] = 30
                                mem[_24670 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _28492 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28492] = 40
                                mem[_28492 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28492 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19746 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19746] = 30
                                mem[_19746 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22121 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22121] = 30
                                mem[_22121 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                _26052 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26052] = 30
                                mem[_26052 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _30441 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30441] = 40
                                mem[_30441 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30441 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _18276 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18276] = 26
                            mem[_18276 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                _19040 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19040] = 30
                                mem[_19040 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _20572 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20572] = 30
                                mem[_20572 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > -1:
                                    revert with 0, 17
                                if stor1[arg2] < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2]
                                _24669 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24669] = 30
                                mem[_24669 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _28489 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28489] = 40
                                mem[_28489 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28489 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19745 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19745] = 30
                                mem[_19745 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 * t / s < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22120 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22120] = 30
                                mem[_22120 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * t / s
                                if stor1[arg2] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                _26051 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26051] = 30
                                mem[_26051 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _30438 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30438] = 40
                                mem[_30438 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30438 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        if arg3 / 100 and 15 > -1 / arg3 / 100:
                            revert with 0, 17
                        if not arg3 / 100:
                            revert with 0, 18
                        if 15 * arg3 / 100 / arg3 / 100 != 15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 15 * arg3 / 100 > arg3:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg3 < 15 * arg3 / 100:
                            revert with 0, 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _18062 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18062] = 26
                                mem[_18062 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    if not 15 * arg3 / 100:
                                        _18757 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18757] = 30
                                        mem[_18757 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _19451 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19451] = 30
                                        mem[_19451 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _19742 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19742 + 68] = mem[idx + _19451 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19742 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19742 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _23013 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23013] = 30
                                        mem[_23013 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _23467 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _23467 + 68] = mem[idx + _23013 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23467 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _23467 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _27110 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27110] = 40
                                        mem[_27110 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _27506 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _27506 + 68] = mem[idx + _27110 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27506 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _27506 + -mem[64] + 132
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19037 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19037] = 30
                                    mem[_19037 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _19282 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19282 + 68] = mem[idx + _19037 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19282 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19282 + -mem[64] + 100
                                    if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20568 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20568] = 30
                                    mem[_20568 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _21079 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21079 + 68] = mem[idx + _20568 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21079 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21079 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _24661 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24661] = 30
                                    mem[_24661 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        _25026 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25026 + 68] = mem[idx + _24661 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25026 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25026 + -mem[64] + 100
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _28484 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28484] = 40
                                    mem[_28484 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29006 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29006 + 68] = mem[idx + _28484 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29006 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29006 + -mem[64] + 132
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg3 / 100:
                                    _19036 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19036] = 30
                                    mem[_19036 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        _19281 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19281 + 68] = mem[idx + _19036 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19281 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19281 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20567 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20567] = 30
                                    mem[_20567 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _21078 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21078 + 68] = mem[idx + _20567 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21078 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21078 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _24660 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24660] = 30
                                    mem[_24660 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _25025 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25025 + 68] = mem[idx + _24660 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25025 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25025 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _28481 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28481] = 40
                                    mem[_28481 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29005 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29005 + 68] = mem[idx + _28481 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29005 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29005 + -mem[64] + 132
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19741 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19741] = 30
                                mem[_19741 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                    _20057 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20057 + 68] = mem[idx + _19741 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20057 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20057 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22117 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22117] = 30
                                mem[_22117 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _22745 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22745 + 68] = mem[idx + _22117 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22745 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22745 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                _26047 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26047] = 30
                                mem[_26047 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    _26427 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _26427 + 68] = mem[idx + _26047 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_26427 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _26427 + -mem[64] + 100
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _30432 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30432] = 40
                                mem[_30432 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _31009 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _31009 + 68] = mem[idx + _30432 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31009 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _31009 + -mem[64] + 132
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _18154 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18154] = 30
                                mem[_18154 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _18212 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18212 + 68] = mem[idx + _18154 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18212 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18212 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _18545 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18545] = 30
                                mem[_18545 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _18605 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18605 + 68] = mem[idx + _18545 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18605 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18605 + -mem[64] + 100
                            _18155 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18155] = 26
                            mem[_18155 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                if not 15 * arg3 / 100:
                                    _18905 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18905] = 30
                                    mem[_18905 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19744 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19744] = 30
                                    mem[_19744 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _20061 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20061 + 68] = mem[idx + _19744 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20061 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20061 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _23469 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23469] = 30
                                    mem[_23469 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _23880 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _23880 + 68] = mem[idx + _23469 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23880 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23880 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _27508 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_27508] = 40
                                    mem[_27508 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _28112 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _28112 + 68] = mem[idx + _27508 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_28112 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _28112 + -mem[64] + 132
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19284 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19284] = 30
                                mem[_19284 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _19453 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19453 + 68] = mem[idx + _19284 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19453 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19453 + -mem[64] + 100
                                if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _21082 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21082] = 30
                                mem[_21082 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    _21609 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21609 + 68] = mem[idx + _21082 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21609 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21609 + -mem[64] + 100
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                _25029 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25029] = 30
                                mem[_25029 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    _25481 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25481 + 68] = mem[idx + _25029 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25481 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25481 + -mem[64] + 100
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _29012 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_29012] = 40
                                mem[_29012 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _29825 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29825 + 68] = mem[idx + _29012 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29825 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29825 + -mem[64] + 132
                            if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg3 / 100:
                                _19283 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19283] = 30
                                mem[_19283 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    _19452 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19452 + 68] = mem[idx + _19283 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19452 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19452 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _21081 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21081] = 30
                                mem[_21081 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _21608 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21608 + 68] = mem[idx + _21081 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21608 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21608 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                _25028 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25028] = 30
                                mem[_25028 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _25480 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25480 + 68] = mem[idx + _25028 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25480 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25480 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _29009 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_29009] = 40
                                mem[_29009 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _29824 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29824 + 68] = mem[idx + _29009 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29824 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29824 + -mem[64] + 132
                            if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                revert with 0, 17
                            if not 15 * arg3 / 100:
                                revert with 0, 18
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20060 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20060] = 30
                            mem[_20060 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                _20569 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20569 + 68] = mem[idx + _20060 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20569 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20569 + -mem[64] + 100
                            if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _22748 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22748] = 30
                            mem[_22748 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                _23352 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23352 + 68] = mem[idx + _22748 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23352 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23352 + -mem[64] + 100
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                revert with 0, 17
                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                            _26431 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26431] = 30
                            mem[_26431 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                _26919 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26919 + 68] = mem[idx + _26431 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26919 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26919 + -mem[64] + 100
                            if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _31014 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_31014] = 40
                            mem[_31014 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _32134 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _32134 + 68] = mem[idx + _31014 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32134 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _32134 + -mem[64] + 132
                        _17856 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17856] = 26
                        mem[_17856 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 100000000 * 10^18:
                            _18275 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18275] = 26
                            mem[_18275 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                if not 15 * arg3 / 100:
                                    _19035 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19035] = 30
                                    mem[_19035 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20566 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20566] = 30
                                    mem[_20566 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _24659 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24659] = 30
                                    mem[_24659 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _28478 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28478] = 40
                                    mem[_28478 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28478 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19740 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19740] = 30
                                    mem[_19740 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22116 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22116] = 30
                                    mem[_22116 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _26046 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26046] = 30
                                    mem[_26046 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30429 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30429] = 40
                                    mem[_30429 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30429 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg3 / 100:
                                    _19739 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19739] = 30
                                    mem[_19739 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22115 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22115] = 30
                                    mem[_22115 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _26045 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26045] = 30
                                    mem[_26045 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30426 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30426] = 40
                                    mem[_30426 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30426 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _21076 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21076] = 30
                                    mem[_21076 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _23670 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23670] = 30
                                    mem[_23670 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _27330 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27330] = 30
                                    mem[_27330 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _32864 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_32864] = 40
                                    mem[_32864 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32864 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _18274 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18274] = 26
                            mem[_18274 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                if not 15 * arg3 / 100:
                                    _19033 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19033] = 30
                                    mem[_19033 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20564 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20564] = 30
                                    mem[_20564 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _24657 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24657] = 30
                                    mem[_24657 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _28474 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28474] = 40
                                    mem[_28474 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28474 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19738 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19738] = 30
                                    mem[_19738 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 15 * arg3 / 100 * t / s:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22114 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22114] = 30
                                    mem[_22114 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > !(-15 * arg3 / 100 * t / s):
                                        revert with 0, 17
                                    if stor1[arg2] - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * t / s)
                                    _26044 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26044] = 30
                                    mem[_26044 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg3 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * t / s
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30423 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30423] = 40
                                    mem[_30423 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30423 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg3 / 100:
                                    _19737 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19737] = 30
                                    mem[_19737 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * t / s < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22113 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22113] = 30
                                    mem[_22113 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * t / s
                                    if stor1[arg2] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                    _26043 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26043] = 30
                                    mem[_26043 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30420 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30420] = 40
                                    mem[_30420 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30420 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _21074 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21074] = 30
                                    mem[_21074 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * t / s > arg3 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * t / s < 15 * arg3 / 100 * t / s:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _23668 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23668] = 30
                                    mem[_23668 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * t / s
                                    if stor1[arg2] > !((arg3 * t / s) - (15 * arg3 / 100 * t / s)):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s)
                                    _27328 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27328] = 30
                                    mem[_27328 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg3 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * t / s
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _32860 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_32860] = 40
                                    mem[_32860 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32860 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    if not arg3 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg3:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg3 < 0:
                            revert with 0, 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _18065 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18065] = 26
                                mem[_18065 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    _18766 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18766] = 30
                                    mem[_18766 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19462 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19462] = 30
                                    mem[_19462 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _19759 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19759 + 68] = mem[idx + _19462 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19759 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19759 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _23048 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23048] = 30
                                    mem[_23048 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _23486 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _23486 + 68] = mem[idx + _23048 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23486 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23486 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _27133 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_27133] = 40
                                    mem[_27133 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _27539 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _27539 + 68] = mem[idx + _27133 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27539 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _27539 + -mem[64] + 132
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19055 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19055] = 30
                                mem[_19055 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    _19291 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19291 + 68] = mem[idx + _19055 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19291 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19291 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _20587 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20587] = 30
                                mem[_20587 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _21099 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21099 + 68] = mem[idx + _20587 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21099 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21099 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                _24689 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24689] = 30
                                mem[_24689 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _25046 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25046 + 68] = mem[idx + _24689 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25046 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25046 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _28521 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28521] = 40
                                mem[_28521 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _29048 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29048 + 68] = mem[idx + _28521 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29048 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29048 + -mem[64] + 132
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _18160 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18160] = 30
                                mem[_18160 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _18215 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18215 + 68] = mem[idx + _18160 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18215 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18215 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _18551 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18551] = 30
                                mem[_18551 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _18611 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18611 + 68] = mem[idx + _18551 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18611 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18611 + -mem[64] + 100
                            _18161 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18161] = 26
                            mem[_18161 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                _18911 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18911] = 30
                                mem[_18911 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _19760 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19760] = 30
                                mem[_19760 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    _20078 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20078 + 68] = mem[idx + _19760 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20078 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20078 + -mem[64] + 100
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > -1:
                                    revert with 0, 17
                                if stor1[arg2] < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2]
                                _23487 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23487] = 30
                                mem[_23487 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _23931 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23931 + 68] = mem[idx + _23487 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23931 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23931 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _27540 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_27540] = 40
                                mem[_27540 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _28132 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _28132 + 68] = mem[idx + _27540 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28132 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _28132 + -mem[64] + 132
                            if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _19292 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19292] = 30
                            mem[_19292 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg3 * stor6 / 100000000 * 10^18:
                                _19463 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19463 + 68] = mem[idx + _19292 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19463 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19463 + -mem[64] + 100
                            if arg3 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _21101 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21101] = 30
                            mem[_21101 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                _21627 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21627 + 68] = mem[idx + _21101 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21627 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21627 + -mem[64] + 100
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                            _25048 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25048] = 30
                            mem[_25048 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                _25512 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25512 + 68] = mem[idx + _25048 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25512 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25512 + -mem[64] + 100
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg3, arg1, arg2);
                            _29051 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_29051] = 40
                            mem[_29051 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _29848 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _29848 + 68] = mem[idx + _29051 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29848 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _29848 + -mem[64] + 132
                        _17865 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17865] = 26
                        mem[_17865 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 100000000 * 10^18:
                            _18281 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18281] = 26
                            mem[_18281 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                _19054 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19054] = 30
                                mem[_19054 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _20586 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20586] = 30
                                mem[_20586 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > -1:
                                    revert with 0, 17
                                if stor1[arg2] < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2]
                                _24688 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24688] = 30
                                mem[_24688 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _28518 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28518] = 40
                                mem[_28518 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28518 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19758 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19758] = 30
                                mem[_19758 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22131 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22131] = 30
                                mem[_22131 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                _26063 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26063] = 30
                                mem[_26063 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _30467 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30467] = 40
                                mem[_30467 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30467 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _18280 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18280] = 26
                            mem[_18280 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                _19052 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19052] = 30
                                mem[_19052 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _20585 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20585] = 30
                                mem[_20585 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > -1:
                                    revert with 0, 17
                                if stor1[arg2] < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2]
                                _24687 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24687] = 30
                                mem[_24687 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _28515 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28515] = 40
                                mem[_28515 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28515 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19757 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19757] = 30
                                mem[_19757 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 * t / s < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22130 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22130] = 30
                                mem[_22130 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * t / s
                                if stor1[arg2] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                _26062 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26062] = 30
                                mem[_26062 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _30464 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30464] = 40
                                mem[_30464 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30464 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        if arg3 / 100 and 15 > -1 / arg3 / 100:
                            revert with 0, 17
                        if not arg3 / 100:
                            revert with 0, 18
                        if 15 * arg3 / 100 / arg3 / 100 != 15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 15 * arg3 / 100 > arg3:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg3 < 15 * arg3 / 100:
                            revert with 0, 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _18064 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18064] = 26
                                mem[_18064 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    if not 15 * arg3 / 100:
                                        _18763 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18763] = 30
                                        mem[_18763 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _19459 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19459] = 30
                                        mem[_19459 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _19754 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19754 + 68] = mem[idx + _19459 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19754 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19754 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _23037 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23037] = 30
                                        mem[_23037 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _23481 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _23481 + 68] = mem[idx + _23037 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23481 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _23481 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _27126 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27126] = 40
                                        mem[_27126 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _27529 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _27529 + 68] = mem[idx + _27126 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27529 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _27529 + -mem[64] + 132
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19049 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19049] = 30
                                    mem[_19049 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _19288 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19288 + 68] = mem[idx + _19049 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19288 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19288 + -mem[64] + 100
                                    if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20581 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20581] = 30
                                    mem[_20581 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _21093 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21093 + 68] = mem[idx + _20581 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21093 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21093 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _24679 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24679] = 30
                                    mem[_24679 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        _25040 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25040 + 68] = mem[idx + _24679 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25040 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25040 + -mem[64] + 100
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _28510 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28510] = 40
                                    mem[_28510 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29035 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29035 + 68] = mem[idx + _28510 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29035 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29035 + -mem[64] + 132
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg3 / 100:
                                    _19048 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19048] = 30
                                    mem[_19048 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        _19287 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19287 + 68] = mem[idx + _19048 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19287 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19287 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20580 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20580] = 30
                                    mem[_20580 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _21092 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21092 + 68] = mem[idx + _20580 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21092 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21092 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _24678 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24678] = 30
                                    mem[_24678 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _25039 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25039 + 68] = mem[idx + _24678 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25039 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25039 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _28507 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28507] = 40
                                    mem[_28507 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29034 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29034 + 68] = mem[idx + _28507 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29034 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29034 + -mem[64] + 132
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19753 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19753] = 30
                                mem[_19753 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                    _20070 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20070 + 68] = mem[idx + _19753 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20070 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20070 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22127 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22127] = 30
                                mem[_22127 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _22762 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22762 + 68] = mem[idx + _22127 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22762 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22762 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                _26058 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26058] = 30
                                mem[_26058 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    _26446 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _26446 + 68] = mem[idx + _26058 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_26446 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _26446 + -mem[64] + 100
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _30458 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30458] = 40
                                mem[_30458 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _31037 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _31037 + 68] = mem[idx + _30458 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31037 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _31037 + -mem[64] + 132
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _18158 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18158] = 30
                                mem[_18158 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _18214 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18214 + 68] = mem[idx + _18158 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18214 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18214 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _18549 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18549] = 30
                                mem[_18549 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _18609 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18609 + 68] = mem[idx + _18549 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18609 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18609 + -mem[64] + 100
                            _18159 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18159] = 26
                            mem[_18159 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                if not 15 * arg3 / 100:
                                    _18909 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18909] = 30
                                    mem[_18909 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19756 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19756] = 30
                                    mem[_19756 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _20074 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20074 + 68] = mem[idx + _19756 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20074 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20074 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _23483 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23483] = 30
                                    mem[_23483 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _23918 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _23918 + 68] = mem[idx + _23483 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23918 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23918 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _27531 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_27531] = 40
                                    mem[_27531 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _28127 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _28127 + 68] = mem[idx + _27531 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_28127 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _28127 + -mem[64] + 132
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19290 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19290] = 30
                                mem[_19290 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _19461 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19461 + 68] = mem[idx + _19290 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19461 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19461 + -mem[64] + 100
                                if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _21096 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21096] = 30
                                mem[_21096 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    _21623 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21623 + 68] = mem[idx + _21096 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21623 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21623 + -mem[64] + 100
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                _25043 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25043] = 30
                                mem[_25043 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    _25506 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25506 + 68] = mem[idx + _25043 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25506 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25506 + -mem[64] + 100
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _29041 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_29041] = 40
                                mem[_29041 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _29842 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29842 + 68] = mem[idx + _29041 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29842 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29842 + -mem[64] + 132
                            if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg3 / 100:
                                _19289 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19289] = 30
                                mem[_19289 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    _19460 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19460 + 68] = mem[idx + _19289 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19460 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19460 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _21095 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21095] = 30
                                mem[_21095 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _21622 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21622 + 68] = mem[idx + _21095 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21622 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21622 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                _25042 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25042] = 30
                                mem[_25042 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _25505 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25505 + 68] = mem[idx + _25042 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25505 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25505 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _29038 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_29038] = 40
                                mem[_29038 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _29841 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29841 + 68] = mem[idx + _29038 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29841 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29841 + -mem[64] + 132
                            if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                revert with 0, 17
                            if not 15 * arg3 / 100:
                                revert with 0, 18
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20073 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20073] = 30
                            mem[_20073 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                _20582 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20582 + 68] = mem[idx + _20073 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20582 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20582 + -mem[64] + 100
                            if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _22765 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22765] = 30
                            mem[_22765 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                _23358 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23358 + 68] = mem[idx + _22765 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23358 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23358 + -mem[64] + 100
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                revert with 0, 17
                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                            _26450 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26450] = 30
                            mem[_26450 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                _26929 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26929 + 68] = mem[idx + _26450 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26929 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26929 + -mem[64] + 100
                            if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _31042 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_31042] = 40
                            mem[_31042 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _32150 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _32150 + 68] = mem[idx + _31042 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32150 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _32150 + -mem[64] + 132
                        _17862 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17862] = 26
                        mem[_17862 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 100000000 * 10^18:
                            _18279 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18279] = 26
                            mem[_18279 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                if not 15 * arg3 / 100:
                                    _19047 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19047] = 30
                                    mem[_19047 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20579 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20579] = 30
                                    mem[_20579 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _24677 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24677] = 30
                                    mem[_24677 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _28504 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28504] = 40
                                    mem[_28504 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28504 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19752 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19752] = 30
                                    mem[_19752 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22126 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22126] = 30
                                    mem[_22126 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _26057 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26057] = 30
                                    mem[_26057 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30455 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30455] = 40
                                    mem[_30455 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30455 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg3 / 100:
                                    _19751 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19751] = 30
                                    mem[_19751 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22125 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22125] = 30
                                    mem[_22125 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _26056 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26056] = 30
                                    mem[_26056 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30452 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30452] = 40
                                    mem[_30452 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30452 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _21090 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21090] = 30
                                    mem[_21090 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _23681 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23681] = 30
                                    mem[_23681 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _27339 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27339] = 30
                                    mem[_27339 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _32880 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_32880] = 40
                                    mem[_32880 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32880 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _18278 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18278] = 26
                            mem[_18278 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                if not 15 * arg3 / 100:
                                    _19045 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19045] = 30
                                    mem[_19045 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20577 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20577] = 30
                                    mem[_20577 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _24675 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24675] = 30
                                    mem[_24675 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _28500 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28500] = 40
                                    mem[_28500 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28500 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19750 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19750] = 30
                                    mem[_19750 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 15 * arg3 / 100 * t / s:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22124 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22124] = 30
                                    mem[_22124 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > !(-15 * arg3 / 100 * t / s):
                                        revert with 0, 17
                                    if stor1[arg2] - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * t / s)
                                    _26055 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26055] = 30
                                    mem[_26055 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg3 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * t / s
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30449 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30449] = 40
                                    mem[_30449 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30449 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg3 / 100:
                                    _19749 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19749] = 30
                                    mem[_19749 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * t / s < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22123 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22123] = 30
                                    mem[_22123 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * t / s
                                    if stor1[arg2] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                    _26054 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26054] = 30
                                    mem[_26054 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30446 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30446] = 40
                                    mem[_30446 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30446 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _21088 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21088] = 30
                                    mem[_21088 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * t / s > arg3 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * t / s < 15 * arg3 / 100 * t / s:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _23679 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23679] = 30
                                    mem[_23679 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * t / s
                                    if stor1[arg2] > !((arg3 * t / s) - (15 * arg3 / 100 * t / s)):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s)
                                    _27337 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27337] = 30
                                    mem[_27337 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg3 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * t / s
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _32876 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_32876] = 40
                                    mem[_32876 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32876 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
        else:
            mem[0] = arg2
            mem[32] = 4
            if stor4[address(arg2)]:
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if not arg3 / 100:
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 0 > arg3:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg3 < 0:
                        revert with 0, 17
                    idx = 0
                    s = 100000000 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _18073 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18073] = 26
                            mem[_18073 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                _18790 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18790] = 30
                                mem[_18790 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _19494 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19494] = 30
                                mem[_19494 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    _19807 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19807 + 68] = mem[idx + _19494 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19807 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19807 + -mem[64] + 100
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] += arg3
                                if stor1[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg2)] < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                _24760 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24760] = 30
                                mem[_24760 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _25095 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25095 + 68] = mem[idx + _24760 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25095 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25095 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _28615 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28615] = 40
                                mem[_28615 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _29160 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29160 + 68] = mem[idx + _28615 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29160 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29160 + -mem[64] + 132
                            if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _19103 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19103] = 30
                            mem[_19103 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg3 * stor6 / 100000000 * 10^18:
                                _19315 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19315 + 68] = mem[idx + _19103 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19315 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19315 + -mem[64] + 100
                            if arg3 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _20639 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20639] = 30
                            mem[_20639 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                _21155 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21155 + 68] = mem[idx + _20639 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21155 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21155 + -mem[64] + 100
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor2[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor2[address(arg2)] + arg3 < stor2[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg2)] += arg3
                            if stor1[address(arg2)] > !(arg3 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] += arg3 * stor6 / 100000000 * 10^18
                            _26111 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26111] = 30
                            mem[_26111 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                _26525 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26525 + 68] = mem[idx + _26111 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26525 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26525 + -mem[64] + 100
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg3, arg1, arg2);
                            _30572 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_30572] = 40
                            mem[_30572 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _31162 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _31162 + 68] = mem[idx + _30572 + 32]
                                idx = idx + 32
                                continue 
                            mem[_31162 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _31162 + -mem[64] + 132
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _18176 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18176] = 30
                            mem[_18176 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _18223 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18223 + 68] = mem[idx + _18176 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18223 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18223 + -mem[64] + 100
                            if t < stor1[stor5[idx]]:
                                revert with 0, 17
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _18567 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18567] = 30
                            mem[_18567 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                if s < stor2[stor5[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _18627 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18627 + 68] = mem[idx + _18567 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18627 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18627 + -mem[64] + 100
                        _18177 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18177] = 26
                        mem[_18177 + 32] = 'SafeMath: division by zero'
                        if not arg3:
                            _18927 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18927] = 30
                            mem[_18927 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _19808 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19808] = 30
                            mem[_19808 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(arg1)]:
                                _20130 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20130 + 68] = mem[idx + _19808 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20130 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20130 + -mem[64] + 100
                            if stor1[address(arg1)] < 0:
                                revert with 0, 17
                            if stor2[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor2[address(arg2)] + arg3 < stor2[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg2)] += arg3
                            if stor1[address(arg2)] > -1:
                                revert with 0, 17
                            if stor1[address(arg2)] < stor1[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            _25096 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25096] = 30
                            mem[_25096 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                _25631 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25631 + 68] = mem[idx + _25096 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25631 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25631 + -mem[64] + 100
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg3, arg1, arg2);
                            _29161 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_29161] = 40
                            mem[_29161 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _29916 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _29916 + 68] = mem[idx + _29161 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29916 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _29916 + -mem[64] + 132
                        if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _19316 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19316] = 30
                        mem[_19316 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                            _19495 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19495 + 68] = mem[idx + _19316 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19495 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19495 + -mem[64] + 100
                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                            revert with 0, 17
                        mem[0] = arg1
                        mem[32] = 1
                        _21157 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21157] = 30
                        mem[_21157 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                            _21683 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21683 + 68] = mem[idx + _21157 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21683 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21683 + -mem[64] + 100
                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                        if stor2[address(arg2)] > !arg3:
                            revert with 0, 17
                        if stor2[address(arg2)] + arg3 < stor2[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[address(arg2)] += arg3
                        if stor1[address(arg2)] > !(arg3 * stor6 / 100000000 * 10^18):
                            revert with 0, 17
                        if stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 1
                        stor1[address(arg2)] += arg3 * stor6 / 100000000 * 10^18
                        _26527 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26527] = 30
                        mem[_26527 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor6:
                            _26988 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26988 + 68] = mem[idx + _26527 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26988 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26988 + -mem[64] + 100
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg3, arg1, arg2);
                        _31165 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_31165] = 40
                        mem[_31165 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                        mem[32] = sha3(address(arg1), 3)
                        if arg3 <= allowance[address(arg1)][msg.sender]:
                            if allowance[address(arg1)][msg.sender] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                            return 1
                        _32222 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _32222 + 68] = mem[idx + _31165 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32222 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _32222 + -mem[64] + 132
                    _17889 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_17889] = 26
                    mem[_17889 + 32] = 'SafeMath: division by zero'
                    if t < stor6 / 100000000 * 10^18:
                        _18297 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18297] = 26
                        mem[_18297 + 32] = 'SafeMath: division by zero'
                        if not arg3:
                            _19102 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19102] = 30
                            mem[_19102 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _20638 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20638] = 30
                            mem[_20638 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(arg1)] < 0:
                                revert with 0, 17
                            if stor2[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor2[address(arg2)] + arg3 < stor2[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg2)] += arg3
                            if stor1[address(arg2)] > -1:
                                revert with 0, 17
                            if stor1[address(arg2)] < stor1[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            _26110 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26110] = 30
                            mem[_26110 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg3, arg1, arg2);
                            _30569 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_30569] = 40
                            mem[_30569 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            if arg3 > allowance[address(arg1)][msg.sender]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30569 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _19806 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19806] = 30
                            mem[_19806 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg3 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _22171 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22171] = 30
                            mem[_22171 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor2[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor2[address(arg2)] + arg3 < stor2[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg2)] += arg3
                            if stor1[address(arg2)] > !(arg3 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] += arg3 * stor6 / 100000000 * 10^18
                            _27382 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27382] = 30
                            mem[_27382 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg3, arg1, arg2);
                            _32961 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_32961] = 40
                            mem[_32961 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            if arg3 > allowance[address(arg1)][msg.sender]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32961 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        _18296 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18296] = 26
                        mem[_18296 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            _19100 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19100] = 30
                            mem[_19100 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = arg1
                            mem[32] = 1
                            _20637 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20637] = 30
                            mem[_20637 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(arg1)] < 0:
                                revert with 0, 17
                            if stor2[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor2[address(arg2)] + arg3 < stor2[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg2)] += arg3
                            if stor1[address(arg2)] > -1:
                                revert with 0, 17
                            if stor1[address(arg2)] < stor1[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            _26109 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26109] = 30
                            mem[_26109 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg3, arg1, arg2);
                            _30566 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_30566] = 40
                            mem[_30566 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            if arg3 > allowance[address(arg1)][msg.sender]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30566 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and t / s > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * t / s / arg3 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _19805 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19805] = 30
                            mem[_19805 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg3 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg3 * t / s < 0:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _22170 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22170] = 30
                            mem[_22170 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * t / s > stor1[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(arg1)] < arg3 * t / s:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * t / s
                            if stor2[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor2[address(arg2)] + arg3 < stor2[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg2)] += arg3
                            if stor1[address(arg2)] > !(arg3 * t / s):
                                revert with 0, 17
                            if stor1[address(arg2)] + (arg3 * t / s) < stor1[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] += arg3 * t / s
                            _27381 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27381] = 30
                            mem[_27381 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg3, arg1, arg2);
                            _32958 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_32958] = 40
                            mem[_32958 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            if arg3 > allowance[address(arg1)][msg.sender]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32958 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    if arg3 / 100 and 15 > -1 / arg3 / 100:
                        revert with 0, 17
                    if not arg3 / 100:
                        revert with 0, 18
                    if 15 * arg3 / 100 / arg3 / 100 != 15:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[64] = 224
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if 15 * arg3 / 100 > arg3:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg3 < 15 * arg3 / 100:
                        revert with 0, 17
                    idx = 0
                    s = 100000000 * 10^18
                    t = stor6
                    while idx < stor5.length:
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        if stor1[stor5[idx]] > t:
                            _18072 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18072] = 26
                            mem[_18072 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                if not 15 * arg3 / 100:
                                    _18787 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18787] = 30
                                    mem[_18787 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19491 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19491] = 30
                                    mem[_19491 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _19802 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19802 + 68] = mem[idx + _19491 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19802 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19802 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                    if stor1[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor1[address(arg2)] < stor1[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    _24748 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24748] = 30
                                    mem[_24748 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _25093 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25093 + 68] = mem[idx + _24748 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25093 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25093 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _28608 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28608] = 40
                                    mem[_28608 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29150 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29150 + 68] = mem[idx + _28608 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29150 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29150 + -mem[64] + 132
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19097 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19097] = 30
                                mem[_19097 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _19312 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19312 + 68] = mem[idx + _19097 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19312 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19312 + -mem[64] + 100
                                if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _20633 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20633] = 30
                                mem[_20633 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    _21149 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21149 + 68] = mem[idx + _20633 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21149 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21149 + -mem[64] + 100
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                if stor1[address(arg2)] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg2)] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                _26101 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26101] = 30
                                mem[_26101 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    _26519 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _26519 + 68] = mem[idx + _26101 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_26519 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _26519 + -mem[64] + 100
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _30561 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30561] = 40
                                mem[_30561 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _31149 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _31149 + 68] = mem[idx + _30561 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31149 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _31149 + -mem[64] + 132
                            if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg3 / 100:
                                _19096 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19096] = 30
                                mem[_19096 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    _19311 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19311 + 68] = mem[idx + _19096 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19311 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19311 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _20632 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20632] = 30
                                mem[_20632 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _21148 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21148 + 68] = mem[idx + _20632 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21148 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21148 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                if stor1[address(arg2)] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] += arg3 * stor6 / 100000000 * 10^18
                                _26100 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26100] = 30
                                mem[_26100 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _26518 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _26518 + 68] = mem[idx + _26100 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_26518 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _26518 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _30558 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30558] = 40
                                mem[_30558 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _31148 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _31148 + 68] = mem[idx + _30558 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31148 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _31148 + -mem[64] + 132
                            if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                revert with 0, 17
                            if not 15 * arg3 / 100:
                                revert with 0, 18
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _19801 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19801] = 30
                            mem[_19801 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                _20122 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20122 + 68] = mem[idx + _19801 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20122 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20122 + -mem[64] + 100
                            if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _22167 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22167] = 30
                            mem[_22167 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                _22830 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22830 + 68] = mem[idx + _22167 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22830 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22830 + -mem[64] + 100
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                revert with 0, 17
                            if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                            if stor1[address(arg2)] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                revert with 0, 17
                            if stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                            _27377 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_27377] = 30
                            mem[_27377 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                _27919 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27919 + 68] = mem[idx + _27377 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27919 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27919 + -mem[64] + 100
                            if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _32952 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_32952] = 40
                            mem[_32952 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _33414 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _33414 + 68] = mem[idx + _32952 + 32]
                                idx = idx + 32
                                continue 
                            mem[_33414 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _33414 + -mem[64] + 132
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        if stor2[stor5[idx]] <= s:
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            _18174 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18174] = 30
                            mem[_18174 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor5[idx]] > t:
                                _18222 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18222 + 68] = mem[idx + _18174 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18222 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18222 + -mem[64] + 100
                            if t < stor1[stor5[idx]]:
                                revert with 0, 17
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            _18565 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18565] = 30
                            mem[_18565 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor5[idx]] <= s:
                                if s < stor2[stor5[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor5[idx]]
                                t = t - stor1[stor5[idx]]
                                continue 
                            _18625 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18625 + 68] = mem[idx + _18565 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18625 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18625 + -mem[64] + 100
                        _18175 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18175] = 26
                        mem[_18175 + 32] = 'SafeMath: division by zero'
                        if not arg3:
                            if not 15 * arg3 / 100:
                                _18925 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18925] = 30
                                mem[_18925 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _19804 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19804] = 30
                                mem[_19804 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    _20126 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20126 + 68] = mem[idx + _19804 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20126 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20126 + -mem[64] + 100
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                if stor1[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg2)] < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                _25094 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25094] = 30
                                mem[_25094 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _25618 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25618 + 68] = mem[idx + _25094 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25618 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25618 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _29152 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_29152] = 40
                                mem[_29152 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _29911 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29911 + 68] = mem[idx + _29152 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29911 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29911 + -mem[64] + 132
                            if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                revert with 0, 17
                            if not 15 * arg3 / 100:
                                revert with 0, 18
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _19314 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19314] = 30
                            mem[_19314 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                _19493 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19493 + 68] = mem[idx + _19314 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19493 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19493 + -mem[64] + 100
                            if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _21152 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21152] = 30
                            mem[_21152 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(arg1)]:
                                _21679 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21679 + 68] = mem[idx + _21152 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21679 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21679 + -mem[64] + 100
                            if stor1[address(arg1)] < 0:
                                revert with 0, 17
                            if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                revert with 0, 17
                            if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                            if stor1[address(arg2)] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[address(arg2)] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                            _26522 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26522] = 30
                            mem[_26522 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                _26982 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26982 + 68] = mem[idx + _26522 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26982 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26982 + -mem[64] + 100
                            if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _31155 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_31155] = 40
                            mem[_31155 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _32216 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _32216 + 68] = mem[idx + _31155 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32216 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _32216 + -mem[64] + 132
                        if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 15 * arg3 / 100:
                            _19313 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19313] = 30
                            mem[_19313 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg3 * stor6 / 100000000 * 10^18:
                                _19492 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19492 + 68] = mem[idx + _19313 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19492 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19492 + -mem[64] + 100
                            if arg3 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _21151 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21151] = 30
                            mem[_21151 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                _21678 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21678 + 68] = mem[idx + _21151 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21678 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21678 + -mem[64] + 100
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                revert with 0, 17
                            if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                            if stor1[address(arg2)] > !(arg3 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] += arg3 * stor6 / 100000000 * 10^18
                            _26521 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26521] = 30
                            mem[_26521 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                _26981 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26981 + 68] = mem[idx + _26521 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26981 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26981 + -mem[64] + 100
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _31152 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_31152] = 40
                            mem[_31152 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _32215 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _32215 + 68] = mem[idx + _31152 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32215 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _32215 + -mem[64] + 132
                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                            revert with 0, 17
                        if not 15 * arg3 / 100:
                            revert with 0, 18
                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _20125 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20125] = 30
                        mem[_20125 + 32] = 'SafeMath: subtraction overflow'
                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                            _20634 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20634 + 68] = mem[idx + _20125 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20634 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20634 + -mem[64] + 100
                        if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        mem[0] = arg1
                        mem[32] = 1
                        _22833 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22833] = 30
                        mem[_22833 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                            _23382 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23382 + 68] = mem[idx + _22833 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23382 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23382 + -mem[64] + 100
                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                        if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                            revert with 0, 17
                        if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                        if stor1[address(arg2)] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                            revert with 0, 17
                        if stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 1
                        stor1[address(arg2)] = stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                        _27923 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27923] = 30
                        mem[_27923 + 32] = 'SafeMath: subtraction overflow'
                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                            _28364 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28364 + 68] = mem[idx + _27923 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28364 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28364 + -mem[64] + 100
                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                        if totalFees > !(15 * arg3 / 100):
                            revert with 0, 17
                        if totalFees + (15 * arg3 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 15 * arg3 / 100
                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                        _33419 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_33419] = 40
                        mem[_33419 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                        mem[32] = sha3(address(arg1), 3)
                        if arg3 <= allowance[address(arg1)][msg.sender]:
                            if allowance[address(arg1)][msg.sender] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                            return 1
                        _34322 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _34322 + 68] = mem[idx + _33419 + 32]
                            idx = idx + 32
                            continue 
                        mem[_34322 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _34322 + -mem[64] + 132
                    _17886 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_17886] = 26
                    mem[_17886 + 32] = 'SafeMath: division by zero'
                    if t < stor6 / 100000000 * 10^18:
                        _18295 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18295] = 26
                        mem[_18295 + 32] = 'SafeMath: division by zero'
                        if not arg3:
                            if not 15 * arg3 / 100:
                                _19095 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19095] = 30
                                mem[_19095 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _20631 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20631] = 30
                                mem[_20631 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                if stor1[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg2)] < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                _26099 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26099] = 30
                                mem[_26099 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _30555 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30555] = 40
                                mem[_30555 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30555 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19800 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19800] = 30
                                mem[_19800 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22166 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22166] = 30
                                mem[_22166 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                if stor1[address(arg2)] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg2)] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                _27376 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27376] = 30
                                mem[_27376 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _32949 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_32949] = 40
                                mem[_32949 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32949 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg3 / 100:
                                _19799 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19799] = 30
                                mem[_19799 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22165 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22165] = 30
                                mem[_22165 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                if stor1[address(arg2)] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] += arg3 * stor6 / 100000000 * 10^18
                                _27375 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27375] = 30
                                mem[_27375 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _32946 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_32946] = 40
                                mem[_32946 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32946 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21146 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21146] = 30
                                mem[_21146 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _23725 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23725] = 30
                                mem[_23725 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                if stor1[address(arg2)] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                _28875 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28875] = 30
                                mem[_28875 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _34782 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_34782] = 40
                                mem[_34782 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_34782 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        _18294 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18294] = 26
                        mem[_18294 + 32] = 'SafeMath: division by zero'
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg3:
                            if not 15 * arg3 / 100:
                                _19093 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19093] = 30
                                mem[_19093 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _20629 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20629] = 30
                                mem[_20629 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                if stor1[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg2)] < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                _26098 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26098] = 30
                                mem[_26098 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _30551 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30551] = 40
                                mem[_30551 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30551 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19798 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19798] = 30
                                mem[_19798 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < 15 * arg3 / 100 * t / s:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22164 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22164] = 30
                                mem[_22164 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                if stor1[address(arg2)] > !(-15 * arg3 / 100 * t / s):
                                    revert with 0, 17
                                if stor1[address(arg2)] - (15 * arg3 / 100 * t / s) < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] += -15 * arg3 / 100 * t / s
                                _27374 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27374] = 30
                                mem[_27374 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 15 * arg3 / 100 * t / s:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * t / s
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _32943 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_32943] = 40
                                mem[_32943 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32943 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 and t / s > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * t / s / arg3 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg3 / 100:
                                _19797 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19797] = 30
                                mem[_19797 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 * t / s < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22163 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22163] = 30
                                mem[_22163 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * t / s
                                if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                if stor1[address(arg2)] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor1[address(arg2)] + (arg3 * t / s) < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] += arg3 * t / s
                                _27373 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27373] = 30
                                mem[_27373 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _32940 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_32940] = 40
                                mem[_32940 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32940 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _21144 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21144] = 30
                                mem[_21144 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * t / s > arg3 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 * t / s < 15 * arg3 / 100 * t / s:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _23723 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23723] = 30
                                mem[_23723 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * t / s
                                if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                if stor1[address(arg2)] > !((arg3 * t / s) - (15 * arg3 / 100 * t / s)):
                                    revert with 0, 17
                                if stor1[address(arg2)] + (arg3 * t / s) - (15 * arg3 / 100 * t / s) < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[address(arg2)] + (arg3 * t / s) - (15 * arg3 / 100 * t / s)
                                _28873 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_28873] = 30
                                mem[_28873 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * t / s > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 15 * arg3 / 100 * t / s:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * t / s
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _34778 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_34778] = 40
                                mem[_34778 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_34778 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
            else:
                mem[0] = arg1
                mem[32] = 4
                if stor4[address(arg1)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not arg3 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg3:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg3 < 0:
                            revert with 0, 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _18067 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18067] = 26
                                mem[_18067 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    _18772 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18772] = 30
                                    mem[_18772 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19470 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19470] = 30
                                    mem[_19470 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _19771 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19771 + 68] = mem[idx + _19470 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19771 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19771 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _23072 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23072] = 30
                                    mem[_23072 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _23500 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _23500 + 68] = mem[idx + _23072 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23500 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23500 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _27149 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_27149] = 40
                                    mem[_27149 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _27562 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _27562 + 68] = mem[idx + _27149 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27562 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _27562 + -mem[64] + 132
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19067 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19067] = 30
                                mem[_19067 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    _19297 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19297 + 68] = mem[idx + _19067 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19297 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19297 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _20600 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20600] = 30
                                mem[_20600 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _21113 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21113 + 68] = mem[idx + _20600 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21113 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21113 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                _24707 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24707] = 30
                                mem[_24707 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _25060 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25060 + 68] = mem[idx + _24707 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25060 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25060 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _28547 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28547] = 40
                                mem[_28547 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _29077 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29077 + 68] = mem[idx + _28547 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29077 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29077 + -mem[64] + 132
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _18164 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18164] = 30
                                mem[_18164 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _18217 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18217 + 68] = mem[idx + _18164 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18217 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18217 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _18555 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18555] = 30
                                mem[_18555 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _18615 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18615 + 68] = mem[idx + _18555 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18615 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18615 + -mem[64] + 100
                            _18165 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18165] = 26
                            mem[_18165 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                _18915 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18915] = 30
                                mem[_18915 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _19772 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19772] = 30
                                mem[_19772 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    _20091 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20091 + 68] = mem[idx + _19772 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20091 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20091 + -mem[64] + 100
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > -1:
                                    revert with 0, 17
                                if stor1[arg2] < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2]
                                _23501 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23501] = 30
                                mem[_23501 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _23969 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23969 + 68] = mem[idx + _23501 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23969 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23969 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _27563 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_27563] = 40
                                mem[_27563 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _28147 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _28147 + 68] = mem[idx + _27563 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28147 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _28147 + -mem[64] + 132
                            if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _19298 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19298] = 30
                            mem[_19298 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg3 * stor6 / 100000000 * 10^18:
                                _19471 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19471 + 68] = mem[idx + _19298 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19471 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19471 + -mem[64] + 100
                            if arg3 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _21115 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21115] = 30
                            mem[_21115 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                _21641 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21641 + 68] = mem[idx + _21115 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21641 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21641 + -mem[64] + 100
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                            _25062 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25062] = 30
                            mem[_25062 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                _25537 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25537 + 68] = mem[idx + _25062 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25537 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25537 + -mem[64] + 100
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg3, arg1, arg2);
                            _29080 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_29080] = 40
                            mem[_29080 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _29865 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _29865 + 68] = mem[idx + _29080 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29865 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _29865 + -mem[64] + 132
                        _17871 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17871] = 26
                        mem[_17871 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 100000000 * 10^18:
                            _18285 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18285] = 26
                            mem[_18285 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                _19066 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19066] = 30
                                mem[_19066 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _20599 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20599] = 30
                                mem[_20599 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > -1:
                                    revert with 0, 17
                                if stor1[arg2] < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2]
                                _24706 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24706] = 30
                                mem[_24706 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _28544 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28544] = 40
                                mem[_28544 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28544 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19770 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19770] = 30
                                mem[_19770 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22141 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22141] = 30
                                mem[_22141 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                _26074 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26074] = 30
                                mem[_26074 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _30493 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30493] = 40
                                mem[_30493 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30493 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _18284 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18284] = 26
                            mem[_18284 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                _19064 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19064] = 30
                                mem[_19064 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _20598 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20598] = 30
                                mem[_20598 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > -1:
                                    revert with 0, 17
                                if stor1[arg2] < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2]
                                _24705 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24705] = 30
                                mem[_24705 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _28541 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28541] = 40
                                mem[_28541 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28541 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19769 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19769] = 30
                                mem[_19769 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 * t / s < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22140 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22140] = 30
                                mem[_22140 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * t / s
                                if stor1[arg2] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                _26073 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26073] = 30
                                mem[_26073 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _30490 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30490] = 40
                                mem[_30490 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30490 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        if arg3 / 100 and 15 > -1 / arg3 / 100:
                            revert with 0, 17
                        if not arg3 / 100:
                            revert with 0, 18
                        if 15 * arg3 / 100 / arg3 / 100 != 15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 15 * arg3 / 100 > arg3:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg3 < 15 * arg3 / 100:
                            revert with 0, 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _18066 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18066] = 26
                                mem[_18066 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    if not 15 * arg3 / 100:
                                        _18769 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18769] = 30
                                        mem[_18769 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _19467 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19467] = 30
                                        mem[_19467 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _19766 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19766 + 68] = mem[idx + _19467 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19766 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19766 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _23061 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23061] = 30
                                        mem[_23061 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _23495 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _23495 + 68] = mem[idx + _23061 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23495 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _23495 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _27142 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27142] = 40
                                        mem[_27142 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _27552 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _27552 + 68] = mem[idx + _27142 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27552 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _27552 + -mem[64] + 132
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19061 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19061] = 30
                                    mem[_19061 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _19294 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19294 + 68] = mem[idx + _19061 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19294 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19294 + -mem[64] + 100
                                    if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20594 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20594] = 30
                                    mem[_20594 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _21107 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21107 + 68] = mem[idx + _20594 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21107 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21107 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _24697 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24697] = 30
                                    mem[_24697 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        _25054 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25054 + 68] = mem[idx + _24697 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25054 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25054 + -mem[64] + 100
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _28536 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28536] = 40
                                    mem[_28536 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29064 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29064 + 68] = mem[idx + _28536 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29064 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29064 + -mem[64] + 132
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg3 / 100:
                                    _19060 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19060] = 30
                                    mem[_19060 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        _19293 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19293 + 68] = mem[idx + _19060 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19293 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19293 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20593 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20593] = 30
                                    mem[_20593 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _21106 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21106 + 68] = mem[idx + _20593 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21106 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21106 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _24696 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24696] = 30
                                    mem[_24696 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _25053 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25053 + 68] = mem[idx + _24696 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25053 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25053 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _28533 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28533] = 40
                                    mem[_28533 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29063 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29063 + 68] = mem[idx + _28533 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29063 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29063 + -mem[64] + 132
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19765 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19765] = 30
                                mem[_19765 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                    _20083 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20083 + 68] = mem[idx + _19765 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20083 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20083 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22137 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22137] = 30
                                mem[_22137 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _22779 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22779 + 68] = mem[idx + _22137 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22779 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22779 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                _26069 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26069] = 30
                                mem[_26069 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    _26465 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _26465 + 68] = mem[idx + _26069 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_26465 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _26465 + -mem[64] + 100
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _30484 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30484] = 40
                                mem[_30484 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _31065 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _31065 + 68] = mem[idx + _30484 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31065 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _31065 + -mem[64] + 132
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _18162 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18162] = 30
                                mem[_18162 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _18216 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18216 + 68] = mem[idx + _18162 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18216 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18216 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _18553 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18553] = 30
                                mem[_18553 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _18613 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18613 + 68] = mem[idx + _18553 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18613 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18613 + -mem[64] + 100
                            _18163 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18163] = 26
                            mem[_18163 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                if not 15 * arg3 / 100:
                                    _18913 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18913] = 30
                                    mem[_18913 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19768 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19768] = 30
                                    mem[_19768 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _20087 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20087 + 68] = mem[idx + _19768 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20087 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20087 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _23497 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23497] = 30
                                    mem[_23497 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _23956 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _23956 + 68] = mem[idx + _23497 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23956 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23956 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _27554 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_27554] = 40
                                    mem[_27554 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _28142 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _28142 + 68] = mem[idx + _27554 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_28142 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _28142 + -mem[64] + 132
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19296 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19296] = 30
                                mem[_19296 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _19469 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19469 + 68] = mem[idx + _19296 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19469 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19469 + -mem[64] + 100
                                if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _21110 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21110] = 30
                                mem[_21110 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    _21637 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21637 + 68] = mem[idx + _21110 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21637 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21637 + -mem[64] + 100
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                _25057 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25057] = 30
                                mem[_25057 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    _25531 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25531 + 68] = mem[idx + _25057 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25531 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25531 + -mem[64] + 100
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _29070 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_29070] = 40
                                mem[_29070 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _29859 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29859 + 68] = mem[idx + _29070 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29859 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29859 + -mem[64] + 132
                            if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg3 / 100:
                                _19295 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19295] = 30
                                mem[_19295 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    _19468 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19468 + 68] = mem[idx + _19295 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19468 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19468 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _21109 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21109] = 30
                                mem[_21109 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _21636 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21636 + 68] = mem[idx + _21109 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21636 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21636 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                _25056 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25056] = 30
                                mem[_25056 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _25530 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25530 + 68] = mem[idx + _25056 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25530 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25530 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _29067 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_29067] = 40
                                mem[_29067 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _29858 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29858 + 68] = mem[idx + _29067 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29858 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29858 + -mem[64] + 132
                            if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                revert with 0, 17
                            if not 15 * arg3 / 100:
                                revert with 0, 18
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20086 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20086] = 30
                            mem[_20086 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                _20595 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20595 + 68] = mem[idx + _20086 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20595 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20595 + -mem[64] + 100
                            if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _22782 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22782] = 30
                            mem[_22782 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                _23364 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23364 + 68] = mem[idx + _22782 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23364 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23364 + -mem[64] + 100
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                revert with 0, 17
                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                            _26469 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26469] = 30
                            mem[_26469 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                _26939 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26939 + 68] = mem[idx + _26469 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26939 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26939 + -mem[64] + 100
                            if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _31070 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_31070] = 40
                            mem[_31070 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _32166 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _32166 + 68] = mem[idx + _31070 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32166 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _32166 + -mem[64] + 132
                        _17868 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17868] = 26
                        mem[_17868 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 100000000 * 10^18:
                            _18283 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18283] = 26
                            mem[_18283 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                if not 15 * arg3 / 100:
                                    _19059 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19059] = 30
                                    mem[_19059 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20592 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20592] = 30
                                    mem[_20592 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _24695 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24695] = 30
                                    mem[_24695 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _28530 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28530] = 40
                                    mem[_28530 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28530 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19764 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19764] = 30
                                    mem[_19764 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22136 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22136] = 30
                                    mem[_22136 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _26068 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26068] = 30
                                    mem[_26068 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30481 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30481] = 40
                                    mem[_30481 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30481 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg3 / 100:
                                    _19763 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19763] = 30
                                    mem[_19763 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22135 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22135] = 30
                                    mem[_22135 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _26067 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26067] = 30
                                    mem[_26067 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30478 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30478] = 40
                                    mem[_30478 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30478 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _21104 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21104] = 30
                                    mem[_21104 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _23692 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23692] = 30
                                    mem[_23692 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _27348 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27348] = 30
                                    mem[_27348 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _32896 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_32896] = 40
                                    mem[_32896 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32896 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _18282 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18282] = 26
                            mem[_18282 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                if not 15 * arg3 / 100:
                                    _19057 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19057] = 30
                                    mem[_19057 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20590 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20590] = 30
                                    mem[_20590 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _24693 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24693] = 30
                                    mem[_24693 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _28526 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28526] = 40
                                    mem[_28526 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28526 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19762 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19762] = 30
                                    mem[_19762 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 15 * arg3 / 100 * t / s:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22134 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22134] = 30
                                    mem[_22134 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > !(-15 * arg3 / 100 * t / s):
                                        revert with 0, 17
                                    if stor1[arg2] - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * t / s)
                                    _26066 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26066] = 30
                                    mem[_26066 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg3 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * t / s
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30475 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30475] = 40
                                    mem[_30475 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30475 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg3 / 100:
                                    _19761 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19761] = 30
                                    mem[_19761 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * t / s < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22133 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22133] = 30
                                    mem[_22133 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * t / s
                                    if stor1[arg2] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                    _26065 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26065] = 30
                                    mem[_26065 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30472 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30472] = 40
                                    mem[_30472 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30472 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _21102 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21102] = 30
                                    mem[_21102 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * t / s > arg3 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * t / s < 15 * arg3 / 100 * t / s:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _23690 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23690] = 30
                                    mem[_23690 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * t / s
                                    if stor1[arg2] > !((arg3 * t / s) - (15 * arg3 / 100 * t / s)):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s)
                                    _27346 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27346] = 30
                                    mem[_27346 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg3 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * t / s
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _32892 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_32892] = 40
                                    mem[_32892 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32892 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    mem[0] = arg2
                    mem[32] = 4
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if stor4[address(arg2)]:
                        if not arg3 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg3:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg3 < 0:
                                revert with 0, 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _18069 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18069] = 26
                                    mem[_18069 + 32] = 'SafeMath: division by zero'
                                    if not arg3:
                                        _18778 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18778] = 30
                                        mem[_18778 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _19478 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19478] = 30
                                        mem[_19478 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _19783 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19783 + 68] = mem[idx + _19478 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19783 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19783 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _23096 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23096] = 30
                                        mem[_23096 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _23514 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _23514 + 68] = mem[idx + _23096 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23514 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _23514 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg3, arg1, arg2);
                                        _27165 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27165] = 40
                                        mem[_27165 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _27585 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _27585 + 68] = mem[idx + _27165 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27585 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _27585 + -mem[64] + 132
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19079 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19079] = 30
                                    mem[_19079 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        _19303 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19303 + 68] = mem[idx + _19079 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19303 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19303 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20613 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20613] = 30
                                    mem[_20613 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _21127 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21127 + 68] = mem[idx + _20613 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21127 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21127 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _24725 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24725] = 30
                                    mem[_24725 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _25074 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25074 + 68] = mem[idx + _24725 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25074 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25074 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _28573 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28573] = 40
                                    mem[_28573 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29106 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29106 + 68] = mem[idx + _28573 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29106 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29106 + -mem[64] + 132
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _18168 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18168] = 30
                                    mem[_18168 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _18219 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18219 + 68] = mem[idx + _18168 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18219 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18219 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _18559 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18559] = 30
                                    mem[_18559 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _18619 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18619 + 68] = mem[idx + _18559 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18619 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18619 + -mem[64] + 100
                                _18169 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18169] = 26
                                mem[_18169 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    _18919 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18919] = 30
                                    mem[_18919 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19784 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19784] = 30
                                    mem[_19784 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _20104 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20104 + 68] = mem[idx + _19784 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20104 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20104 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _23515 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23515] = 30
                                    mem[_23515 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _24007 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _24007 + 68] = mem[idx + _23515 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24007 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _24007 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _27586 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_27586] = 40
                                    mem[_27586 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _28162 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _28162 + 68] = mem[idx + _27586 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_28162 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _28162 + -mem[64] + 132
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19304 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19304] = 30
                                mem[_19304 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    _19479 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19479 + 68] = mem[idx + _19304 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19479 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19479 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _21129 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21129] = 30
                                mem[_21129 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _21655 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21655 + 68] = mem[idx + _21129 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21655 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21655 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                _25076 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25076] = 30
                                mem[_25076 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _25562 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25562 + 68] = mem[idx + _25076 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25562 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25562 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _29109 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_29109] = 40
                                mem[_29109 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _29882 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29882 + 68] = mem[idx + _29109 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29882 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29882 + -mem[64] + 132
                            _17877 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17877] = 26
                            mem[_17877 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 100000000 * 10^18:
                                _18289 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18289] = 26
                                mem[_18289 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    _19078 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19078] = 30
                                    mem[_19078 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20612 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20612] = 30
                                    mem[_20612 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _24724 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24724] = 30
                                    mem[_24724 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _28570 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28570] = 40
                                    mem[_28570 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28570 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19782 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19782] = 30
                                    mem[_19782 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22151 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22151] = 30
                                    mem[_22151 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _26085 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26085] = 30
                                    mem[_26085 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _30519 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30519] = 40
                                    mem[_30519 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30519 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _18288 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18288] = 26
                                mem[_18288 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    _19076 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19076] = 30
                                    mem[_19076 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20611 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20611] = 30
                                    mem[_20611 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _24723 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24723] = 30
                                    mem[_24723 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _28567 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28567] = 40
                                    mem[_28567 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28567 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19781 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19781] = 30
                                    mem[_19781 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * t / s < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22150 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22150] = 30
                                    mem[_22150 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * t / s
                                    if stor1[arg2] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                    _26084 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26084] = 30
                                    mem[_26084 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _30516 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30516] = 40
                                    mem[_30516 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30516 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 / 100 and 15 > -1 / arg3 / 100:
                                revert with 0, 17
                            if not arg3 / 100:
                                revert with 0, 18
                            if 15 * arg3 / 100 / arg3 / 100 != 15:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 > arg3:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg3 < 15 * arg3 / 100:
                                revert with 0, 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _18068 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18068] = 26
                                    mem[_18068 + 32] = 'SafeMath: division by zero'
                                    if not arg3:
                                        if not 15 * arg3 / 100:
                                            _18775 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18775] = 30
                                            mem[_18775 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _19475 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19475] = 30
                                            mem[_19475 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(arg1)]:
                                                _19778 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _19778 + 68] = mem[idx + _19475 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19778 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19778 + -mem[64] + 100
                                            if stor1[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor1[arg2] > -1:
                                                revert with 0, 17
                                            if stor1[arg2] < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2]
                                            _23085 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23085] = 30
                                            mem[_23085 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _23509 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _23509 + 68] = mem[idx + _23085 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23509 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _23509 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _27158 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27158] = 40
                                            mem[_27158 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            mem[32] = sha3(address(arg1), 3)
                                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                                if allowance[address(arg1)][msg.sender] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                                return 1
                                            _27575 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _27575 + 68] = mem[idx + _27158 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27575 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _27575 + -mem[64] + 132
                                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19073 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19073] = 30
                                        mem[_19073 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _19300 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19300 + 68] = mem[idx + _19073 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19300 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19300 + -mem[64] + 100
                                        if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20607 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20607] = 30
                                        mem[_20607 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _21121 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21121 + 68] = mem[idx + _20607 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21121 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21121 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                        _24715 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24715] = 30
                                        mem[_24715 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            _25068 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _25068 + 68] = mem[idx + _24715 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25068 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _25068 + -mem[64] + 100
                                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28562 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28562] = 40
                                        mem[_28562 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _29093 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29093 + 68] = mem[idx + _28562 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29093 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29093 + -mem[64] + 132
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg3 / 100:
                                        _19072 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19072] = 30
                                        mem[_19072 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                                            _19299 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19299 + 68] = mem[idx + _19072 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19299 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19299 + -mem[64] + 100
                                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20606 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20606] = 30
                                        mem[_20606 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            _21120 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21120 + 68] = mem[idx + _20606 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21120 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21120 + -mem[64] + 100
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                        _24714 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24714] = 30
                                        mem[_24714 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _25067 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _25067 + 68] = mem[idx + _24714 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25067 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _25067 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28559 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28559] = 40
                                        mem[_28559 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _29092 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29092 + 68] = mem[idx + _28559 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29092 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29092 + -mem[64] + 132
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19777 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19777] = 30
                                    mem[_19777 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                        _20096 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20096 + 68] = mem[idx + _19777 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20096 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20096 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22147 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22147] = 30
                                    mem[_22147 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _22796 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22796 + 68] = mem[idx + _22147 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22796 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22796 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _26080 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26080] = 30
                                    mem[_26080 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        _26484 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _26484 + 68] = mem[idx + _26080 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_26484 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _26484 + -mem[64] + 100
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30510 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30510] = 40
                                    mem[_30510 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _31093 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _31093 + 68] = mem[idx + _30510 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31093 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _31093 + -mem[64] + 132
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _18166 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18166] = 30
                                    mem[_18166 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _18218 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18218 + 68] = mem[idx + _18166 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18218 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18218 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _18557 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18557] = 30
                                    mem[_18557 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _18617 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18617 + 68] = mem[idx + _18557 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18617 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18617 + -mem[64] + 100
                                _18167 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18167] = 26
                                mem[_18167 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    if not 15 * arg3 / 100:
                                        _18917 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18917] = 30
                                        mem[_18917 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _19780 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19780] = 30
                                        mem[_19780 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _20100 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _20100 + 68] = mem[idx + _19780 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_20100 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _20100 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _23511 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23511] = 30
                                        mem[_23511 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _23994 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _23994 + 68] = mem[idx + _23511 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23994 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _23994 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _27577 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27577] = 40
                                        mem[_27577 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _28157 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _28157 + 68] = mem[idx + _27577 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_28157 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _28157 + -mem[64] + 132
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19302 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19302] = 30
                                    mem[_19302 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _19477 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19477 + 68] = mem[idx + _19302 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19477 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19477 + -mem[64] + 100
                                    if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _21124 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21124] = 30
                                    mem[_21124 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _21651 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21651 + 68] = mem[idx + _21124 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21651 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21651 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _25071 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25071] = 30
                                    mem[_25071 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        _25556 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25556 + 68] = mem[idx + _25071 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25556 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25556 + -mem[64] + 100
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _29099 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_29099] = 40
                                    mem[_29099 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29876 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29876 + 68] = mem[idx + _29099 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29876 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29876 + -mem[64] + 132
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg3 / 100:
                                    _19301 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19301] = 30
                                    mem[_19301 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        _19476 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19476 + 68] = mem[idx + _19301 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19476 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19476 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _21123 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21123] = 30
                                    mem[_21123 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _21650 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21650 + 68] = mem[idx + _21123 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21650 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21650 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _25070 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25070] = 30
                                    mem[_25070 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _25555 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25555 + 68] = mem[idx + _25070 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25555 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25555 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _29096 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_29096] = 40
                                    mem[_29096 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29875 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29875 + 68] = mem[idx + _29096 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29875 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29875 + -mem[64] + 132
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20099 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20099] = 30
                                mem[_20099 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                    _20608 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20608 + 68] = mem[idx + _20099 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20608 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20608 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22799 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22799] = 30
                                mem[_22799 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _23370 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23370 + 68] = mem[idx + _22799 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23370 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23370 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                _26488 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26488] = 30
                                mem[_26488 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    _26949 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _26949 + 68] = mem[idx + _26488 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_26949 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _26949 + -mem[64] + 100
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _31098 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_31098] = 40
                                mem[_31098 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _32182 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _32182 + 68] = mem[idx + _31098 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32182 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _32182 + -mem[64] + 132
                            _17874 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17874] = 26
                            mem[_17874 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 100000000 * 10^18:
                                _18287 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18287] = 26
                                mem[_18287 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    if not 15 * arg3 / 100:
                                        _19071 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19071] = 30
                                        mem[_19071 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20605 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20605] = 30
                                        mem[_20605 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _24713 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24713] = 30
                                        mem[_24713 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28556 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28556] = 40
                                        mem[_28556 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28556 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19776 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19776] = 30
                                        mem[_19776 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22146 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22146] = 30
                                        mem[_22146 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                        _26079 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26079] = 30
                                        mem[_26079 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30507 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30507] = 40
                                        mem[_30507 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30507 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg3 / 100:
                                        _19775 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19775] = 30
                                        mem[_19775 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22145 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22145] = 30
                                        mem[_22145 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                        _26078 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26078] = 30
                                        mem[_26078 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30504 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30504] = 40
                                        mem[_30504 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30504 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _21118 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21118] = 30
                                        mem[_21118 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _23703 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23703] = 30
                                        mem[_23703 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                        _27357 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27357] = 30
                                        mem[_27357 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _32912 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_32912] = 40
                                        mem[_32912 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32912 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _18286 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18286] = 26
                                mem[_18286 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    if not 15 * arg3 / 100:
                                        _19069 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19069] = 30
                                        mem[_19069 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20603 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20603] = 30
                                        mem[_20603 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _24711 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24711] = 30
                                        mem[_24711 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28552 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28552] = 40
                                        mem[_28552 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28552 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19774 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19774] = 30
                                        mem[_19774 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 15 * arg3 / 100 * t / s:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22144 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22144] = 30
                                        mem[_22144 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > !(-15 * arg3 / 100 * t / s):
                                            revert with 0, 17
                                        if stor1[arg2] - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * t / s)
                                        _26077 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26077] = 30
                                        mem[_26077 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg3 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * t / s
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30501 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30501] = 40
                                        mem[_30501 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30501 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg3 / 100:
                                        _19773 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19773] = 30
                                        mem[_19773 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * t / s < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22143 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22143] = 30
                                        mem[_22143 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * t / s
                                        if stor1[arg2] > !(arg3 * t / s):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                        _26076 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26076] = 30
                                        mem[_26076 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30498 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30498] = 40
                                        mem[_30498 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30498 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _21116 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21116] = 30
                                        mem[_21116 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * t / s > arg3 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * t / s < 15 * arg3 / 100 * t / s:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _23701 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23701] = 30
                                        mem[_23701 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * t / s
                                        if stor1[arg2] > !((arg3 * t / s) - (15 * arg3 / 100 * t / s)):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s)
                                        _27355 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27355] = 30
                                        mem[_27355 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg3 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * t / s
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _32908 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_32908] = 40
                                        mem[_32908 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32908 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        if not arg3 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg3:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg3 < 0:
                                revert with 0, 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _18071 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18071] = 26
                                    mem[_18071 + 32] = 'SafeMath: division by zero'
                                    if not arg3:
                                        _18784 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18784] = 30
                                        mem[_18784 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _19486 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19486] = 30
                                        mem[_19486 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _19795 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19795 + 68] = mem[idx + _19486 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19795 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19795 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _23120 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23120] = 30
                                        mem[_23120 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _23528 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _23528 + 68] = mem[idx + _23120 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23528 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _23528 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg3, arg1, arg2);
                                        _27181 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27181] = 40
                                        mem[_27181 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _27608 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _27608 + 68] = mem[idx + _27181 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27608 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _27608 + -mem[64] + 132
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19091 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19091] = 30
                                    mem[_19091 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        _19309 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19309 + 68] = mem[idx + _19091 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19309 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19309 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20626 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20626] = 30
                                    mem[_20626 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _21141 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21141 + 68] = mem[idx + _20626 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21141 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21141 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _24743 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24743] = 30
                                    mem[_24743 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _25088 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25088 + 68] = mem[idx + _24743 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25088 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25088 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _28599 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28599] = 40
                                    mem[_28599 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29135 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29135 + 68] = mem[idx + _28599 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29135 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29135 + -mem[64] + 132
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _18172 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18172] = 30
                                    mem[_18172 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _18221 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18221 + 68] = mem[idx + _18172 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18221 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18221 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _18563 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18563] = 30
                                    mem[_18563 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _18623 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18623 + 68] = mem[idx + _18563 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18623 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18623 + -mem[64] + 100
                                _18173 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18173] = 26
                                mem[_18173 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    _18923 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18923] = 30
                                    mem[_18923 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19796 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19796] = 30
                                    mem[_19796 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _20117 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20117 + 68] = mem[idx + _19796 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20117 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20117 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _23529 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23529] = 30
                                    mem[_23529 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _24045 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _24045 + 68] = mem[idx + _23529 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24045 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _24045 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _27609 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_27609] = 40
                                    mem[_27609 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _28177 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _28177 + 68] = mem[idx + _27609 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_28177 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _28177 + -mem[64] + 132
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19310 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19310] = 30
                                mem[_19310 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    _19487 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19487 + 68] = mem[idx + _19310 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19487 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19487 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _21143 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21143] = 30
                                mem[_21143 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _21669 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21669 + 68] = mem[idx + _21143 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21669 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21669 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                _25090 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25090] = 30
                                mem[_25090 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _25587 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25587 + 68] = mem[idx + _25090 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25587 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25587 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _29138 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_29138] = 40
                                mem[_29138 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _29899 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29899 + 68] = mem[idx + _29138 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29899 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29899 + -mem[64] + 132
                            _17883 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17883] = 26
                            mem[_17883 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 100000000 * 10^18:
                                _18293 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18293] = 26
                                mem[_18293 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    _19090 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19090] = 30
                                    mem[_19090 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20625 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20625] = 30
                                    mem[_20625 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _24742 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24742] = 30
                                    mem[_24742 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _28596 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28596] = 40
                                    mem[_28596 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28596 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19794 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19794] = 30
                                    mem[_19794 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22161 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22161] = 30
                                    mem[_22161 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _26096 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26096] = 30
                                    mem[_26096 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _30545 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30545] = 40
                                    mem[_30545 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30545 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _18292 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18292] = 26
                                mem[_18292 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    _19088 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19088] = 30
                                    mem[_19088 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20624 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20624] = 30
                                    mem[_20624 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _24741 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24741] = 30
                                    mem[_24741 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _28593 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28593] = 40
                                    mem[_28593 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28593 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19793 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19793] = 30
                                    mem[_19793 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * t / s < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22160 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22160] = 30
                                    mem[_22160 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * t / s
                                    if stor1[arg2] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                    _26095 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26095] = 30
                                    mem[_26095 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _30542 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30542] = 40
                                    mem[_30542 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30542 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 / 100 and 15 > -1 / arg3 / 100:
                                revert with 0, 17
                            if not arg3 / 100:
                                revert with 0, 18
                            if 15 * arg3 / 100 / arg3 / 100 != 15:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 > arg3:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg3 < 15 * arg3 / 100:
                                revert with 0, 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _18070 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18070] = 26
                                    mem[_18070 + 32] = 'SafeMath: division by zero'
                                    if not arg3:
                                        if not 15 * arg3 / 100:
                                            _18781 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18781] = 30
                                            mem[_18781 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _19483 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19483] = 30
                                            mem[_19483 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(arg1)]:
                                                _19790 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _19790 + 68] = mem[idx + _19483 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19790 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19790 + -mem[64] + 100
                                            if stor1[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor1[arg2] > -1:
                                                revert with 0, 17
                                            if stor1[arg2] < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2]
                                            _23109 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23109] = 30
                                            mem[_23109 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _23523 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _23523 + 68] = mem[idx + _23109 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23523 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _23523 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _27174 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27174] = 40
                                            mem[_27174 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            mem[32] = sha3(address(arg1), 3)
                                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                                if allowance[address(arg1)][msg.sender] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                                return 1
                                            _27598 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _27598 + 68] = mem[idx + _27174 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27598 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _27598 + -mem[64] + 132
                                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19085 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19085] = 30
                                        mem[_19085 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _19306 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19306 + 68] = mem[idx + _19085 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19306 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19306 + -mem[64] + 100
                                        if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20620 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20620] = 30
                                        mem[_20620 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _21135 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21135 + 68] = mem[idx + _20620 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21135 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21135 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                        _24733 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24733] = 30
                                        mem[_24733 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            _25082 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _25082 + 68] = mem[idx + _24733 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25082 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _25082 + -mem[64] + 100
                                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28588 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28588] = 40
                                        mem[_28588 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _29122 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29122 + 68] = mem[idx + _28588 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29122 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29122 + -mem[64] + 132
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg3 / 100:
                                        _19084 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19084] = 30
                                        mem[_19084 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                                            _19305 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19305 + 68] = mem[idx + _19084 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19305 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19305 + -mem[64] + 100
                                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20619 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20619] = 30
                                        mem[_20619 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            _21134 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21134 + 68] = mem[idx + _20619 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21134 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21134 + -mem[64] + 100
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                        _24732 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24732] = 30
                                        mem[_24732 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _25081 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _25081 + 68] = mem[idx + _24732 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25081 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _25081 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28585 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28585] = 40
                                        mem[_28585 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _29121 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29121 + 68] = mem[idx + _28585 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29121 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29121 + -mem[64] + 132
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19789 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19789] = 30
                                    mem[_19789 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                        _20109 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20109 + 68] = mem[idx + _19789 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20109 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20109 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22157 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22157] = 30
                                    mem[_22157 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _22813 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22813 + 68] = mem[idx + _22157 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22813 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22813 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _26091 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26091] = 30
                                    mem[_26091 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        _26503 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _26503 + 68] = mem[idx + _26091 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_26503 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _26503 + -mem[64] + 100
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30536 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30536] = 40
                                    mem[_30536 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _31121 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _31121 + 68] = mem[idx + _30536 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31121 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _31121 + -mem[64] + 132
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _18170 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18170] = 30
                                    mem[_18170 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _18220 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18220 + 68] = mem[idx + _18170 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18220 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18220 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _18561 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18561] = 30
                                    mem[_18561 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _18621 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18621 + 68] = mem[idx + _18561 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18621 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18621 + -mem[64] + 100
                                _18171 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18171] = 26
                                mem[_18171 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    if not 15 * arg3 / 100:
                                        _18921 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18921] = 30
                                        mem[_18921 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _19792 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19792] = 30
                                        mem[_19792 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _20113 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _20113 + 68] = mem[idx + _19792 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_20113 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _20113 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _23525 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23525] = 30
                                        mem[_23525 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _24032 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _24032 + 68] = mem[idx + _23525 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_24032 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _24032 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _27600 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27600] = 40
                                        mem[_27600 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _28172 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _28172 + 68] = mem[idx + _27600 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_28172 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _28172 + -mem[64] + 132
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19308 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19308] = 30
                                    mem[_19308 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _19485 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19485 + 68] = mem[idx + _19308 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19485 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19485 + -mem[64] + 100
                                    if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _21138 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21138] = 30
                                    mem[_21138 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _21665 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21665 + 68] = mem[idx + _21138 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21665 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21665 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _25085 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25085] = 30
                                    mem[_25085 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        _25581 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25581 + 68] = mem[idx + _25085 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25581 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25581 + -mem[64] + 100
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _29128 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_29128] = 40
                                    mem[_29128 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29893 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29893 + 68] = mem[idx + _29128 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29893 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29893 + -mem[64] + 132
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg3 / 100:
                                    _19307 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19307] = 30
                                    mem[_19307 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        _19484 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19484 + 68] = mem[idx + _19307 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19484 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19484 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _21137 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21137] = 30
                                    mem[_21137 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _21664 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21664 + 68] = mem[idx + _21137 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21664 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21664 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _25084 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25084] = 30
                                    mem[_25084 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _25580 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25580 + 68] = mem[idx + _25084 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25580 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25580 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _29125 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_29125] = 40
                                    mem[_29125 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29892 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29892 + 68] = mem[idx + _29125 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29892 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29892 + -mem[64] + 132
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20112 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20112] = 30
                                mem[_20112 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                    _20621 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20621 + 68] = mem[idx + _20112 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20621 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20621 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22816 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22816] = 30
                                mem[_22816 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _23376 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23376 + 68] = mem[idx + _22816 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23376 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23376 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                _26507 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26507] = 30
                                mem[_26507 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    _26959 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _26959 + 68] = mem[idx + _26507 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_26959 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _26959 + -mem[64] + 100
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _31126 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_31126] = 40
                                mem[_31126 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _32198 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _32198 + 68] = mem[idx + _31126 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32198 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _32198 + -mem[64] + 132
                            _17880 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17880] = 26
                            mem[_17880 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 100000000 * 10^18:
                                _18291 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18291] = 26
                                mem[_18291 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    if not 15 * arg3 / 100:
                                        _19083 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19083] = 30
                                        mem[_19083 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20618 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20618] = 30
                                        mem[_20618 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _24731 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24731] = 30
                                        mem[_24731 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28582 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28582] = 40
                                        mem[_28582 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28582 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19788 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19788] = 30
                                        mem[_19788 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22156 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22156] = 30
                                        mem[_22156 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                        _26090 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26090] = 30
                                        mem[_26090 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30533 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30533] = 40
                                        mem[_30533 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30533 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg3 / 100:
                                        _19787 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19787] = 30
                                        mem[_19787 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22155 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22155] = 30
                                        mem[_22155 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                        _26089 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26089] = 30
                                        mem[_26089 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30530 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30530] = 40
                                        mem[_30530 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30530 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _21132 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21132] = 30
                                        mem[_21132 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _23714 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23714] = 30
                                        mem[_23714 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                        _27366 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27366] = 30
                                        mem[_27366 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _32928 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_32928] = 40
                                        mem[_32928 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32928 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _18290 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18290] = 26
                                mem[_18290 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    if not 15 * arg3 / 100:
                                        _19081 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19081] = 30
                                        mem[_19081 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20616 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20616] = 30
                                        mem[_20616 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _24729 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24729] = 30
                                        mem[_24729 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28578 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28578] = 40
                                        mem[_28578 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28578 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19786 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19786] = 30
                                        mem[_19786 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 15 * arg3 / 100 * t / s:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22154 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22154] = 30
                                        mem[_22154 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > !(-15 * arg3 / 100 * t / s):
                                            revert with 0, 17
                                        if stor1[arg2] - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * t / s)
                                        _26088 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26088] = 30
                                        mem[_26088 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg3 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * t / s
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30527 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30527] = 40
                                        mem[_30527 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30527 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg3 / 100:
                                        _19785 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19785] = 30
                                        mem[_19785 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * t / s < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22153 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22153] = 30
                                        mem[_22153 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * t / s
                                        if stor1[arg2] > !(arg3 * t / s):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                        _26087 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26087] = 30
                                        mem[_26087 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30524 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30524] = 40
                                        mem[_30524 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30524 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _21130 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21130] = 30
                                        mem[_21130 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * t / s > arg3 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * t / s < 15 * arg3 / 100 * t / s:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _23712 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23712] = 30
                                        mem[_23712 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * t / s
                                        if stor1[arg2] > !((arg3 * t / s) - (15 * arg3 / 100 * t / s)):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s)
                                        _27364 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27364] = 30
                                        mem[_27364 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg3 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * t / s
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _32924 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_32924] = 40
                                        mem[_32924 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32924 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
    else:
        mem[0] = arg2
        mem[32] = 4
        if not stor4[address(arg2)]:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            if not arg3 / 100:
                mem[64] = 224
                mem[160] = 30
                mem[192] = 'SafeMath: subtraction overflow'
                if 0 > arg3:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg3 < 0:
                    revert with 0, 17
                idx = 0
                s = 100000000 * 10^18
                t = stor6
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _18089 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18089] = 26
                        mem[_18089 + 32] = 'SafeMath: division by zero'
                        if not arg3:
                            _18838 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18838] = 30
                            mem[_18838 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = arg1
                            mem[32] = 2
                            _19558 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19558] = 30
                            mem[_19558 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor2[address(arg1)]:
                                _19903 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19903 + 68] = mem[idx + _19558 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19903 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19903 + -mem[64] + 100
                            if stor2[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor2[address(arg1)] -= arg3
                            mem[32] = 1
                            _21269 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21269] = 30
                            mem[_21269 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(arg1)]:
                                _21797 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21797 + 68] = mem[idx + _21269 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21797 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21797 + -mem[64] + 100
                            if stor1[address(arg1)] < 0:
                                revert with 0, 17
                            if stor1[arg2] > -1:
                                revert with 0, 17
                            if stor1[arg2] < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2]
                            _25205 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25205] = 30
                            mem[_25205 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                _25841 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25841 + 68] = mem[idx + _25205 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25841 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25841 + -mem[64] + 100
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg3, arg1, arg2);
                            _29373 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_29373] = 40
                            mem[_29373 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _30053 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _30053 + 68] = mem[idx + _29373 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30053 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _30053 + -mem[64] + 132
                        if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _19199 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19199] = 30
                        mem[_19199 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                            _19363 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19363 + 68] = mem[idx + _19199 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19363 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19363 + -mem[64] + 100
                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                            revert with 0, 17
                        mem[0] = arg1
                        mem[32] = 2
                        _20743 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20743] = 30
                        mem[_20743 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 > stor2[address(arg1)]:
                            _21268 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21268 + 68] = mem[idx + _20743 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21268 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21268 + -mem[64] + 100
                        if stor2[address(arg1)] < arg3:
                            revert with 0, 17
                        mem[0] = arg1
                        stor2[address(arg1)] -= arg3
                        mem[32] = 1
                        _22980 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22980] = 30
                        mem[_22980 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                            _23442 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23442 + 68] = mem[idx + _22980 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23442 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23442 + -mem[64] + 100
                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                        if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                            revert with 0, 17
                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 1
                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                        _26669 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26669] = 30
                        mem[_26669 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor6:
                            _27086 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27086 + 68] = mem[idx + _26669 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27086 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27086 + -mem[64] + 100
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg3, arg1, arg2);
                        _31387 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_31387] = 40
                        mem[_31387 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                        mem[32] = sha3(address(arg1), 3)
                        if arg3 <= allowance[address(arg1)][msg.sender]:
                            if allowance[address(arg1)][msg.sender] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                            return 1
                        _32361 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _32361 + 68] = mem[idx + _31387 + 32]
                            idx = idx + 32
                            continue 
                        mem[_32361 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _32361 + -mem[64] + 132
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _18208 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18208] = 30
                        mem[_18208 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _18239 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18239 + 68] = mem[idx + _18208 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18239 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18239 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _18599 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18599] = 30
                        mem[_18599 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _18659 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18659 + 68] = mem[idx + _18599 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18659 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18659 + -mem[64] + 100
                    _18209 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_18209] = 26
                    mem[_18209 + 32] = 'SafeMath: division by zero'
                    if not arg3:
                        _18959 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18959] = 30
                        mem[_18959 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = arg1
                        mem[32] = 2
                        _19904 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19904] = 30
                        mem[_19904 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 > stor2[address(arg1)]:
                            _20234 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20234 + 68] = mem[idx + _19904 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20234 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20234 + -mem[64] + 100
                        if stor2[address(arg1)] < arg3:
                            revert with 0, 17
                        mem[0] = arg1
                        stor2[address(arg1)] -= arg3
                        mem[32] = 1
                        _21799 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21799] = 30
                        mem[_21799 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(arg1)]:
                            _22252 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22252 + 68] = mem[idx + _21799 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22252 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22252 + -mem[64] + 100
                        if stor1[address(arg1)] < 0:
                            revert with 0, 17
                        if stor1[arg2] > -1:
                            revert with 0, 17
                        if stor1[arg2] < stor1[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 1
                        stor1[address(arg2)] = stor1[arg2]
                        _25842 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_25842] = 30
                        mem[_25842 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor6:
                            _26233 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _26233 + 68] = mem[idx + _25842 + 32]
                                idx = idx + 32
                                continue 
                            mem[_26233 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _26233 + -mem[64] + 100
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg3, arg1, arg2);
                        _30054 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_30054] = 40
                        mem[_30054 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                        mem[32] = sha3(address(arg1), 3)
                        if arg3 <= allowance[address(arg1)][msg.sender]:
                            if allowance[address(arg1)][msg.sender] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                            return 1
                        _30772 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _30772 + 68] = mem[idx + _30054 + 32]
                            idx = idx + 32
                            continue 
                        mem[_30772 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _30772 + -mem[64] + 132
                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                        revert with 0, 17
                    if not arg3:
                        revert with 0, 18
                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _19364 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19364] = 30
                    mem[_19364 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                        _19559 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19559 + 68] = mem[idx + _19364 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19559 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19559 + -mem[64] + 100
                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                        revert with 0, 17
                    mem[0] = arg1
                    mem[32] = 2
                    _21271 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_21271] = 30
                    mem[_21271 + 32] = 'SafeMath: subtraction overflow'
                    if arg3 > stor2[address(arg1)]:
                        _21798 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _21798 + 68] = mem[idx + _21271 + 32]
                            idx = idx + 32
                            continue 
                        mem[_21798 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _21798 + -mem[64] + 100
                    if stor2[address(arg1)] < arg3:
                        revert with 0, 17
                    mem[0] = arg1
                    stor2[address(arg1)] -= arg3
                    mem[32] = 1
                    _23444 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_23444] = 30
                    mem[_23444 + 32] = 'SafeMath: subtraction overflow'
                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                        _23816 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _23816 + 68] = mem[idx + _23444 + 32]
                            idx = idx + 32
                            continue 
                        mem[_23816 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _23816 + -mem[64] + 100
                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                        revert with 0, 17
                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                        revert with 0, 17
                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg2
                    mem[32] = 1
                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                    _27088 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_27088] = 30
                    mem[_27088 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > stor6:
                        _27472 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _27472 + 68] = mem[idx + _27088 + 32]
                            idx = idx + 32
                            continue 
                        mem[_27472 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _27472 + -mem[64] + 100
                    if stor6 < 0:
                        revert with 0, 17
                    if totalFees > -1:
                        revert with 0, 17
                    if totalFees < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    emit Transfer(arg3, arg1, arg2);
                    _32364 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_32364] = 40
                    mem[_32364 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                    mem[32] = sha3(address(arg1), 3)
                    if arg3 <= allowance[address(arg1)][msg.sender]:
                        if allowance[address(arg1)][msg.sender] < arg3:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not msg.sender:
                            revert with 0, 'ERC20: approve to the zero address'
                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                        return 1
                    _33102 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 40
                    idx = 0
                    while idx < 40:
                        mem[idx + _33102 + 68] = mem[idx + _32364 + 32]
                        idx = idx + 32
                        continue 
                    mem[_33102 + 108] = 0
                    revert with memory
                      from mem[64]
                       len _33102 + -mem[64] + 132
                _17937 = mem[64]
                mem[64] = mem[64] + 64
                mem[_17937] = 26
                mem[_17937 + 32] = 'SafeMath: division by zero'
                if t < stor6 / 100000000 * 10^18:
                    _18329 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_18329] = 26
                    mem[_18329 + 32] = 'SafeMath: division by zero'
                    if not arg3:
                        _19198 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19198] = 30
                        mem[_19198 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = arg1
                        mem[32] = 2
                        _20742 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20742] = 30
                        mem[_20742 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 > stor2[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(arg1)] < arg3:
                            revert with 0, 17
                        mem[0] = arg1
                        stor2[address(arg1)] -= arg3
                        mem[32] = 1
                        _22978 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22978] = 30
                        mem[_22978 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor1[address(arg1)] < 0:
                            revert with 0, 17
                        if stor1[arg2] > -1:
                            revert with 0, 17
                        if stor1[arg2] < stor1[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 1
                        stor1[address(arg2)] = stor1[arg2]
                        _26668 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26668] = 30
                        mem[_26668 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg3, arg1, arg2);
                        _31384 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_31384] = 40
                        mem[_31384 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                        if arg3 > allowance[address(arg1)][msg.sender]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_31384 + 72 len 24]
                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _19902 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19902] = 30
                        mem[_19902 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                            revert with 0, 17
                        mem[0] = arg1
                        mem[32] = 2
                        _22251 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22251] = 30
                        mem[_22251 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 > stor2[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(arg1)] < arg3:
                            revert with 0, 17
                        mem[0] = arg1
                        stor2[address(arg1)] -= arg3
                        mem[32] = 1
                        _24635 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24635] = 30
                        mem[_24635 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                        if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                            revert with 0, 17
                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 1
                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                        _28086 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28086] = 30
                        mem[_28086 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg3, arg1, arg2);
                        _33595 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_33595] = 40
                        mem[_33595 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                        if arg3 > allowance[address(arg1)][msg.sender]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_33595 + 72 len 24]
                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    _18328 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_18328] = 26
                    mem[_18328 + 32] = 'SafeMath: division by zero'
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg3:
                        _19196 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19196] = 30
                        mem[_19196 + 32] = 'SafeMath: subtraction overflow'
                        mem[0] = arg1
                        mem[32] = 2
                        _20741 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20741] = 30
                        mem[_20741 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 > stor2[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(arg1)] < arg3:
                            revert with 0, 17
                        mem[0] = arg1
                        stor2[address(arg1)] -= arg3
                        mem[32] = 1
                        _22975 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22975] = 30
                        mem[_22975 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor1[address(arg1)] < 0:
                            revert with 0, 17
                        if stor1[arg2] > -1:
                            revert with 0, 17
                        if stor1[arg2] < stor1[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 1
                        stor1[address(arg2)] = stor1[arg2]
                        _26667 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_26667] = 30
                        mem[_26667 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg3, arg1, arg2);
                        _31381 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_31381] = 40
                        mem[_31381 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                        if arg3 > allowance[address(arg1)][msg.sender]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_31381 + 72 len 24]
                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        if arg3 and t / s > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * t / s / arg3 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _19901 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19901] = 30
                        mem[_19901 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg3 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg3 * t / s < 0:
                            revert with 0, 17
                        mem[0] = arg1
                        mem[32] = 2
                        _22250 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22250] = 30
                        mem[_22250 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 > stor2[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor2[address(arg1)] < arg3:
                            revert with 0, 17
                        mem[0] = arg1
                        stor2[address(arg1)] -= arg3
                        mem[32] = 1
                        _24633 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24633] = 30
                        mem[_24633 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * t / s > stor1[address(arg1)]:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor1[address(arg1)] < arg3 * t / s:
                            revert with 0, 17
                        stor1[address(arg1)] += -1 * arg3 * t / s
                        if stor1[arg2] > !(arg3 * t / s):
                            revert with 0, 17
                        if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 1
                        stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                        _28085 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28085] = 30
                        mem[_28085 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor6:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > -1:
                            revert with 0, 17
                        if totalFees < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        emit Transfer(arg3, arg1, arg2);
                        _33592 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_33592] = 40
                        mem[_33592 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                        if arg3 > allowance[address(arg1)][msg.sender]:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_33592 + 72 len 24]
                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
            else:
                if arg3 / 100 and 15 > -1 / arg3 / 100:
                    revert with 0, 17
                if not arg3 / 100:
                    revert with 0, 18
                if 15 * arg3 / 100 / arg3 / 100 != 15:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[64] = 224
                mem[160] = 30
                mem[192] = 'SafeMath: subtraction overflow'
                if 15 * arg3 / 100 > arg3:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg3 < 15 * arg3 / 100:
                    revert with 0, 17
                idx = 0
                s = 100000000 * 10^18
                t = stor6
                while idx < stor5.length:
                    mem[0] = stor5[idx]
                    mem[32] = 1
                    if stor1[stor5[idx]] > t:
                        _18088 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18088] = 26
                        mem[_18088 + 32] = 'SafeMath: division by zero'
                        if not arg3:
                            if not 15 * arg3 / 100:
                                _18835 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18835] = 30
                                mem[_18835 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 2
                                _19555 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19555] = 30
                                mem[_19555 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 > stor2[address(arg1)]:
                                    _19898 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19898 + 68] = mem[idx + _19555 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19898 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19898 + -mem[64] + 100
                                if stor2[address(arg1)] < arg3:
                                    revert with 0, 17
                                mem[0] = arg1
                                stor2[address(arg1)] -= arg3
                                mem[32] = 1
                                _21262 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21262] = 30
                                mem[_21262 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    _21790 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21790 + 68] = mem[idx + _21262 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21790 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21790 + -mem[64] + 100
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > -1:
                                    revert with 0, 17
                                if stor1[arg2] < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2]
                                _25194 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25194] = 30
                                mem[_25194 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _25836 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25836 + 68] = mem[idx + _25194 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25836 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25836 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _29366 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_29366] = 40
                                mem[_29366 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _30043 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _30043 + 68] = mem[idx + _29366 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_30043 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _30043 + -mem[64] + 132
                            if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                revert with 0, 17
                            if not 15 * arg3 / 100:
                                revert with 0, 18
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _19193 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19193] = 30
                            mem[_19193 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                _19360 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19360 + 68] = mem[idx + _19193 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19360 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19360 + -mem[64] + 100
                            if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 2
                            _20737 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20737] = 30
                            mem[_20737 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor2[address(arg1)]:
                                _21261 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21261 + 68] = mem[idx + _20737 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21261 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21261 + -mem[64] + 100
                            if stor2[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor2[address(arg1)] -= arg3
                            mem[32] = 1
                            _22971 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22971] = 30
                            mem[_22971 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(arg1)]:
                                _23433 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23433 + 68] = mem[idx + _22971 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23433 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23433 + -mem[64] + 100
                            if stor1[address(arg1)] < 0:
                                revert with 0, 17
                            if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                            _26659 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26659] = 30
                            mem[_26659 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                _27080 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27080 + 68] = mem[idx + _26659 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27080 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27080 + -mem[64] + 100
                            if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _31376 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_31376] = 40
                            mem[_31376 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _32348 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _32348 + 68] = mem[idx + _31376 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32348 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _32348 + -mem[64] + 132
                        if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 15 * arg3 / 100:
                            _19192 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19192] = 30
                            mem[_19192 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg3 * stor6 / 100000000 * 10^18:
                                _19359 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19359 + 68] = mem[idx + _19192 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19359 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19359 + -mem[64] + 100
                            if arg3 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 2
                            _20736 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20736] = 30
                            mem[_20736 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor2[address(arg1)]:
                                _21260 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21260 + 68] = mem[idx + _20736 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21260 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21260 + -mem[64] + 100
                            if stor2[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor2[address(arg1)] -= arg3
                            mem[32] = 1
                            _22969 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22969] = 30
                            mem[_22969 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                _23432 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23432 + 68] = mem[idx + _22969 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23432 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23432 + -mem[64] + 100
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                            _26658 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26658] = 30
                            mem[_26658 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                _27079 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27079 + 68] = mem[idx + _26658 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27079 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27079 + -mem[64] + 100
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _31373 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_31373] = 40
                            mem[_31373 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _32347 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _32347 + 68] = mem[idx + _31373 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32347 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _32347 + -mem[64] + 132
                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                            revert with 0, 17
                        if not 15 * arg3 / 100:
                            revert with 0, 18
                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _19897 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19897] = 30
                        mem[_19897 + 32] = 'SafeMath: subtraction overflow'
                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                            _20226 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20226 + 68] = mem[idx + _19897 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20226 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20226 + -mem[64] + 100
                        if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        mem[0] = arg1
                        mem[32] = 2
                        _22247 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_22247] = 30
                        mem[_22247 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 > stor2[address(arg1)]:
                            _22968 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _22968 + 68] = mem[idx + _22247 + 32]
                                idx = idx + 32
                                continue 
                            mem[_22968 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _22968 + -mem[64] + 100
                        if stor2[address(arg1)] < arg3:
                            revert with 0, 17
                        mem[0] = arg1
                        stor2[address(arg1)] -= arg3
                        mem[32] = 1
                        _24630 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_24630] = 30
                        mem[_24630 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                            _24995 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _24995 + 68] = mem[idx + _24630 + 32]
                                idx = idx + 32
                                continue 
                            mem[_24995 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _24995 + -mem[64] + 100
                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                        if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                            revert with 0, 17
                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 1
                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                        _28081 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_28081] = 30
                        mem[_28081 + 32] = 'SafeMath: subtraction overflow'
                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                            _28434 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _28434 + 68] = mem[idx + _28081 + 32]
                                idx = idx + 32
                                continue 
                            mem[_28434 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _28434 + -mem[64] + 100
                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                        if totalFees > !(15 * arg3 / 100):
                            revert with 0, 17
                        if totalFees + (15 * arg3 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 15 * arg3 / 100
                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                        _33586 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_33586] = 40
                        mem[_33586 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                        mem[32] = sha3(address(arg1), 3)
                        if arg3 <= allowance[address(arg1)][msg.sender]:
                            if allowance[address(arg1)][msg.sender] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                            return 1
                        _34412 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _34412 + 68] = mem[idx + _33586 + 32]
                            idx = idx + 32
                            continue 
                        mem[_34412 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _34412 + -mem[64] + 132
                    if idx >= stor5.length:
                        revert with 0, 50
                    mem[0] = stor5[idx]
                    mem[32] = 2
                    if stor2[stor5[idx]] <= s:
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 1
                        _18206 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18206] = 30
                        mem[_18206 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor5[idx]] > t:
                            _18238 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18238 + 68] = mem[idx + _18206 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18238 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18238 + -mem[64] + 100
                        if t < stor1[stor5[idx]]:
                            revert with 0, 17
                        if idx >= stor5.length:
                            revert with 0, 50
                        mem[0] = stor5[idx]
                        mem[32] = 2
                        _18597 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18597] = 30
                        mem[_18597 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor5[idx]] <= s:
                            if s < stor2[stor5[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor5[idx]]
                            t = t - stor1[stor5[idx]]
                            continue 
                        _18657 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18657 + 68] = mem[idx + _18597 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18657 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18657 + -mem[64] + 100
                    _18207 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_18207] = 26
                    mem[_18207 + 32] = 'SafeMath: division by zero'
                    if not arg3:
                        if not 15 * arg3 / 100:
                            _18957 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18957] = 30
                            mem[_18957 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = arg1
                            mem[32] = 2
                            _19900 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19900] = 30
                            mem[_19900 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor2[address(arg1)]:
                                _20230 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20230 + 68] = mem[idx + _19900 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20230 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20230 + -mem[64] + 100
                            if stor2[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor2[address(arg1)] -= arg3
                            mem[32] = 1
                            _21793 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21793] = 30
                            mem[_21793 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(arg1)]:
                                _22249 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _22249 + 68] = mem[idx + _21793 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_22249 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _22249 + -mem[64] + 100
                            if stor1[address(arg1)] < 0:
                                revert with 0, 17
                            if stor1[arg2] > -1:
                                revert with 0, 17
                            if stor1[arg2] < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2]
                            _25838 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25838] = 30
                            mem[_25838 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                _26220 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26220 + 68] = mem[idx + _25838 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26220 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26220 + -mem[64] + 100
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _30045 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_30045] = 40
                            mem[_30045 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _30767 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _30767 + 68] = mem[idx + _30045 + 32]
                                idx = idx + 32
                                continue 
                            mem[_30767 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _30767 + -mem[64] + 132
                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                            revert with 0, 17
                        if not 15 * arg3 / 100:
                            revert with 0, 18
                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _19362 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19362] = 30
                        mem[_19362 + 32] = 'SafeMath: subtraction overflow'
                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                            _19557 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19557 + 68] = mem[idx + _19362 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19557 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19557 + -mem[64] + 100
                        if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        mem[0] = arg1
                        mem[32] = 2
                        _21265 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21265] = 30
                        mem[_21265 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 > stor2[address(arg1)]:
                            _21792 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21792 + 68] = mem[idx + _21265 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21792 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21792 + -mem[64] + 100
                        if stor2[address(arg1)] < arg3:
                            revert with 0, 17
                        mem[0] = arg1
                        stor2[address(arg1)] -= arg3
                        mem[32] = 1
                        _23438 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23438] = 30
                        mem[_23438 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor1[address(arg1)]:
                            _23814 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23814 + 68] = mem[idx + _23438 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23814 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23814 + -mem[64] + 100
                        if stor1[address(arg1)] < 0:
                            revert with 0, 17
                        if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                            revert with 0, 17
                        if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 1
                        stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                        _27083 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27083] = 30
                        mem[_27083 + 32] = 'SafeMath: subtraction overflow'
                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                            _27466 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27466 + 68] = mem[idx + _27083 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27466 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27466 + -mem[64] + 100
                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                        if totalFees > !(15 * arg3 / 100):
                            revert with 0, 17
                        if totalFees + (15 * arg3 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 15 * arg3 / 100
                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                        _32354 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_32354] = 40
                        mem[_32354 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                        mem[32] = sha3(address(arg1), 3)
                        if arg3 <= allowance[address(arg1)][msg.sender]:
                            if allowance[address(arg1)][msg.sender] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                            return 1
                        _33096 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _33096 + 68] = mem[idx + _32354 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33096 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _33096 + -mem[64] + 132
                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                        revert with 0, 17
                    if not arg3:
                        revert with 0, 18
                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not 15 * arg3 / 100:
                        _19361 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19361] = 30
                        mem[_19361 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                            _19556 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19556 + 68] = mem[idx + _19361 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19556 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19556 + -mem[64] + 100
                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                            revert with 0, 17
                        mem[0] = arg1
                        mem[32] = 2
                        _21264 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_21264] = 30
                        mem[_21264 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 > stor2[address(arg1)]:
                            _21791 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _21791 + 68] = mem[idx + _21264 + 32]
                                idx = idx + 32
                                continue 
                            mem[_21791 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _21791 + -mem[64] + 100
                        if stor2[address(arg1)] < arg3:
                            revert with 0, 17
                        mem[0] = arg1
                        stor2[address(arg1)] -= arg3
                        mem[32] = 1
                        _23436 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_23436] = 30
                        mem[_23436 + 32] = 'SafeMath: subtraction overflow'
                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                            _23813 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _23813 + 68] = mem[idx + _23436 + 32]
                                idx = idx + 32
                                continue 
                            mem[_23813 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _23813 + -mem[64] + 100
                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                            revert with 0, 17
                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                        if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                            revert with 0, 17
                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[0] = arg2
                        mem[32] = 1
                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                        _27082 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_27082] = 30
                        mem[_27082 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > stor6:
                            _27465 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _27465 + 68] = mem[idx + _27082 + 32]
                                idx = idx + 32
                                continue 
                            mem[_27465 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _27465 + -mem[64] + 100
                        if stor6 < 0:
                            revert with 0, 17
                        if totalFees > !(15 * arg3 / 100):
                            revert with 0, 17
                        if totalFees + (15 * arg3 / 100) < totalFees:
                            revert with 0, 'SafeMath: addition overflow'
                        totalFees += 15 * arg3 / 100
                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                        _32351 = mem[64]
                        mem[64] = mem[64] + 96
                        mem[_32351] = 40
                        mem[_32351 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                        mem[32] = sha3(address(arg1), 3)
                        if arg3 <= allowance[address(arg1)][msg.sender]:
                            if allowance[address(arg1)][msg.sender] < arg3:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 'ERC20: approve from the zero address'
                            if not msg.sender:
                                revert with 0, 'ERC20: approve to the zero address'
                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                            return 1
                        _33095 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 40
                        idx = 0
                        while idx < 40:
                            mem[idx + _33095 + 68] = mem[idx + _32351 + 32]
                            idx = idx + 32
                            continue 
                        mem[_33095 + 108] = 0
                        revert with memory
                          from mem[64]
                           len _33095 + -mem[64] + 132
                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                        revert with 0, 17
                    if not 15 * arg3 / 100:
                        revert with 0, 18
                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _20229 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_20229] = 30
                    mem[_20229 + 32] = 'SafeMath: subtraction overflow'
                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                        _20738 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _20738 + 68] = mem[idx + _20229 + 32]
                            idx = idx + 32
                            continue 
                        mem[_20738 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _20738 + -mem[64] + 100
                    if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                        revert with 0, 17
                    mem[0] = arg1
                    mem[32] = 2
                    _22973 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_22973] = 30
                    mem[_22973 + 32] = 'SafeMath: subtraction overflow'
                    if arg3 > stor2[address(arg1)]:
                        _23435 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _23435 + 68] = mem[idx + _22973 + 32]
                            idx = idx + 32
                            continue 
                        mem[_23435 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _23435 + -mem[64] + 100
                    if stor2[address(arg1)] < arg3:
                        revert with 0, 17
                    mem[0] = arg1
                    stor2[address(arg1)] -= arg3
                    mem[32] = 1
                    _24998 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_24998] = 30
                    mem[_24998 + 32] = 'SafeMath: subtraction overflow'
                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                        _25435 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _25435 + 68] = mem[idx + _24998 + 32]
                            idx = idx + 32
                            continue 
                        mem[_25435 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _25435 + -mem[64] + 100
                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                        revert with 0, 17
                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                    if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                        revert with 0, 17
                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[0] = arg2
                    mem[32] = 1
                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                    _28438 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_28438] = 30
                    mem[_28438 + 32] = 'SafeMath: subtraction overflow'
                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                        _28961 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _28961 + 68] = mem[idx + _28438 + 32]
                            idx = idx + 32
                            continue 
                        mem[_28961 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _28961 + -mem[64] + 100
                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                        revert with 0, 17
                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                    if totalFees > !(15 * arg3 / 100):
                        revert with 0, 17
                    if totalFees + (15 * arg3 / 100) < totalFees:
                        revert with 0, 'SafeMath: addition overflow'
                    totalFees += 15 * arg3 / 100
                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                    _34417 = mem[64]
                    mem[64] = mem[64] + 96
                    mem[_34417] = 40
                    mem[_34417 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                    mem[32] = sha3(address(arg1), 3)
                    if arg3 <= allowance[address(arg1)][msg.sender]:
                        if allowance[address(arg1)][msg.sender] < arg3:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 'ERC20: approve from the zero address'
                        if not msg.sender:
                            revert with 0, 'ERC20: approve to the zero address'
                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                        return 1
                    _34864 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 40
                    idx = 0
                    while idx < 40:
                        mem[idx + _34864 + 68] = mem[idx + _34417 + 32]
                        idx = idx + 32
                        continue 
                    mem[_34864 + 108] = 0
                    revert with memory
                      from mem[64]
                       len _34864 + -mem[64] + 132
                _17934 = mem[64]
                mem[64] = mem[64] + 64
                mem[_17934] = 26
                mem[_17934 + 32] = 'SafeMath: division by zero'
                if t < stor6 / 100000000 * 10^18:
                    _18327 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_18327] = 26
                    mem[_18327 + 32] = 'SafeMath: division by zero'
                    if not arg3:
                        if not 15 * arg3 / 100:
                            _19191 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19191] = 30
                            mem[_19191 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = arg1
                            mem[32] = 2
                            _20735 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20735] = 30
                            mem[_20735 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor2[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor2[address(arg1)] -= arg3
                            mem[32] = 1
                            _22966 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22966] = 30
                            mem[_22966 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(arg1)] < 0:
                                revert with 0, 17
                            if stor1[arg2] > -1:
                                revert with 0, 17
                            if stor1[arg2] < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2]
                            _26657 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26657] = 30
                            mem[_26657 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _31370 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_31370] = 40
                            mem[_31370 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            if arg3 > allowance[address(arg1)][msg.sender]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_31370 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                revert with 0, 17
                            if not 15 * arg3 / 100:
                                revert with 0, 18
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _19896 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19896] = 30
                            mem[_19896 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 2
                            _22246 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22246] = 30
                            mem[_22246 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor2[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor2[address(arg1)] -= arg3
                            mem[32] = 1
                            _24628 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24628] = 30
                            mem[_24628 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(arg1)] < 0:
                                revert with 0, 17
                            if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                            _28080 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28080] = 30
                            mem[_28080 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _33583 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_33583] = 40
                            mem[_33583 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            if arg3 > allowance[address(arg1)][msg.sender]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_33583 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 15 * arg3 / 100:
                            _19895 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19895] = 30
                            mem[_19895 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg3 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 2
                            _22245 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22245] = 30
                            mem[_22245 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor2[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor2[address(arg1)] -= arg3
                            mem[32] = 1
                            _24626 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24626] = 30
                            mem[_24626 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                            _28079 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28079] = 30
                            mem[_28079 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _33580 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_33580] = 40
                            mem[_33580 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            if arg3 > allowance[address(arg1)][msg.sender]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_33580 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                revert with 0, 17
                            if not 15 * arg3 / 100:
                                revert with 0, 18
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21258 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21258] = 30
                            mem[_21258 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 2
                            _23812 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23812] = 30
                            mem[_23812 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor2[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor2[address(arg1)] -= arg3
                            mem[32] = 1
                            _26022 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26022] = 30
                            mem[_26022 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                revert with 0, 17
                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                            _29793 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29793] = 30
                            mem[_29793 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _35067 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_35067] = 40
                            mem[_35067 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            if arg3 > allowance[address(arg1)][msg.sender]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_35067 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    _18326 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_18326] = 26
                    mem[_18326 + 32] = 'SafeMath: division by zero'
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg3:
                        if not 15 * arg3 / 100:
                            _19189 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19189] = 30
                            mem[_19189 + 32] = 'SafeMath: subtraction overflow'
                            mem[0] = arg1
                            mem[32] = 2
                            _20733 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20733] = 30
                            mem[_20733 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor2[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor2[address(arg1)] -= arg3
                            mem[32] = 1
                            _22962 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22962] = 30
                            mem[_22962 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(arg1)] < 0:
                                revert with 0, 17
                            if stor1[arg2] > -1:
                                revert with 0, 17
                            if stor1[arg2] < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2]
                            _26655 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26655] = 30
                            mem[_26655 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _31366 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_31366] = 40
                            mem[_31366 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            if arg3 > allowance[address(arg1)][msg.sender]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_31366 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                revert with 0, 17
                            if not 15 * arg3 / 100:
                                revert with 0, 18
                            if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _19894 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19894] = 30
                            mem[_19894 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < 15 * arg3 / 100 * t / s:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 2
                            _22244 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22244] = 30
                            mem[_22244 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor2[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor2[address(arg1)] -= arg3
                            mem[32] = 1
                            _24623 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24623] = 30
                            mem[_24623 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor1[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(arg1)] < 0:
                                revert with 0, 17
                            if stor1[arg2] > !(-15 * arg3 / 100 * t / s):
                                revert with 0, 17
                            if stor1[arg2] - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * t / s)
                            _28078 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28078] = 30
                            mem[_28078 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * t / s > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 15 * arg3 / 100 * t / s:
                                revert with 0, 17
                            stor6 += -15 * arg3 / 100 * t / s
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _33577 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_33577] = 40
                            mem[_33577 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            if arg3 > allowance[address(arg1)][msg.sender]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_33577 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        if arg3 and t / s > -1 / arg3:
                            revert with 0, 17
                        if not arg3:
                            revert with 0, 18
                        if arg3 * t / s / arg3 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not 15 * arg3 / 100:
                            _19893 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19893] = 30
                            mem[_19893 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg3 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg3 * t / s < 0:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 2
                            _22243 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22243] = 30
                            mem[_22243 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor2[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor2[address(arg1)] -= arg3
                            mem[32] = 1
                            _24621 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_24621] = 30
                            mem[_24621 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * t / s > stor1[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(arg1)] < arg3 * t / s:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * t / s
                            if stor1[arg2] > !(arg3 * t / s):
                                revert with 0, 17
                            if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                            _28077 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28077] = 30
                            mem[_28077 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _33574 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_33574] = 40
                            mem[_33574 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            if arg3 > allowance[address(arg1)][msg.sender]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_33574 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                revert with 0, 17
                            if not 15 * arg3 / 100:
                                revert with 0, 18
                            if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _21256 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21256] = 30
                            mem[_21256 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * t / s > arg3 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg3 * t / s < 15 * arg3 / 100 * t / s:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 2
                            _23811 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_23811] = 30
                            mem[_23811 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 > stor2[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor2[address(arg1)] < arg3:
                                revert with 0, 17
                            mem[0] = arg1
                            stor2[address(arg1)] -= arg3
                            mem[32] = 1
                            _26019 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26019] = 30
                            mem[_26019 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * t / s > stor1[address(arg1)]:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor1[address(arg1)] < arg3 * t / s:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * t / s
                            if stor1[arg2] > !((arg3 * t / s) - (15 * arg3 / 100 * t / s)):
                                revert with 0, 17
                            if stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s)
                            _29791 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_29791] = 30
                            mem[_29791 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * t / s > stor6:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if stor6 < 15 * arg3 / 100 * t / s:
                                revert with 0, 17
                            stor6 += -15 * arg3 / 100 * t / s
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _35063 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_35063] = 40
                            mem[_35063 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            if arg3 > allowance[address(arg1)][msg.sender]:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_35063 + 72 len 24]
                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
        else:
            if stor4[address(arg1)]:
                mem[0] = arg1
                mem[32] = 4
                if stor4[address(arg1)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not arg3 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg3:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg3 < 0:
                            revert with 0, 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _18075 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18075] = 26
                                mem[_18075 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    _18796 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18796] = 30
                                    mem[_18796 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19502 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19502] = 30
                                    mem[_19502 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _19819 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19819 + 68] = mem[idx + _19502 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19819 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19819 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _23168 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23168] = 30
                                    mem[_23168 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _23552 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _23552 + 68] = mem[idx + _23168 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23552 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23552 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _27208 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_27208] = 40
                                    mem[_27208 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _27643 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _27643 + 68] = mem[idx + _27208 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27643 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _27643 + -mem[64] + 132
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19115 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19115] = 30
                                mem[_19115 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    _19321 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19321 + 68] = mem[idx + _19115 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19321 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19321 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _20652 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20652] = 30
                                mem[_20652 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _21169 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21169 + 68] = mem[idx + _20652 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21169 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21169 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                _24781 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24781] = 30
                                mem[_24781 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _25108 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25108 + 68] = mem[idx + _24781 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25108 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25108 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _28641 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28641] = 40
                                mem[_28641 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _29187 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29187 + 68] = mem[idx + _28641 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29187 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29187 + -mem[64] + 132
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _18180 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18180] = 30
                                mem[_18180 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _18225 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18225 + 68] = mem[idx + _18180 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18225 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18225 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _18571 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18571] = 30
                                mem[_18571 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _18631 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18631 + 68] = mem[idx + _18571 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18631 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18631 + -mem[64] + 100
                            _18181 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18181] = 26
                            mem[_18181 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                _18931 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18931] = 30
                                mem[_18931 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _19820 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19820] = 30
                                mem[_19820 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    _20143 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20143 + 68] = mem[idx + _19820 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20143 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20143 + -mem[64] + 100
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > -1:
                                    revert with 0, 17
                                if stor1[arg2] < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2]
                                _23553 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_23553] = 30
                                mem[_23553 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _24130 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _24130 + 68] = mem[idx + _23553 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_24130 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _24130 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _27644 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_27644] = 40
                                mem[_27644 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _28208 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _28208 + 68] = mem[idx + _27644 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28208 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _28208 + -mem[64] + 132
                            if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _19322 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19322] = 30
                            mem[_19322 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg3 * stor6 / 100000000 * 10^18:
                                _19503 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19503 + 68] = mem[idx + _19322 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19503 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19503 + -mem[64] + 100
                            if arg3 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _21171 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21171] = 30
                            mem[_21171 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                _21697 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21697 + 68] = mem[idx + _21171 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21697 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21697 + -mem[64] + 100
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                            _25110 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_25110] = 30
                            mem[_25110 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                _25655 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _25655 + 68] = mem[idx + _25110 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_25655 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _25655 + -mem[64] + 100
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg3, arg1, arg2);
                            _29190 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_29190] = 40
                            mem[_29190 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _29931 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _29931 + 68] = mem[idx + _29190 + 32]
                                idx = idx + 32
                                continue 
                            mem[_29931 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _29931 + -mem[64] + 132
                        _17895 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17895] = 26
                        mem[_17895 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 100000000 * 10^18:
                            _18301 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18301] = 26
                            mem[_18301 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                _19114 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19114] = 30
                                mem[_19114 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _20651 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20651] = 30
                                mem[_20651 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > -1:
                                    revert with 0, 17
                                if stor1[arg2] < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2]
                                _24780 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24780] = 30
                                mem[_24780 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _28638 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28638] = 40
                                mem[_28638 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28638 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19818 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19818] = 30
                                mem[_19818 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22181 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22181] = 30
                                mem[_22181 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                _26123 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26123] = 30
                                mem[_26123 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _30597 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30597] = 40
                                mem[_30597 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30597 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _18300 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18300] = 26
                            mem[_18300 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                _19112 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19112] = 30
                                mem[_19112 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _20650 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20650] = 30
                                mem[_20650 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > -1:
                                    revert with 0, 17
                                if stor1[arg2] < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2]
                                _24779 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_24779] = 30
                                mem[_24779 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _28635 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_28635] = 40
                                mem[_28635 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28635 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19817 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19817] = 30
                                mem[_19817 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 * t / s < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22180 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22180] = 30
                                mem[_22180 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * t / s
                                if stor1[arg2] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                _26122 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26122] = 30
                                mem[_26122 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _30594 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30594] = 40
                                mem[_30594 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30594 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        if arg3 / 100 and 15 > -1 / arg3 / 100:
                            revert with 0, 17
                        if not arg3 / 100:
                            revert with 0, 18
                        if 15 * arg3 / 100 / arg3 / 100 != 15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 15 * arg3 / 100 > arg3:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg3 < 15 * arg3 / 100:
                            revert with 0, 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _18074 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18074] = 26
                                mem[_18074 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    if not 15 * arg3 / 100:
                                        _18793 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18793] = 30
                                        mem[_18793 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _19499 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19499] = 30
                                        mem[_19499 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _19814 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19814 + 68] = mem[idx + _19499 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19814 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19814 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _23157 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23157] = 30
                                        mem[_23157 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _23547 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _23547 + 68] = mem[idx + _23157 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23547 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _23547 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _27201 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27201] = 40
                                        mem[_27201 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _27633 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _27633 + 68] = mem[idx + _27201 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27633 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _27633 + -mem[64] + 132
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19109 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19109] = 30
                                    mem[_19109 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _19318 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19318 + 68] = mem[idx + _19109 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19318 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19318 + -mem[64] + 100
                                    if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20646 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20646] = 30
                                    mem[_20646 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _21163 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21163 + 68] = mem[idx + _20646 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21163 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21163 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _24771 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24771] = 30
                                    mem[_24771 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        _25102 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25102 + 68] = mem[idx + _24771 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25102 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25102 + -mem[64] + 100
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _28630 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28630] = 40
                                    mem[_28630 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29174 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29174 + 68] = mem[idx + _28630 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29174 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29174 + -mem[64] + 132
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg3 / 100:
                                    _19108 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19108] = 30
                                    mem[_19108 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        _19317 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19317 + 68] = mem[idx + _19108 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19317 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19317 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20645 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20645] = 30
                                    mem[_20645 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _21162 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21162 + 68] = mem[idx + _20645 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21162 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21162 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _24770 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24770] = 30
                                    mem[_24770 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _25101 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25101 + 68] = mem[idx + _24770 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25101 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25101 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _28627 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28627] = 40
                                    mem[_28627 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29173 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29173 + 68] = mem[idx + _28627 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29173 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29173 + -mem[64] + 132
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19813 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19813] = 30
                                mem[_19813 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                    _20135 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20135 + 68] = mem[idx + _19813 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20135 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20135 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22177 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22177] = 30
                                mem[_22177 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _22847 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22847 + 68] = mem[idx + _22177 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22847 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22847 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                _26118 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26118] = 30
                                mem[_26118 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    _26534 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _26534 + 68] = mem[idx + _26118 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_26534 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _26534 + -mem[64] + 100
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _30588 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30588] = 40
                                mem[_30588 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _31178 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _31178 + 68] = mem[idx + _30588 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31178 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _31178 + -mem[64] + 132
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _18178 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18178] = 30
                                mem[_18178 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _18224 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18224 + 68] = mem[idx + _18178 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18224 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18224 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _18569 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18569] = 30
                                mem[_18569 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _18629 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18629 + 68] = mem[idx + _18569 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18629 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18629 + -mem[64] + 100
                            _18179 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18179] = 26
                            mem[_18179 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                if not 15 * arg3 / 100:
                                    _18929 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18929] = 30
                                    mem[_18929 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19816 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19816] = 30
                                    mem[_19816 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _20139 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20139 + 68] = mem[idx + _19816 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20139 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20139 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _23549 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23549] = 30
                                    mem[_23549 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _24117 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _24117 + 68] = mem[idx + _23549 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24117 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _24117 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _27635 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_27635] = 40
                                    mem[_27635 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _28203 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _28203 + 68] = mem[idx + _27635 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_28203 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _28203 + -mem[64] + 132
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19320 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19320] = 30
                                mem[_19320 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _19501 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19501 + 68] = mem[idx + _19320 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19501 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19501 + -mem[64] + 100
                                if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _21166 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21166] = 30
                                mem[_21166 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    _21693 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21693 + 68] = mem[idx + _21166 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21693 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21693 + -mem[64] + 100
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                _25105 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25105] = 30
                                mem[_25105 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    _25649 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25649 + 68] = mem[idx + _25105 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25649 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25649 + -mem[64] + 100
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _29180 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_29180] = 40
                                mem[_29180 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _29925 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29925 + 68] = mem[idx + _29180 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29925 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29925 + -mem[64] + 132
                            if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg3 / 100:
                                _19319 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19319] = 30
                                mem[_19319 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    _19500 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19500 + 68] = mem[idx + _19319 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19500 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19500 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _21165 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21165] = 30
                                mem[_21165 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _21692 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21692 + 68] = mem[idx + _21165 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21692 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21692 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                _25104 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25104] = 30
                                mem[_25104 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _25648 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25648 + 68] = mem[idx + _25104 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25648 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25648 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _29177 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_29177] = 40
                                mem[_29177 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _29924 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29924 + 68] = mem[idx + _29177 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29924 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29924 + -mem[64] + 132
                            if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                revert with 0, 17
                            if not 15 * arg3 / 100:
                                revert with 0, 18
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20138 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20138] = 30
                            mem[_20138 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                _20647 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20647 + 68] = mem[idx + _20138 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20647 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20647 + -mem[64] + 100
                            if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _22850 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22850] = 30
                            mem[_22850 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                _23388 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23388 + 68] = mem[idx + _22850 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23388 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23388 + -mem[64] + 100
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                revert with 0, 17
                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                            _26538 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26538] = 30
                            mem[_26538 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                _26994 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _26994 + 68] = mem[idx + _26538 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_26994 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _26994 + -mem[64] + 100
                            if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _31183 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_31183] = 40
                            mem[_31183 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _32231 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _32231 + 68] = mem[idx + _31183 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32231 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _32231 + -mem[64] + 132
                        _17892 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17892] = 26
                        mem[_17892 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 100000000 * 10^18:
                            _18299 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18299] = 26
                            mem[_18299 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                if not 15 * arg3 / 100:
                                    _19107 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19107] = 30
                                    mem[_19107 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20644 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20644] = 30
                                    mem[_20644 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _24769 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24769] = 30
                                    mem[_24769 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _28624 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28624] = 40
                                    mem[_28624 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28624 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19812 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19812] = 30
                                    mem[_19812 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22176 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22176] = 30
                                    mem[_22176 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _26117 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26117] = 30
                                    mem[_26117 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30585 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30585] = 40
                                    mem[_30585 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30585 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg3 / 100:
                                    _19811 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19811] = 30
                                    mem[_19811 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22175 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22175] = 30
                                    mem[_22175 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _26116 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26116] = 30
                                    mem[_26116 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30582 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30582] = 40
                                    mem[_30582 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30582 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _21160 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21160] = 30
                                    mem[_21160 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _23736 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23736] = 30
                                    mem[_23736 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _27386 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27386] = 30
                                    mem[_27386 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _32970 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_32970] = 40
                                    mem[_32970 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32970 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _18298 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18298] = 26
                            mem[_18298 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                if not 15 * arg3 / 100:
                                    _19105 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19105] = 30
                                    mem[_19105 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20642 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20642] = 30
                                    mem[_20642 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _24767 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24767] = 30
                                    mem[_24767 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _28620 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28620] = 40
                                    mem[_28620 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28620 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19810 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19810] = 30
                                    mem[_19810 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 15 * arg3 / 100 * t / s:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22174 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22174] = 30
                                    mem[_22174 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > !(-15 * arg3 / 100 * t / s):
                                        revert with 0, 17
                                    if stor1[arg2] - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * t / s)
                                    _26115 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26115] = 30
                                    mem[_26115 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg3 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * t / s
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30579 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30579] = 40
                                    mem[_30579 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30579 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg3 / 100:
                                    _19809 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19809] = 30
                                    mem[_19809 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * t / s < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22173 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22173] = 30
                                    mem[_22173 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * t / s
                                    if stor1[arg2] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                    _26114 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26114] = 30
                                    mem[_26114 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30576 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30576] = 40
                                    mem[_30576 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30576 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _21158 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21158] = 30
                                    mem[_21158 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * t / s > arg3 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * t / s < 15 * arg3 / 100 * t / s:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _23734 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23734] = 30
                                    mem[_23734 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * t / s
                                    if stor1[arg2] > !((arg3 * t / s) - (15 * arg3 / 100 * t / s)):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s)
                                    _27384 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27384] = 30
                                    mem[_27384 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg3 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * t / s
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _32966 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_32966] = 40
                                    mem[_32966 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32966 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    mem[0] = arg2
                    mem[32] = 4
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if stor4[address(arg2)]:
                        if not arg3 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg3:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg3 < 0:
                                revert with 0, 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _18077 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18077] = 26
                                    mem[_18077 + 32] = 'SafeMath: division by zero'
                                    if not arg3:
                                        _18802 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18802] = 30
                                        mem[_18802 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _19510 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19510] = 30
                                        mem[_19510 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _19831 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19831 + 68] = mem[idx + _19510 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19831 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19831 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _23192 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23192] = 30
                                        mem[_23192 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _23566 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _23566 + 68] = mem[idx + _23192 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23566 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _23566 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg3, arg1, arg2);
                                        _27224 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27224] = 40
                                        mem[_27224 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _27666 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _27666 + 68] = mem[idx + _27224 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27666 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _27666 + -mem[64] + 132
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19127 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19127] = 30
                                    mem[_19127 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        _19327 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19327 + 68] = mem[idx + _19127 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19327 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19327 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20665 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20665] = 30
                                    mem[_20665 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _21183 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21183 + 68] = mem[idx + _20665 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21183 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21183 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _24799 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24799] = 30
                                    mem[_24799 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _25122 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25122 + 68] = mem[idx + _24799 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25122 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25122 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _28667 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28667] = 40
                                    mem[_28667 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29216 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29216 + 68] = mem[idx + _28667 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29216 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29216 + -mem[64] + 132
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _18184 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18184] = 30
                                    mem[_18184 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _18227 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18227 + 68] = mem[idx + _18184 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18227 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18227 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _18575 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18575] = 30
                                    mem[_18575 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _18635 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18635 + 68] = mem[idx + _18575 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18635 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18635 + -mem[64] + 100
                                _18185 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18185] = 26
                                mem[_18185 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    _18935 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18935] = 30
                                    mem[_18935 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19832 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19832] = 30
                                    mem[_19832 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _20156 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20156 + 68] = mem[idx + _19832 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20156 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20156 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _23567 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23567] = 30
                                    mem[_23567 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _24168 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _24168 + 68] = mem[idx + _23567 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24168 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _24168 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _27667 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_27667] = 40
                                    mem[_27667 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _28223 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _28223 + 68] = mem[idx + _27667 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_28223 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _28223 + -mem[64] + 132
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19328 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19328] = 30
                                mem[_19328 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    _19511 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19511 + 68] = mem[idx + _19328 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19511 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19511 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _21185 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21185] = 30
                                mem[_21185 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _21711 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21711 + 68] = mem[idx + _21185 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21711 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21711 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                _25124 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25124] = 30
                                mem[_25124 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _25680 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25680 + 68] = mem[idx + _25124 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25680 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25680 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _29219 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_29219] = 40
                                mem[_29219 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _29948 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29948 + 68] = mem[idx + _29219 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29948 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29948 + -mem[64] + 132
                            _17901 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17901] = 26
                            mem[_17901 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 100000000 * 10^18:
                                _18305 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18305] = 26
                                mem[_18305 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    _19126 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19126] = 30
                                    mem[_19126 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20664 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20664] = 30
                                    mem[_20664 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _24798 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24798] = 30
                                    mem[_24798 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _28664 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28664] = 40
                                    mem[_28664 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28664 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19830 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19830] = 30
                                    mem[_19830 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22191 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22191] = 30
                                    mem[_22191 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _26134 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26134] = 30
                                    mem[_26134 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _30623 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30623] = 40
                                    mem[_30623 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30623 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _18304 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18304] = 26
                                mem[_18304 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    _19124 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19124] = 30
                                    mem[_19124 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20663 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20663] = 30
                                    mem[_20663 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _24797 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24797] = 30
                                    mem[_24797 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _28661 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28661] = 40
                                    mem[_28661 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28661 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19829 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19829] = 30
                                    mem[_19829 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * t / s < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22190 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22190] = 30
                                    mem[_22190 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * t / s
                                    if stor1[arg2] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                    _26133 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26133] = 30
                                    mem[_26133 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _30620 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30620] = 40
                                    mem[_30620 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30620 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 / 100 and 15 > -1 / arg3 / 100:
                                revert with 0, 17
                            if not arg3 / 100:
                                revert with 0, 18
                            if 15 * arg3 / 100 / arg3 / 100 != 15:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 > arg3:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg3 < 15 * arg3 / 100:
                                revert with 0, 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _18076 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18076] = 26
                                    mem[_18076 + 32] = 'SafeMath: division by zero'
                                    if not arg3:
                                        if not 15 * arg3 / 100:
                                            _18799 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18799] = 30
                                            mem[_18799 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _19507 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19507] = 30
                                            mem[_19507 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(arg1)]:
                                                _19826 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _19826 + 68] = mem[idx + _19507 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19826 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19826 + -mem[64] + 100
                                            if stor1[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor1[arg2] > -1:
                                                revert with 0, 17
                                            if stor1[arg2] < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2]
                                            _23181 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23181] = 30
                                            mem[_23181 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _23561 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _23561 + 68] = mem[idx + _23181 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23561 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _23561 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _27217 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27217] = 40
                                            mem[_27217 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            mem[32] = sha3(address(arg1), 3)
                                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                                if allowance[address(arg1)][msg.sender] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                                return 1
                                            _27656 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _27656 + 68] = mem[idx + _27217 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27656 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _27656 + -mem[64] + 132
                                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19121 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19121] = 30
                                        mem[_19121 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _19324 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19324 + 68] = mem[idx + _19121 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19324 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19324 + -mem[64] + 100
                                        if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20659 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20659] = 30
                                        mem[_20659 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _21177 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21177 + 68] = mem[idx + _20659 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21177 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21177 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                        _24789 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24789] = 30
                                        mem[_24789 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            _25116 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _25116 + 68] = mem[idx + _24789 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25116 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _25116 + -mem[64] + 100
                                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28656 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28656] = 40
                                        mem[_28656 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _29203 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29203 + 68] = mem[idx + _28656 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29203 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29203 + -mem[64] + 132
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg3 / 100:
                                        _19120 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19120] = 30
                                        mem[_19120 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                                            _19323 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19323 + 68] = mem[idx + _19120 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19323 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19323 + -mem[64] + 100
                                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20658 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20658] = 30
                                        mem[_20658 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            _21176 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21176 + 68] = mem[idx + _20658 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21176 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21176 + -mem[64] + 100
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                        _24788 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24788] = 30
                                        mem[_24788 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _25115 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _25115 + 68] = mem[idx + _24788 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25115 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _25115 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28653 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28653] = 40
                                        mem[_28653 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _29202 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29202 + 68] = mem[idx + _28653 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29202 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29202 + -mem[64] + 132
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19825 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19825] = 30
                                    mem[_19825 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                        _20148 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20148 + 68] = mem[idx + _19825 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20148 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20148 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22187 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22187] = 30
                                    mem[_22187 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _22864 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22864 + 68] = mem[idx + _22187 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22864 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22864 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _26129 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26129] = 30
                                    mem[_26129 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        _26553 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _26553 + 68] = mem[idx + _26129 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_26553 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _26553 + -mem[64] + 100
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30614 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30614] = 40
                                    mem[_30614 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _31206 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _31206 + 68] = mem[idx + _30614 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31206 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _31206 + -mem[64] + 132
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _18182 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18182] = 30
                                    mem[_18182 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _18226 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18226 + 68] = mem[idx + _18182 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18226 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18226 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _18573 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18573] = 30
                                    mem[_18573 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _18633 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18633 + 68] = mem[idx + _18573 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18633 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18633 + -mem[64] + 100
                                _18183 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18183] = 26
                                mem[_18183 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    if not 15 * arg3 / 100:
                                        _18933 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18933] = 30
                                        mem[_18933 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _19828 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19828] = 30
                                        mem[_19828 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _20152 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _20152 + 68] = mem[idx + _19828 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_20152 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _20152 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _23563 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23563] = 30
                                        mem[_23563 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _24155 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _24155 + 68] = mem[idx + _23563 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_24155 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _24155 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _27658 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27658] = 40
                                        mem[_27658 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _28218 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _28218 + 68] = mem[idx + _27658 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_28218 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _28218 + -mem[64] + 132
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19326 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19326] = 30
                                    mem[_19326 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _19509 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19509 + 68] = mem[idx + _19326 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19509 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19509 + -mem[64] + 100
                                    if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _21180 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21180] = 30
                                    mem[_21180 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _21707 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21707 + 68] = mem[idx + _21180 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21707 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21707 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _25119 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25119] = 30
                                    mem[_25119 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        _25674 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25674 + 68] = mem[idx + _25119 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25674 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25674 + -mem[64] + 100
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _29209 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_29209] = 40
                                    mem[_29209 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29942 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29942 + 68] = mem[idx + _29209 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29942 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29942 + -mem[64] + 132
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg3 / 100:
                                    _19325 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19325] = 30
                                    mem[_19325 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        _19508 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19508 + 68] = mem[idx + _19325 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19508 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19508 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _21179 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21179] = 30
                                    mem[_21179 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _21706 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21706 + 68] = mem[idx + _21179 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21706 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21706 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _25118 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25118] = 30
                                    mem[_25118 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _25673 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25673 + 68] = mem[idx + _25118 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25673 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25673 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _29206 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_29206] = 40
                                    mem[_29206 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29941 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29941 + 68] = mem[idx + _29206 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29941 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29941 + -mem[64] + 132
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20151 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20151] = 30
                                mem[_20151 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                    _20660 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20660 + 68] = mem[idx + _20151 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20660 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20660 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22867 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22867] = 30
                                mem[_22867 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _23394 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23394 + 68] = mem[idx + _22867 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23394 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23394 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                _26557 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26557] = 30
                                mem[_26557 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    _27004 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _27004 + 68] = mem[idx + _26557 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27004 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _27004 + -mem[64] + 100
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _31211 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_31211] = 40
                                mem[_31211 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _32247 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _32247 + 68] = mem[idx + _31211 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32247 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _32247 + -mem[64] + 132
                            _17898 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17898] = 26
                            mem[_17898 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 100000000 * 10^18:
                                _18303 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18303] = 26
                                mem[_18303 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    if not 15 * arg3 / 100:
                                        _19119 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19119] = 30
                                        mem[_19119 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20657 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20657] = 30
                                        mem[_20657 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _24787 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24787] = 30
                                        mem[_24787 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28650 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28650] = 40
                                        mem[_28650 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28650 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19824 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19824] = 30
                                        mem[_19824 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22186 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22186] = 30
                                        mem[_22186 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                        _26128 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26128] = 30
                                        mem[_26128 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30611 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30611] = 40
                                        mem[_30611 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30611 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg3 / 100:
                                        _19823 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19823] = 30
                                        mem[_19823 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22185 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22185] = 30
                                        mem[_22185 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                        _26127 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26127] = 30
                                        mem[_26127 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30608 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30608] = 40
                                        mem[_30608 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30608 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _21174 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21174] = 30
                                        mem[_21174 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _23747 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23747] = 30
                                        mem[_23747 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                        _27395 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27395] = 30
                                        mem[_27395 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _32986 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_32986] = 40
                                        mem[_32986 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32986 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _18302 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18302] = 26
                                mem[_18302 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    if not 15 * arg3 / 100:
                                        _19117 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19117] = 30
                                        mem[_19117 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20655 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20655] = 30
                                        mem[_20655 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _24785 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24785] = 30
                                        mem[_24785 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28646 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28646] = 40
                                        mem[_28646 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28646 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19822 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19822] = 30
                                        mem[_19822 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 15 * arg3 / 100 * t / s:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22184 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22184] = 30
                                        mem[_22184 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > !(-15 * arg3 / 100 * t / s):
                                            revert with 0, 17
                                        if stor1[arg2] - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * t / s)
                                        _26126 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26126] = 30
                                        mem[_26126 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg3 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * t / s
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30605 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30605] = 40
                                        mem[_30605 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30605 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg3 / 100:
                                        _19821 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19821] = 30
                                        mem[_19821 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * t / s < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22183 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22183] = 30
                                        mem[_22183 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * t / s
                                        if stor1[arg2] > !(arg3 * t / s):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                        _26125 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26125] = 30
                                        mem[_26125 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30602 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30602] = 40
                                        mem[_30602 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30602 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _21172 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21172] = 30
                                        mem[_21172 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * t / s > arg3 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * t / s < 15 * arg3 / 100 * t / s:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _23745 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23745] = 30
                                        mem[_23745 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * t / s
                                        if stor1[arg2] > !((arg3 * t / s) - (15 * arg3 / 100 * t / s)):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s)
                                        _27393 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27393] = 30
                                        mem[_27393 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg3 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * t / s
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _32982 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_32982] = 40
                                        mem[_32982 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32982 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        if not arg3 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg3:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg3 < 0:
                                revert with 0, 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _18079 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18079] = 26
                                    mem[_18079 + 32] = 'SafeMath: division by zero'
                                    if not arg3:
                                        _18808 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18808] = 30
                                        mem[_18808 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _19518 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19518] = 30
                                        mem[_19518 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _19843 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19843 + 68] = mem[idx + _19518 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19843 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19843 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _23216 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23216] = 30
                                        mem[_23216 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _23580 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _23580 + 68] = mem[idx + _23216 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23580 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _23580 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg3, arg1, arg2);
                                        _27240 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27240] = 40
                                        mem[_27240 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _27689 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _27689 + 68] = mem[idx + _27240 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27689 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _27689 + -mem[64] + 132
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19139 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19139] = 30
                                    mem[_19139 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        _19333 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19333 + 68] = mem[idx + _19139 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19333 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19333 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20678 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20678] = 30
                                    mem[_20678 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _21197 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21197 + 68] = mem[idx + _20678 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21197 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21197 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _24817 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24817] = 30
                                    mem[_24817 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _25136 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25136 + 68] = mem[idx + _24817 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25136 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25136 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _28693 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28693] = 40
                                    mem[_28693 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29245 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29245 + 68] = mem[idx + _28693 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29245 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29245 + -mem[64] + 132
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _18188 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18188] = 30
                                    mem[_18188 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _18229 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18229 + 68] = mem[idx + _18188 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18229 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18229 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _18579 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18579] = 30
                                    mem[_18579 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _18639 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18639 + 68] = mem[idx + _18579 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18639 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18639 + -mem[64] + 100
                                _18189 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18189] = 26
                                mem[_18189 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    _18939 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18939] = 30
                                    mem[_18939 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19844 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19844] = 30
                                    mem[_19844 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _20169 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20169 + 68] = mem[idx + _19844 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20169 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20169 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _23581 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23581] = 30
                                    mem[_23581 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _24206 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _24206 + 68] = mem[idx + _23581 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24206 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _24206 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _27690 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_27690] = 40
                                    mem[_27690 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _28238 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _28238 + 68] = mem[idx + _27690 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_28238 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _28238 + -mem[64] + 132
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19334 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19334] = 30
                                mem[_19334 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    _19519 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19519 + 68] = mem[idx + _19334 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19519 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19519 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _21199 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21199] = 30
                                mem[_21199 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _21725 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21725 + 68] = mem[idx + _21199 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21725 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21725 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                _25138 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25138] = 30
                                mem[_25138 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _25705 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25705 + 68] = mem[idx + _25138 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25705 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25705 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _29248 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_29248] = 40
                                mem[_29248 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _29965 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29965 + 68] = mem[idx + _29248 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29965 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29965 + -mem[64] + 132
                            _17907 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17907] = 26
                            mem[_17907 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 100000000 * 10^18:
                                _18309 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18309] = 26
                                mem[_18309 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    _19138 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19138] = 30
                                    mem[_19138 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20677 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20677] = 30
                                    mem[_20677 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _24816 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24816] = 30
                                    mem[_24816 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _28690 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28690] = 40
                                    mem[_28690 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28690 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19842 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19842] = 30
                                    mem[_19842 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22201 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22201] = 30
                                    mem[_22201 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _26145 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26145] = 30
                                    mem[_26145 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _30649 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30649] = 40
                                    mem[_30649 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30649 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _18308 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18308] = 26
                                mem[_18308 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    _19136 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19136] = 30
                                    mem[_19136 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20676 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20676] = 30
                                    mem[_20676 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _24815 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24815] = 30
                                    mem[_24815 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _28687 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28687] = 40
                                    mem[_28687 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28687 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19841 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19841] = 30
                                    mem[_19841 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * t / s < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22200 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22200] = 30
                                    mem[_22200 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * t / s
                                    if stor1[arg2] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                    _26144 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26144] = 30
                                    mem[_26144 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _30646 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30646] = 40
                                    mem[_30646 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30646 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 / 100 and 15 > -1 / arg3 / 100:
                                revert with 0, 17
                            if not arg3 / 100:
                                revert with 0, 18
                            if 15 * arg3 / 100 / arg3 / 100 != 15:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 > arg3:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg3 < 15 * arg3 / 100:
                                revert with 0, 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _18078 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18078] = 26
                                    mem[_18078 + 32] = 'SafeMath: division by zero'
                                    if not arg3:
                                        if not 15 * arg3 / 100:
                                            _18805 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18805] = 30
                                            mem[_18805 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _19515 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19515] = 30
                                            mem[_19515 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(arg1)]:
                                                _19838 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _19838 + 68] = mem[idx + _19515 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19838 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19838 + -mem[64] + 100
                                            if stor1[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor1[arg2] > -1:
                                                revert with 0, 17
                                            if stor1[arg2] < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2]
                                            _23205 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23205] = 30
                                            mem[_23205 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _23575 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _23575 + 68] = mem[idx + _23205 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23575 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _23575 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _27233 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27233] = 40
                                            mem[_27233 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            mem[32] = sha3(address(arg1), 3)
                                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                                if allowance[address(arg1)][msg.sender] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                                return 1
                                            _27679 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _27679 + 68] = mem[idx + _27233 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27679 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _27679 + -mem[64] + 132
                                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19133 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19133] = 30
                                        mem[_19133 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _19330 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19330 + 68] = mem[idx + _19133 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19330 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19330 + -mem[64] + 100
                                        if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20672 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20672] = 30
                                        mem[_20672 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _21191 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21191 + 68] = mem[idx + _20672 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21191 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21191 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                        _24807 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24807] = 30
                                        mem[_24807 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            _25130 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _25130 + 68] = mem[idx + _24807 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25130 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _25130 + -mem[64] + 100
                                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28682 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28682] = 40
                                        mem[_28682 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _29232 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29232 + 68] = mem[idx + _28682 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29232 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29232 + -mem[64] + 132
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg3 / 100:
                                        _19132 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19132] = 30
                                        mem[_19132 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                                            _19329 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19329 + 68] = mem[idx + _19132 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19329 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19329 + -mem[64] + 100
                                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20671 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20671] = 30
                                        mem[_20671 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            _21190 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21190 + 68] = mem[idx + _20671 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21190 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21190 + -mem[64] + 100
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                        _24806 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24806] = 30
                                        mem[_24806 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _25129 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _25129 + 68] = mem[idx + _24806 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25129 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _25129 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28679 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28679] = 40
                                        mem[_28679 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _29231 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29231 + 68] = mem[idx + _28679 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29231 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29231 + -mem[64] + 132
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19837 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19837] = 30
                                    mem[_19837 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                        _20161 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20161 + 68] = mem[idx + _19837 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20161 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20161 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22197 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22197] = 30
                                    mem[_22197 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _22881 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22881 + 68] = mem[idx + _22197 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22881 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22881 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _26140 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26140] = 30
                                    mem[_26140 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        _26572 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _26572 + 68] = mem[idx + _26140 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_26572 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _26572 + -mem[64] + 100
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30640 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30640] = 40
                                    mem[_30640 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _31234 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _31234 + 68] = mem[idx + _30640 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31234 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _31234 + -mem[64] + 132
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _18186 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18186] = 30
                                    mem[_18186 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _18228 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18228 + 68] = mem[idx + _18186 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18228 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18228 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _18577 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18577] = 30
                                    mem[_18577 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _18637 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18637 + 68] = mem[idx + _18577 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18637 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18637 + -mem[64] + 100
                                _18187 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18187] = 26
                                mem[_18187 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    if not 15 * arg3 / 100:
                                        _18937 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18937] = 30
                                        mem[_18937 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _19840 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19840] = 30
                                        mem[_19840 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _20165 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _20165 + 68] = mem[idx + _19840 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_20165 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _20165 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _23577 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23577] = 30
                                        mem[_23577 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _24193 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _24193 + 68] = mem[idx + _23577 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_24193 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _24193 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _27681 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27681] = 40
                                        mem[_27681 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _28233 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _28233 + 68] = mem[idx + _27681 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_28233 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _28233 + -mem[64] + 132
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19332 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19332] = 30
                                    mem[_19332 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _19517 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19517 + 68] = mem[idx + _19332 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19517 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19517 + -mem[64] + 100
                                    if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _21194 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21194] = 30
                                    mem[_21194 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _21721 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21721 + 68] = mem[idx + _21194 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21721 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21721 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _25133 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25133] = 30
                                    mem[_25133 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        _25699 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25699 + 68] = mem[idx + _25133 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25699 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25699 + -mem[64] + 100
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _29238 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_29238] = 40
                                    mem[_29238 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29959 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29959 + 68] = mem[idx + _29238 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29959 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29959 + -mem[64] + 132
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg3 / 100:
                                    _19331 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19331] = 30
                                    mem[_19331 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        _19516 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19516 + 68] = mem[idx + _19331 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19516 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19516 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _21193 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21193] = 30
                                    mem[_21193 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _21720 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21720 + 68] = mem[idx + _21193 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21720 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21720 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _25132 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25132] = 30
                                    mem[_25132 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _25698 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25698 + 68] = mem[idx + _25132 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25698 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25698 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _29235 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_29235] = 40
                                    mem[_29235 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29958 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29958 + 68] = mem[idx + _29235 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29958 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29958 + -mem[64] + 132
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20164 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20164] = 30
                                mem[_20164 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                    _20673 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20673 + 68] = mem[idx + _20164 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20673 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20673 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22884 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22884] = 30
                                mem[_22884 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _23400 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23400 + 68] = mem[idx + _22884 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23400 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23400 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                _26576 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26576] = 30
                                mem[_26576 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    _27014 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _27014 + 68] = mem[idx + _26576 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27014 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _27014 + -mem[64] + 100
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _31239 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_31239] = 40
                                mem[_31239 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _32263 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _32263 + 68] = mem[idx + _31239 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32263 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _32263 + -mem[64] + 132
                            _17904 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17904] = 26
                            mem[_17904 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 100000000 * 10^18:
                                _18307 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18307] = 26
                                mem[_18307 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    if not 15 * arg3 / 100:
                                        _19131 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19131] = 30
                                        mem[_19131 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20670 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20670] = 30
                                        mem[_20670 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _24805 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24805] = 30
                                        mem[_24805 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28676 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28676] = 40
                                        mem[_28676 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28676 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19836 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19836] = 30
                                        mem[_19836 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22196 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22196] = 30
                                        mem[_22196 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                        _26139 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26139] = 30
                                        mem[_26139 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30637 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30637] = 40
                                        mem[_30637 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30637 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg3 / 100:
                                        _19835 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19835] = 30
                                        mem[_19835 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22195 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22195] = 30
                                        mem[_22195 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                        _26138 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26138] = 30
                                        mem[_26138 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30634 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30634] = 40
                                        mem[_30634 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30634 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _21188 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21188] = 30
                                        mem[_21188 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _23758 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23758] = 30
                                        mem[_23758 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                        _27404 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27404] = 30
                                        mem[_27404 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _33002 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_33002] = 40
                                        mem[_33002 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_33002 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _18306 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18306] = 26
                                mem[_18306 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    if not 15 * arg3 / 100:
                                        _19129 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19129] = 30
                                        mem[_19129 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20668 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20668] = 30
                                        mem[_20668 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _24803 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24803] = 30
                                        mem[_24803 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28672 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28672] = 40
                                        mem[_28672 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28672 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19834 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19834] = 30
                                        mem[_19834 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 15 * arg3 / 100 * t / s:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22194 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22194] = 30
                                        mem[_22194 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > !(-15 * arg3 / 100 * t / s):
                                            revert with 0, 17
                                        if stor1[arg2] - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * t / s)
                                        _26137 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26137] = 30
                                        mem[_26137 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg3 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * t / s
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30631 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30631] = 40
                                        mem[_30631 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30631 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg3 / 100:
                                        _19833 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19833] = 30
                                        mem[_19833 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * t / s < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22193 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22193] = 30
                                        mem[_22193 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * t / s
                                        if stor1[arg2] > !(arg3 * t / s):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                        _26136 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26136] = 30
                                        mem[_26136 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30628 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30628] = 40
                                        mem[_30628 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30628 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _21186 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21186] = 30
                                        mem[_21186 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * t / s > arg3 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * t / s < 15 * arg3 / 100 * t / s:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _23756 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23756] = 30
                                        mem[_23756 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * t / s
                                        if stor1[arg2] > !((arg3 * t / s) - (15 * arg3 / 100 * t / s)):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s)
                                        _27402 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27402] = 30
                                        mem[_27402 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg3 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * t / s
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _32998 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_32998] = 40
                                        mem[_32998 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_32998 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
            else:
                mem[0] = arg2
                mem[32] = 4
                if stor4[address(arg2)]:
                    mem[96] = 26
                    mem[128] = 'SafeMath: division by zero'
                    if not arg3 / 100:
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 0 > arg3:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg3 < 0:
                            revert with 0, 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _18087 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18087] = 26
                                mem[_18087 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    _18832 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18832] = 30
                                    mem[_18832 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19550 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19550] = 30
                                    mem[_19550 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _19891 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19891 + 68] = mem[idx + _19550 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19891 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19891 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg2)] > !arg3:
                                        revert with 0, 17
                                    if stor2[address(arg2)] + arg3 < stor2[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg2)] += arg3
                                    if stor1[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor1[address(arg2)] < stor1[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    _24888 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24888] = 30
                                    mem[_24888 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _25185 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25185 + 68] = mem[idx + _24888 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25185 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25185 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _28787 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28787] = 40
                                    mem[_28787 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29357 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29357 + 68] = mem[idx + _28787 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29357 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29357 + -mem[64] + 132
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19187 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19187] = 30
                                mem[_19187 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    _19357 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19357 + 68] = mem[idx + _19187 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19357 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19357 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _20730 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20730] = 30
                                mem[_20730 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _21253 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21253 + 68] = mem[idx + _20730 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21253 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21253 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor2[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] += arg3
                                if stor1[address(arg2)] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] += arg3 * stor6 / 100000000 * 10^18
                                _26193 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26193] = 30
                                mem[_26193 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _26651 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _26651 + 68] = mem[idx + _26193 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_26651 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _26651 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _30754 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30754] = 40
                                mem[_30754 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _31359 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _31359 + 68] = mem[idx + _30754 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_31359 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _31359 + -mem[64] + 132
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _18204 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18204] = 30
                                mem[_18204 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _18237 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18237 + 68] = mem[idx + _18204 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18237 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18237 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _18595 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18595] = 30
                                mem[_18595 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _18655 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18655 + 68] = mem[idx + _18595 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18655 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18655 + -mem[64] + 100
                            _18205 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18205] = 26
                            mem[_18205 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                _18955 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18955] = 30
                                mem[_18955 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _19892 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19892] = 30
                                mem[_19892 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    _20221 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20221 + 68] = mem[idx + _19892 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20221 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20221 + -mem[64] + 100
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] += arg3
                                if stor1[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg2)] < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                _25186 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25186] = 30
                                mem[_25186 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _25824 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25824 + 68] = mem[idx + _25186 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25824 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25824 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _29358 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_29358] = 40
                                mem[_29358 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _30033 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _30033 + 68] = mem[idx + _29358 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_30033 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _30033 + -mem[64] + 132
                            if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _19358 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19358] = 30
                            mem[_19358 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg3 * stor6 / 100000000 * 10^18:
                                _19551 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _19551 + 68] = mem[idx + _19358 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_19551 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _19551 + -mem[64] + 100
                            if arg3 * stor6 / 100000000 * 10^18 < 0:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _21255 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_21255] = 30
                            mem[_21255 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                _21781 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _21781 + 68] = mem[idx + _21255 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_21781 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _21781 + -mem[64] + 100
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor2[address(arg2)] > !arg3:
                                revert with 0, 17
                            if stor2[address(arg2)] + arg3 < stor2[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg2)] += arg3
                            if stor1[address(arg2)] > !(arg3 * stor6 / 100000000 * 10^18):
                                revert with 0, 17
                            if stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] += arg3 * stor6 / 100000000 * 10^18
                            _26653 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_26653] = 30
                            mem[_26653 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > stor6:
                                _27073 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _27073 + 68] = mem[idx + _26653 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_27073 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _27073 + -mem[64] + 100
                            if stor6 < 0:
                                revert with 0, 17
                            if totalFees > -1:
                                revert with 0, 17
                            if totalFees < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            emit Transfer(arg3, arg1, arg2);
                            _31362 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_31362] = 40
                            mem[_31362 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _32335 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _32335 + 68] = mem[idx + _31362 + 32]
                                idx = idx + 32
                                continue 
                            mem[_32335 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _32335 + -mem[64] + 132
                        _17931 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17931] = 26
                        mem[_17931 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 100000000 * 10^18:
                            _18325 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18325] = 26
                            mem[_18325 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                _19186 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19186] = 30
                                mem[_19186 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _20729 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20729] = 30
                                mem[_20729 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] += arg3
                                if stor1[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg2)] < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                _26192 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26192] = 30
                                mem[_26192 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _30751 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30751] = 40
                                mem[_30751 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30751 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19890 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19890] = 30
                                mem[_19890 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22241 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22241] = 30
                                mem[_22241 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor2[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] += arg3
                                if stor1[address(arg2)] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] += arg3 * stor6 / 100000000 * 10^18
                                _27447 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27447] = 30
                                mem[_27447 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _33083 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_33083] = 40
                                mem[_33083 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_33083 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _18324 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18324] = 26
                            mem[_18324 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                _19184 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19184] = 30
                                mem[_19184 + 32] = 'SafeMath: subtraction overflow'
                                mem[0] = arg1
                                mem[32] = 1
                                _20728 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20728] = 30
                                mem[_20728 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] += arg3
                                if stor1[address(arg2)] > -1:
                                    revert with 0, 17
                                if stor1[address(arg2)] < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                _26191 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26191] = 30
                                mem[_26191 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _30748 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_30748] = 40
                                mem[_30748 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30748 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19889 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19889] = 30
                                mem[_19889 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 * t / s < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22240 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22240] = 30
                                mem[_22240 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * t / s > stor1[address(arg1)]:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor1[address(arg1)] < arg3 * t / s:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * t / s
                                if stor2[address(arg2)] > !arg3:
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] += arg3
                                if stor1[address(arg2)] > !(arg3 * t / s):
                                    revert with 0, 17
                                if stor1[address(arg2)] + (arg3 * t / s) < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] += arg3 * t / s
                                _27446 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27446] = 30
                                mem[_27446 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _33080 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_33080] = 40
                                mem[_33080 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                if arg3 > allowance[address(arg1)][msg.sender]:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_33080 + 72 len 24]
                                    revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        if arg3 / 100 and 15 > -1 / arg3 / 100:
                            revert with 0, 17
                        if not arg3 / 100:
                            revert with 0, 18
                        if 15 * arg3 / 100 / arg3 / 100 != 15:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[64] = 224
                        mem[160] = 30
                        mem[192] = 'SafeMath: subtraction overflow'
                        if 15 * arg3 / 100 > arg3:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg3 < 15 * arg3 / 100:
                            revert with 0, 17
                        idx = 0
                        s = 100000000 * 10^18
                        t = stor6
                        while idx < stor5.length:
                            mem[0] = stor5[idx]
                            mem[32] = 1
                            if stor1[stor5[idx]] > t:
                                _18086 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18086] = 26
                                mem[_18086 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    if not 15 * arg3 / 100:
                                        _18829 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18829] = 30
                                        mem[_18829 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _19547 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19547] = 30
                                        mem[_19547 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _19886 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19886 + 68] = mem[idx + _19547 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19886 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19886 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                            revert with 0, 17
                                        if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                        if stor1[address(arg2)] > -1:
                                            revert with 0, 17
                                        if stor1[address(arg2)] < stor1[address(arg2)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        _24876 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24876] = 30
                                        mem[_24876 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _25183 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _25183 + 68] = mem[idx + _24876 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25183 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _25183 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28780 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28780] = 40
                                        mem[_28780 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _29347 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29347 + 68] = mem[idx + _28780 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29347 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29347 + -mem[64] + 132
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19181 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19181] = 30
                                    mem[_19181 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _19354 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19354 + 68] = mem[idx + _19181 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19354 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19354 + -mem[64] + 100
                                    if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20724 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20724] = 30
                                    mem[_20724 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _21247 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21247 + 68] = mem[idx + _20724 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21247 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21247 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                    if stor1[address(arg2)] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[address(arg2)] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    _26183 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26183] = 30
                                    mem[_26183 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        _26645 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _26645 + 68] = mem[idx + _26183 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_26645 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _26645 + -mem[64] + 100
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30743 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30743] = 40
                                    mem[_30743 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _31346 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _31346 + 68] = mem[idx + _30743 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31346 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _31346 + -mem[64] + 132
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg3 / 100:
                                    _19180 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19180] = 30
                                    mem[_19180 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        _19353 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19353 + 68] = mem[idx + _19180 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19353 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19353 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20723 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20723] = 30
                                    mem[_20723 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _21246 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21246 + 68] = mem[idx + _20723 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21246 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21246 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                    if stor1[address(arg2)] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] += arg3 * stor6 / 100000000 * 10^18
                                    _26182 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26182] = 30
                                    mem[_26182 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _26644 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _26644 + 68] = mem[idx + _26182 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_26644 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _26644 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30740 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30740] = 40
                                    mem[_30740 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _31345 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _31345 + 68] = mem[idx + _30740 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31345 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _31345 + -mem[64] + 132
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19885 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19885] = 30
                                mem[_19885 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                    _20213 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20213 + 68] = mem[idx + _19885 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20213 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20213 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22237 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22237] = 30
                                mem[_22237 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _22949 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _22949 + 68] = mem[idx + _22237 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_22949 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _22949 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                if stor1[address(arg2)] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                _27442 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_27442] = 30
                                mem[_27442 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    _28064 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _28064 + 68] = mem[idx + _27442 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_28064 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _28064 + -mem[64] + 100
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _33074 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_33074] = 40
                                mem[_33074 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _33556 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _33556 + 68] = mem[idx + _33074 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_33556 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _33556 + -mem[64] + 132
                            if idx >= stor5.length:
                                revert with 0, 50
                            mem[0] = stor5[idx]
                            mem[32] = 2
                            if stor2[stor5[idx]] <= s:
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                _18202 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18202] = 30
                                mem[_18202 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor5[idx]] > t:
                                    _18236 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18236 + 68] = mem[idx + _18202 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18236 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18236 + -mem[64] + 100
                                if t < stor1[stor5[idx]]:
                                    revert with 0, 17
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                _18593 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18593] = 30
                                mem[_18593 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor5[idx]] <= s:
                                    if s < stor2[stor5[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor5[idx]]
                                    t = t - stor1[stor5[idx]]
                                    continue 
                                _18653 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18653 + 68] = mem[idx + _18593 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18653 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18653 + -mem[64] + 100
                            _18203 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18203] = 26
                            mem[_18203 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                if not 15 * arg3 / 100:
                                    _18953 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18953] = 30
                                    mem[_18953 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19888 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19888] = 30
                                    mem[_19888 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _20217 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20217 + 68] = mem[idx + _19888 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20217 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20217 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                    if stor1[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor1[address(arg2)] < stor1[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    _25184 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25184] = 30
                                    mem[_25184 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _25811 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25811 + 68] = mem[idx + _25184 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25811 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25811 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _29349 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_29349] = 40
                                    mem[_29349 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _30028 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _30028 + 68] = mem[idx + _29349 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_30028 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _30028 + -mem[64] + 132
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19356 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19356] = 30
                                mem[_19356 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                    _19549 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19549 + 68] = mem[idx + _19356 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19549 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19549 + -mem[64] + 100
                                if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _21250 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21250] = 30
                                mem[_21250 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor1[address(arg1)]:
                                    _21777 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21777 + 68] = mem[idx + _21250 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21777 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21777 + -mem[64] + 100
                                if stor1[address(arg1)] < 0:
                                    revert with 0, 17
                                if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                if stor1[address(arg2)] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg2)] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                _26648 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26648] = 30
                                mem[_26648 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    _27067 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _27067 + 68] = mem[idx + _26648 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27067 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _27067 + -mem[64] + 100
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _31352 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_31352] = 40
                                mem[_31352 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _32329 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _32329 + 68] = mem[idx + _31352 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32329 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _32329 + -mem[64] + 132
                            if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                revert with 0, 17
                            if not arg3:
                                revert with 0, 18
                            if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not 15 * arg3 / 100:
                                _19355 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19355] = 30
                                mem[_19355 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    _19548 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19548 + 68] = mem[idx + _19355 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19548 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19548 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _21249 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21249] = 30
                                mem[_21249 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _21776 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21776 + 68] = mem[idx + _21249 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21776 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21776 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                    revert with 0, 17
                                if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                if stor1[address(arg2)] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] += arg3 * stor6 / 100000000 * 10^18
                                _26647 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26647] = 30
                                mem[_26647 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _27066 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _27066 + 68] = mem[idx + _26647 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27066 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _27066 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _31349 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_31349] = 40
                                mem[_31349 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _32328 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _32328 + 68] = mem[idx + _31349 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32328 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _32328 + -mem[64] + 132
                            if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                revert with 0, 17
                            if not 15 * arg3 / 100:
                                revert with 0, 18
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _20216 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_20216] = 30
                            mem[_20216 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                _20725 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _20725 + 68] = mem[idx + _20216 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_20725 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _20725 + -mem[64] + 100
                            if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            mem[0] = arg1
                            mem[32] = 1
                            _22952 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_22952] = 30
                            mem[_22952 + 32] = 'SafeMath: subtraction overflow'
                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                _23424 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _23424 + 68] = mem[idx + _22952 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_23424 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _23424 + -mem[64] + 100
                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                            if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                revert with 0, 17
                            if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                            if stor1[address(arg2)] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                revert with 0, 17
                            if stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[0] = arg2
                            mem[32] = 1
                            stor1[address(arg2)] = stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                            _28068 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_28068] = 30
                            mem[_28068 + 32] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                _28422 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _28422 + 68] = mem[idx + _28068 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_28422 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _28422 + -mem[64] + 100
                            if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                revert with 0, 17
                            stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                            if totalFees > !(15 * arg3 / 100):
                                revert with 0, 17
                            if totalFees + (15 * arg3 / 100) < totalFees:
                                revert with 0, 'SafeMath: addition overflow'
                            totalFees += 15 * arg3 / 100
                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                            _33561 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_33561] = 40
                            mem[_33561 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                            mem[32] = sha3(address(arg1), 3)
                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                if allowance[address(arg1)][msg.sender] < arg3:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 'ERC20: approve from the zero address'
                                if not msg.sender:
                                    revert with 0, 'ERC20: approve to the zero address'
                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                return 1
                            _34392 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 40
                            idx = 0
                            while idx < 40:
                                mem[idx + _34392 + 68] = mem[idx + _33561 + 32]
                                idx = idx + 32
                                continue 
                            mem[_34392 + 108] = 0
                            revert with memory
                              from mem[64]
                               len _34392 + -mem[64] + 132
                        _17928 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17928] = 26
                        mem[_17928 + 32] = 'SafeMath: division by zero'
                        if t < stor6 / 100000000 * 10^18:
                            _18323 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18323] = 26
                            mem[_18323 + 32] = 'SafeMath: division by zero'
                            if not arg3:
                                if not 15 * arg3 / 100:
                                    _19179 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19179] = 30
                                    mem[_19179 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20722 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20722] = 30
                                    mem[_20722 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                    if stor1[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor1[address(arg2)] < stor1[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    _26181 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26181] = 30
                                    mem[_26181 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30737 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30737] = 40
                                    mem[_30737 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30737 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19884 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19884] = 30
                                    mem[_19884 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22236 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22236] = 30
                                    mem[_22236 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                    if stor1[address(arg2)] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[address(arg2)] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    _27441 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27441] = 30
                                    mem[_27441 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _33071 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_33071] = 40
                                    mem[_33071 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_33071 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg3 / 100:
                                    _19883 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19883] = 30
                                    mem[_19883 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22235 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22235] = 30
                                    mem[_22235 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                    if stor1[address(arg2)] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] += arg3 * stor6 / 100000000 * 10^18
                                    _27440 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27440] = 30
                                    mem[_27440 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _33068 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_33068] = 40
                                    mem[_33068 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_33068 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _21244 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21244] = 30
                                    mem[_21244 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _23802 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23802] = 30
                                    mem[_23802 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                    if stor1[address(arg2)] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[address(arg2)] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _28950 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28950] = 30
                                    mem[_28950 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _34846 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_34846] = 40
                                    mem[_34846 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_34846 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            _18322 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18322] = 26
                            mem[_18322 + 32] = 'SafeMath: division by zero'
                            if not s:
                                revert with 0, 'SafeMath: division by zero', 0
                            if not arg3:
                                if not 15 * arg3 / 100:
                                    _19177 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19177] = 30
                                    mem[_19177 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20720 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20720] = 30
                                    mem[_20720 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                    if stor1[address(arg2)] > -1:
                                        revert with 0, 17
                                    if stor1[address(arg2)] < stor1[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    _26180 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26180] = 30
                                    mem[_26180 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30733 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30733] = 40
                                    mem[_30733 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30733 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19882 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19882] = 30
                                    mem[_19882 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < 15 * arg3 / 100 * t / s:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22234 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22234] = 30
                                    mem[_22234 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                    if stor1[address(arg2)] > !(-15 * arg3 / 100 * t / s):
                                        revert with 0, 17
                                    if stor1[address(arg2)] - (15 * arg3 / 100 * t / s) < stor1[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] += -15 * arg3 / 100 * t / s
                                    _27439 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27439] = 30
                                    mem[_27439 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg3 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * t / s
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _33065 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_33065] = 40
                                    mem[_33065 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_33065 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 and t / s > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * t / s / arg3 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg3 / 100:
                                    _19881 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19881] = 30
                                    mem[_19881 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * t / s < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22233 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22233] = 30
                                    mem[_22233 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * t / s
                                    if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                    if stor1[address(arg2)] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor1[address(arg2)] + (arg3 * t / s) < stor1[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] += arg3 * t / s
                                    _27438 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_27438] = 30
                                    mem[_27438 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _33062 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_33062] = 40
                                    mem[_33062 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_33062 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _21242 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21242] = 30
                                    mem[_21242 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * t / s > arg3 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * t / s < 15 * arg3 / 100 * t / s:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _23800 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23800] = 30
                                    mem[_23800 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * t / s
                                    if stor2[address(arg2)] > !(arg3 - (15 * arg3 / 100)):
                                        revert with 0, 17
                                    if stor2[address(arg2)] + arg3 - (15 * arg3 / 100) < stor2[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    stor2[address(arg2)] = stor2[address(arg2)] + arg3 - (15 * arg3 / 100)
                                    if stor1[address(arg2)] > !((arg3 * t / s) - (15 * arg3 / 100 * t / s)):
                                        revert with 0, 17
                                    if stor1[address(arg2)] + (arg3 * t / s) - (15 * arg3 / 100 * t / s) < stor1[address(arg2)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[address(arg2)] + (arg3 * t / s) - (15 * arg3 / 100 * t / s)
                                    _28948 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_28948] = 30
                                    mem[_28948 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * t / s > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 15 * arg3 / 100 * t / s:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * t / s
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _34842 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_34842] = 40
                                    mem[_34842 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_34842 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                else:
                    mem[0] = arg1
                    mem[32] = 4
                    if stor4[address(arg1)]:
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        if not arg3 / 100:
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 0 > arg3:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg3 < 0:
                                revert with 0, 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _18081 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18081] = 26
                                    mem[_18081 + 32] = 'SafeMath: division by zero'
                                    if not arg3:
                                        _18814 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18814] = 30
                                        mem[_18814 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _19526 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19526] = 30
                                        mem[_19526 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _19855 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19855 + 68] = mem[idx + _19526 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19855 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19855 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _23240 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23240] = 30
                                        mem[_23240 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _23594 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _23594 + 68] = mem[idx + _23240 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_23594 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _23594 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg3, arg1, arg2);
                                        _27256 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27256] = 40
                                        mem[_27256 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _27712 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _27712 + 68] = mem[idx + _27256 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27712 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _27712 + -mem[64] + 132
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19151 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19151] = 30
                                    mem[_19151 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        _19339 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19339 + 68] = mem[idx + _19151 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19339 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19339 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20691 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20691] = 30
                                    mem[_20691 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _21211 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21211 + 68] = mem[idx + _20691 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21211 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21211 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _24835 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24835] = 30
                                    mem[_24835 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _25150 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25150 + 68] = mem[idx + _24835 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25150 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25150 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _28719 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28719] = 40
                                    mem[_28719 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29274 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29274 + 68] = mem[idx + _28719 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29274 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29274 + -mem[64] + 132
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _18192 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18192] = 30
                                    mem[_18192 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _18231 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18231 + 68] = mem[idx + _18192 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18231 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18231 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _18583 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18583] = 30
                                    mem[_18583 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _18643 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18643 + 68] = mem[idx + _18583 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18643 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18643 + -mem[64] + 100
                                _18193 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18193] = 26
                                mem[_18193 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    _18943 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18943] = 30
                                    mem[_18943 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _19856 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19856] = 30
                                    mem[_19856 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _20182 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20182 + 68] = mem[idx + _19856 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20182 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20182 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _23595 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_23595] = 30
                                    mem[_23595 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _24244 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _24244 + 68] = mem[idx + _23595 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_24244 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _24244 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _27713 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_27713] = 40
                                    mem[_27713 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _28253 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _28253 + 68] = mem[idx + _27713 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_28253 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _28253 + -mem[64] + 132
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _19340 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_19340] = 30
                                mem[_19340 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg3 * stor6 / 100000000 * 10^18:
                                    _19527 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _19527 + 68] = mem[idx + _19340 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_19527 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _19527 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 0:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _21213 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_21213] = 30
                                mem[_21213 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _21739 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _21739 + 68] = mem[idx + _21213 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_21739 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _21739 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                _25152 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_25152] = 30
                                mem[_25152 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > stor6:
                                    _25730 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _25730 + 68] = mem[idx + _25152 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_25730 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _25730 + -mem[64] + 100
                                if stor6 < 0:
                                    revert with 0, 17
                                if totalFees > -1:
                                    revert with 0, 17
                                if totalFees < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                emit Transfer(arg3, arg1, arg2);
                                _29277 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_29277] = 40
                                mem[_29277 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _29982 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _29982 + 68] = mem[idx + _29277 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_29982 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _29982 + -mem[64] + 132
                            _17913 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17913] = 26
                            mem[_17913 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 100000000 * 10^18:
                                _18313 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18313] = 26
                                mem[_18313 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    _19150 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19150] = 30
                                    mem[_19150 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20690 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20690] = 30
                                    mem[_20690 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _24834 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24834] = 30
                                    mem[_24834 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _28716 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28716] = 40
                                    mem[_28716 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28716 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19854 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19854] = 30
                                    mem[_19854 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22211 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22211] = 30
                                    mem[_22211 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _26156 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26156] = 30
                                    mem[_26156 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _30675 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30675] = 40
                                    mem[_30675 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30675 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _18312 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18312] = 26
                                mem[_18312 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    _19148 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19148] = 30
                                    mem[_19148 + 32] = 'SafeMath: subtraction overflow'
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _20689 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20689] = 30
                                    mem[_20689 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > -1:
                                        revert with 0, 17
                                    if stor1[arg2] < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2]
                                    _24833 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_24833] = 30
                                    mem[_24833 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _28713 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_28713] = 40
                                    mem[_28713 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28713 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19853 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19853] = 30
                                    mem[_19853 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if arg3 * t / s < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22210 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22210] = 30
                                    mem[_22210 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * t / s > stor1[address(arg1)]:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor1[address(arg1)] < arg3 * t / s:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * t / s
                                    if stor1[arg2] > !(arg3 * t / s):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                    _26155 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26155] = 30
                                    mem[_26155 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _30672 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30672] = 40
                                    mem[_30672 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    if arg3 > allowance[address(arg1)][msg.sender]:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30672 + 72 len 24]
                                        revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if arg3 / 100 and 15 > -1 / arg3 / 100:
                                revert with 0, 17
                            if not arg3 / 100:
                                revert with 0, 18
                            if 15 * arg3 / 100 / arg3 / 100 != 15:
                                revert with 0, 'SafeMath: multiplication overflow'
                            mem[64] = 224
                            mem[160] = 30
                            mem[192] = 'SafeMath: subtraction overflow'
                            if 15 * arg3 / 100 > arg3:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg3 < 15 * arg3 / 100:
                                revert with 0, 17
                            idx = 0
                            s = 100000000 * 10^18
                            t = stor6
                            while idx < stor5.length:
                                mem[0] = stor5[idx]
                                mem[32] = 1
                                if stor1[stor5[idx]] > t:
                                    _18080 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18080] = 26
                                    mem[_18080 + 32] = 'SafeMath: division by zero'
                                    if not arg3:
                                        if not 15 * arg3 / 100:
                                            _18811 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18811] = 30
                                            mem[_18811 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _19523 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19523] = 30
                                            mem[_19523 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(arg1)]:
                                                _19850 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _19850 + 68] = mem[idx + _19523 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19850 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19850 + -mem[64] + 100
                                            if stor1[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor1[arg2] > -1:
                                                revert with 0, 17
                                            if stor1[arg2] < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2]
                                            _23229 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23229] = 30
                                            mem[_23229 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _23589 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _23589 + 68] = mem[idx + _23229 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23589 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _23589 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _27249 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27249] = 40
                                            mem[_27249 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            mem[32] = sha3(address(arg1), 3)
                                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                                if allowance[address(arg1)][msg.sender] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                                return 1
                                            _27702 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _27702 + 68] = mem[idx + _27249 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27702 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _27702 + -mem[64] + 132
                                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19145 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19145] = 30
                                        mem[_19145 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _19336 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19336 + 68] = mem[idx + _19145 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19336 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19336 + -mem[64] + 100
                                        if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20685 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20685] = 30
                                        mem[_20685 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _21205 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21205 + 68] = mem[idx + _20685 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21205 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21205 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                        _24825 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24825] = 30
                                        mem[_24825 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            _25144 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _25144 + 68] = mem[idx + _24825 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25144 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _25144 + -mem[64] + 100
                                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28708 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28708] = 40
                                        mem[_28708 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _29261 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29261 + 68] = mem[idx + _28708 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29261 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29261 + -mem[64] + 132
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg3 / 100:
                                        _19144 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19144] = 30
                                        mem[_19144 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                                            _19335 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19335 + 68] = mem[idx + _19144 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19335 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19335 + -mem[64] + 100
                                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20684 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20684] = 30
                                        mem[_20684 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            _21204 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21204 + 68] = mem[idx + _20684 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21204 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21204 + -mem[64] + 100
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                        _24824 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24824] = 30
                                        mem[_24824 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _25143 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _25143 + 68] = mem[idx + _24824 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25143 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _25143 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28705 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28705] = 40
                                        mem[_28705 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _29260 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29260 + 68] = mem[idx + _28705 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29260 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29260 + -mem[64] + 132
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19849 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19849] = 30
                                    mem[_19849 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                        _20174 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20174 + 68] = mem[idx + _19849 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20174 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20174 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22207 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22207] = 30
                                    mem[_22207 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _22898 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _22898 + 68] = mem[idx + _22207 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_22898 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _22898 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _26151 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26151] = 30
                                    mem[_26151 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        _26591 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _26591 + 68] = mem[idx + _26151 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_26591 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _26591 + -mem[64] + 100
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _30666 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_30666] = 40
                                    mem[_30666 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _31262 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _31262 + 68] = mem[idx + _30666 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_31262 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _31262 + -mem[64] + 132
                                if idx >= stor5.length:
                                    revert with 0, 50
                                mem[0] = stor5[idx]
                                mem[32] = 2
                                if stor2[stor5[idx]] <= s:
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    _18190 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18190] = 30
                                    mem[_18190 + 32] = 'SafeMath: subtraction overflow'
                                    if stor1[stor5[idx]] > t:
                                        _18230 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18230 + 68] = mem[idx + _18190 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18230 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18230 + -mem[64] + 100
                                    if t < stor1[stor5[idx]]:
                                        revert with 0, 17
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    _18581 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18581] = 30
                                    mem[_18581 + 32] = 'SafeMath: subtraction overflow'
                                    if stor2[stor5[idx]] <= s:
                                        if s < stor2[stor5[idx]]:
                                            revert with 0, 17
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s - stor2[stor5[idx]]
                                        t = t - stor1[stor5[idx]]
                                        continue 
                                    _18641 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18641 + 68] = mem[idx + _18581 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18641 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18641 + -mem[64] + 100
                                _18191 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18191] = 26
                                mem[_18191 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    if not 15 * arg3 / 100:
                                        _18941 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18941] = 30
                                        mem[_18941 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _19852 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19852] = 30
                                        mem[_19852 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _20178 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _20178 + 68] = mem[idx + _19852 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_20178 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _20178 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _23591 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23591] = 30
                                        mem[_23591 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _24231 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _24231 + 68] = mem[idx + _23591 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_24231 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _24231 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _27704 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27704] = 40
                                        mem[_27704 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _28248 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _28248 + 68] = mem[idx + _27704 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_28248 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _28248 + -mem[64] + 132
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19338 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19338] = 30
                                    mem[_19338 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                        _19525 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19525 + 68] = mem[idx + _19338 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19525 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19525 + -mem[64] + 100
                                    if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _21208 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21208] = 30
                                    mem[_21208 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor1[address(arg1)]:
                                        _21735 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21735 + 68] = mem[idx + _21208 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21735 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21735 + -mem[64] + 100
                                    if stor1[address(arg1)] < 0:
                                        revert with 0, 17
                                    if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _25147 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25147] = 30
                                    mem[_25147 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        _25724 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25724 + 68] = mem[idx + _25147 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25724 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25724 + -mem[64] + 100
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _29267 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_29267] = 40
                                    mem[_29267 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29976 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29976 + 68] = mem[idx + _29267 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29976 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29976 + -mem[64] + 132
                                if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                    revert with 0, 17
                                if not arg3:
                                    revert with 0, 18
                                if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not 15 * arg3 / 100:
                                    _19337 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19337] = 30
                                    mem[_19337 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        _19524 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19524 + 68] = mem[idx + _19337 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19524 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19524 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _21207 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21207] = 30
                                    mem[_21207 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _21734 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21734 + 68] = mem[idx + _21207 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21734 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21734 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _25146 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25146] = 30
                                    mem[_25146 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _25723 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25723 + 68] = mem[idx + _25146 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25723 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25723 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _29264 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_29264] = 40
                                    mem[_29264 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29975 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29975 + 68] = mem[idx + _29264 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29975 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29975 + -mem[64] + 132
                                if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                    revert with 0, 17
                                if not 15 * arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _20177 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_20177] = 30
                                mem[_20177 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                    _20686 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _20686 + 68] = mem[idx + _20177 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_20686 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _20686 + -mem[64] + 100
                                if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                mem[0] = arg1
                                mem[32] = 1
                                _22901 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_22901] = 30
                                mem[_22901 + 32] = 'SafeMath: subtraction overflow'
                                if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                    _23406 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _23406 + 68] = mem[idx + _22901 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_23406 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _23406 + -mem[64] + 100
                                if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                    revert with 0, 17
                                if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[0] = arg2
                                mem[32] = 1
                                stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                _26595 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_26595] = 30
                                mem[_26595 + 32] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                    _27024 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _27024 + 68] = mem[idx + _26595 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_27024 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _27024 + -mem[64] + 100
                                if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                    revert with 0, 17
                                stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                if totalFees > !(15 * arg3 / 100):
                                    revert with 0, 17
                                if totalFees + (15 * arg3 / 100) < totalFees:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalFees += 15 * arg3 / 100
                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                _31267 = mem[64]
                                mem[64] = mem[64] + 96
                                mem[_31267] = 40
                                mem[_31267 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                mem[32] = sha3(address(arg1), 3)
                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                    if allowance[address(arg1)][msg.sender] < arg3:
                                        revert with 0, 17
                                    if not arg1:
                                        revert with 0, 'ERC20: approve from the zero address'
                                    if not msg.sender:
                                        revert with 0, 'ERC20: approve to the zero address'
                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                    return 1
                                _32279 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 40
                                idx = 0
                                while idx < 40:
                                    mem[idx + _32279 + 68] = mem[idx + _31267 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_32279 + 108] = 0
                                revert with memory
                                  from mem[64]
                                   len _32279 + -mem[64] + 132
                            _17910 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17910] = 26
                            mem[_17910 + 32] = 'SafeMath: division by zero'
                            if t < stor6 / 100000000 * 10^18:
                                _18311 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18311] = 26
                                mem[_18311 + 32] = 'SafeMath: division by zero'
                                if not arg3:
                                    if not 15 * arg3 / 100:
                                        _19143 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19143] = 30
                                        mem[_19143 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20683 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20683] = 30
                                        mem[_20683 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _24823 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24823] = 30
                                        mem[_24823 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28702 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28702] = 40
                                        mem[_28702 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28702 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19848 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19848] = 30
                                        mem[_19848 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22206 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22206] = 30
                                        mem[_22206 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                        _26150 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26150] = 30
                                        mem[_26150 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30663 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30663] = 40
                                        mem[_30663 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30663 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg3 / 100:
                                        _19847 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19847] = 30
                                        mem[_19847 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22205 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22205] = 30
                                        mem[_22205 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                        _26149 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26149] = 30
                                        mem[_26149 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30660 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30660] = 40
                                        mem[_30660 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30660 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _21202 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21202] = 30
                                        mem[_21202 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _23769 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23769] = 30
                                        mem[_23769 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                        _27413 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27413] = 30
                                        mem[_27413 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _33018 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_33018] = 40
                                        mem[_33018 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_33018 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                _18310 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18310] = 26
                                mem[_18310 + 32] = 'SafeMath: division by zero'
                                if not s:
                                    revert with 0, 'SafeMath: division by zero', 0
                                if not arg3:
                                    if not 15 * arg3 / 100:
                                        _19141 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19141] = 30
                                        mem[_19141 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20681 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20681] = 30
                                        mem[_20681 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _24821 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24821] = 30
                                        mem[_24821 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _28698 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28698] = 40
                                        mem[_28698 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28698 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19846 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19846] = 30
                                        mem[_19846 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * t / s > 0:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if 0 < 15 * arg3 / 100 * t / s:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22204 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22204] = 30
                                        mem[_22204 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > !(-15 * arg3 / 100 * t / s):
                                            revert with 0, 17
                                        if stor1[arg2] - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * t / s)
                                        _26148 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26148] = 30
                                        mem[_26148 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg3 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * t / s
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30657 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30657] = 40
                                        mem[_30657 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30657 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    if arg3 and t / s > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * t / s / arg3 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg3 / 100:
                                        _19845 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19845] = 30
                                        mem[_19845 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * t / s < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22203 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22203] = 30
                                        mem[_22203 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * t / s
                                        if stor1[arg2] > !(arg3 * t / s):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                        _26147 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26147] = 30
                                        mem[_26147 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30654 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30654] = 40
                                        mem[_30654 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30654 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _21200 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21200] = 30
                                        mem[_21200 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * t / s > arg3 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * t / s < 15 * arg3 / 100 * t / s:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _23767 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23767] = 30
                                        mem[_23767 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * t / s
                                        if stor1[arg2] > !((arg3 * t / s) - (15 * arg3 / 100 * t / s)):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s)
                                        _27411 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_27411] = 30
                                        mem[_27411 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * t / s > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 15 * arg3 / 100 * t / s:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * t / s
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _33014 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_33014] = 40
                                        mem[_33014 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_33014 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                    else:
                        mem[0] = arg2
                        mem[32] = 4
                        mem[96] = 26
                        mem[128] = 'SafeMath: division by zero'
                        if stor4[address(arg2)]:
                            if not arg3 / 100:
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg3:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 < 0:
                                    revert with 0, 17
                                idx = 0
                                s = 100000000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _18083 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18083] = 26
                                        mem[_18083 + 32] = 'SafeMath: division by zero'
                                        if not arg3:
                                            _18820 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18820] = 30
                                            mem[_18820 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _19534 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19534] = 30
                                            mem[_19534 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(arg1)]:
                                                _19867 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _19867 + 68] = mem[idx + _19534 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19867 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19867 + -mem[64] + 100
                                            if stor1[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor1[arg2] > -1:
                                                revert with 0, 17
                                            if stor1[arg2] < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2]
                                            _23264 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23264] = 30
                                            mem[_23264 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _23608 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _23608 + 68] = mem[idx + _23264 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23608 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _23608 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg3, arg1, arg2);
                                            _27272 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27272] = 40
                                            mem[_27272 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            mem[32] = sha3(address(arg1), 3)
                                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                                if allowance[address(arg1)][msg.sender] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                                return 1
                                            _27735 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _27735 + 68] = mem[idx + _27272 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27735 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _27735 + -mem[64] + 132
                                        if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19163 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19163] = 30
                                        mem[_19163 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                                            _19345 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19345 + 68] = mem[idx + _19163 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19345 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19345 + -mem[64] + 100
                                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20704 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20704] = 30
                                        mem[_20704 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            _21225 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21225 + 68] = mem[idx + _20704 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21225 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21225 + -mem[64] + 100
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                        _24853 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24853] = 30
                                        mem[_24853 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _25164 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _25164 + 68] = mem[idx + _24853 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25164 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _25164 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg3, arg1, arg2);
                                        _28745 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28745] = 40
                                        mem[_28745 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _29303 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29303 + 68] = mem[idx + _28745 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29303 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29303 + -mem[64] + 132
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _18196 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18196] = 30
                                        mem[_18196 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _18233 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18233 + 68] = mem[idx + _18196 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18233 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18233 + -mem[64] + 100
                                        if t < stor1[stor5[idx]]:
                                            revert with 0, 17
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _18587 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18587] = 30
                                        mem[_18587 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            if s < stor2[stor5[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _18647 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18647 + 68] = mem[idx + _18587 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18647 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18647 + -mem[64] + 100
                                    _18197 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18197] = 26
                                    mem[_18197 + 32] = 'SafeMath: division by zero'
                                    if not arg3:
                                        _18947 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18947] = 30
                                        mem[_18947 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _19868 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19868] = 30
                                        mem[_19868 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _20195 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _20195 + 68] = mem[idx + _19868 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_20195 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _20195 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _23609 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23609] = 30
                                        mem[_23609 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _24282 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _24282 + 68] = mem[idx + _23609 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_24282 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _24282 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg3, arg1, arg2);
                                        _27736 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27736] = 40
                                        mem[_27736 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _28268 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _28268 + 68] = mem[idx + _27736 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_28268 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _28268 + -mem[64] + 132
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19346 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19346] = 30
                                    mem[_19346 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        _19535 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19535 + 68] = mem[idx + _19346 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19535 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19535 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _21227 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21227] = 30
                                    mem[_21227 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _21753 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21753 + 68] = mem[idx + _21227 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21753 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21753 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _25166 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25166] = 30
                                    mem[_25166 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _25755 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25755 + 68] = mem[idx + _25166 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25755 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25755 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _29306 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_29306] = 40
                                    mem[_29306 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _29999 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _29999 + 68] = mem[idx + _29306 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_29999 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _29999 + -mem[64] + 132
                                _17919 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17919] = 26
                                mem[_17919 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 100000000 * 10^18:
                                    _18317 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18317] = 26
                                    mem[_18317 + 32] = 'SafeMath: division by zero'
                                    if not arg3:
                                        _19162 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19162] = 30
                                        mem[_19162 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20703 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20703] = 30
                                        mem[_20703 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _24852 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24852] = 30
                                        mem[_24852 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg3, arg1, arg2);
                                        _28742 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28742] = 40
                                        mem[_28742 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28742 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19866 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19866] = 30
                                        mem[_19866 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22221 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22221] = 30
                                        mem[_22221 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                        _26167 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26167] = 30
                                        mem[_26167 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg3, arg1, arg2);
                                        _30701 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30701] = 40
                                        mem[_30701 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30701 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    _18316 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18316] = 26
                                    mem[_18316 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        _19160 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19160] = 30
                                        mem[_19160 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20702 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20702] = 30
                                        mem[_20702 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _24851 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24851] = 30
                                        mem[_24851 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg3, arg1, arg2);
                                        _28739 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28739] = 40
                                        mem[_28739 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28739 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and t / s > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * t / s / arg3 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19865 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19865] = 30
                                        mem[_19865 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * t / s < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22220 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22220] = 30
                                        mem[_22220 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * t / s
                                        if stor1[arg2] > !(arg3 * t / s):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                        _26166 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26166] = 30
                                        mem[_26166 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg3, arg1, arg2);
                                        _30698 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30698] = 40
                                        mem[_30698 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30698 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 / 100 and 15 > -1 / arg3 / 100:
                                    revert with 0, 17
                                if not arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 / arg3 / 100 != 15:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 > arg3:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 < 15 * arg3 / 100:
                                    revert with 0, 17
                                idx = 0
                                s = 100000000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _18082 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18082] = 26
                                        mem[_18082 + 32] = 'SafeMath: division by zero'
                                        if not arg3:
                                            if not 15 * arg3 / 100:
                                                _18817 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18817] = 30
                                                mem[_18817 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _19531 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_19531] = 30
                                                mem[_19531 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(arg1)]:
                                                    _19862 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _19862 + 68] = mem[idx + _19531 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_19862 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _19862 + -mem[64] + 100
                                                if stor1[address(arg1)] < 0:
                                                    revert with 0, 17
                                                if stor1[arg2] > -1:
                                                    revert with 0, 17
                                                if stor1[arg2] < stor1[arg2]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg2
                                                mem[32] = 1
                                                stor1[address(arg2)] = stor1[arg2]
                                                _23253 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_23253] = 30
                                                mem[_23253 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _23603 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _23603 + 68] = mem[idx + _23253 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_23603 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _23603 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(15 * arg3 / 100):
                                                    revert with 0, 17
                                                if totalFees + (15 * arg3 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 15 * arg3 / 100
                                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                                _27265 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_27265] = 40
                                                mem[_27265 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                mem[32] = sha3(address(arg1), 3)
                                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                                    if allowance[address(arg1)][msg.sender] < arg3:
                                                        revert with 0, 17
                                                    if not arg1:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                                    return 1
                                                _27725 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                idx = 0
                                                while idx < 40:
                                                    mem[idx + _27725 + 68] = mem[idx + _27265 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_27725 + 108] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _27725 + -mem[64] + 132
                                            if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                                revert with 0, 17
                                            if not 15 * arg3 / 100:
                                                revert with 0, 18
                                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _19157 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19157] = 30
                                            mem[_19157 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                                _19342 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _19342 + 68] = mem[idx + _19157 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19342 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19342 + -mem[64] + 100
                                            if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _20698 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20698] = 30
                                            mem[_20698 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(arg1)]:
                                                _21219 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _21219 + 68] = mem[idx + _20698 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_21219 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _21219 + -mem[64] + 100
                                            if stor1[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                            _24843 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24843] = 30
                                            mem[_24843 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                                _25158 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _25158 + 68] = mem[idx + _24843 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_25158 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _25158 + -mem[64] + 100
                                            if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _28734 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28734] = 40
                                            mem[_28734 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            mem[32] = sha3(address(arg1), 3)
                                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                                if allowance[address(arg1)][msg.sender] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                                return 1
                                            _29290 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _29290 + 68] = mem[idx + _28734 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29290 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _29290 + -mem[64] + 132
                                        if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 15 * arg3 / 100:
                                            _19156 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19156] = 30
                                            mem[_19156 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg3 * stor6 / 100000000 * 10^18:
                                                _19341 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _19341 + 68] = mem[idx + _19156 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19341 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19341 + -mem[64] + 100
                                            if arg3 * stor6 / 100000000 * 10^18 < 0:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _20697 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20697] = 30
                                            mem[_20697 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                                _21218 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _21218 + 68] = mem[idx + _20697 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_21218 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _21218 + -mem[64] + 100
                                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                            if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                            _24842 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24842] = 30
                                            mem[_24842 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _25157 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _25157 + 68] = mem[idx + _24842 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_25157 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _25157 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _28731 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28731] = 40
                                            mem[_28731 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            mem[32] = sha3(address(arg1), 3)
                                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                                if allowance[address(arg1)][msg.sender] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                                return 1
                                            _29289 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _29289 + 68] = mem[idx + _28731 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29289 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _29289 + -mem[64] + 132
                                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19861 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19861] = 30
                                        mem[_19861 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                            _20187 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _20187 + 68] = mem[idx + _19861 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_20187 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _20187 + -mem[64] + 100
                                        if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22217 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22217] = 30
                                        mem[_22217 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            _22915 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _22915 + 68] = mem[idx + _22217 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_22915 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _22915 + -mem[64] + 100
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                        _26162 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26162] = 30
                                        mem[_26162 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            _26610 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _26610 + 68] = mem[idx + _26162 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26610 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _26610 + -mem[64] + 100
                                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30692 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30692] = 40
                                        mem[_30692 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _31290 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _31290 + 68] = mem[idx + _30692 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31290 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _31290 + -mem[64] + 132
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _18194 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18194] = 30
                                        mem[_18194 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _18232 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18232 + 68] = mem[idx + _18194 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18232 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18232 + -mem[64] + 100
                                        if t < stor1[stor5[idx]]:
                                            revert with 0, 17
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _18585 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18585] = 30
                                        mem[_18585 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            if s < stor2[stor5[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _18645 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18645 + 68] = mem[idx + _18585 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18645 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18645 + -mem[64] + 100
                                    _18195 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18195] = 26
                                    mem[_18195 + 32] = 'SafeMath: division by zero'
                                    if not arg3:
                                        if not 15 * arg3 / 100:
                                            _18945 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18945] = 30
                                            mem[_18945 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _19864 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19864] = 30
                                            mem[_19864 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(arg1)]:
                                                _20191 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _20191 + 68] = mem[idx + _19864 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_20191 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _20191 + -mem[64] + 100
                                            if stor1[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor1[arg2] > -1:
                                                revert with 0, 17
                                            if stor1[arg2] < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2]
                                            _23605 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23605] = 30
                                            mem[_23605 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _24269 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _24269 + 68] = mem[idx + _23605 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_24269 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _24269 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _27727 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27727] = 40
                                            mem[_27727 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            mem[32] = sha3(address(arg1), 3)
                                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                                if allowance[address(arg1)][msg.sender] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                                return 1
                                            _28263 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _28263 + 68] = mem[idx + _27727 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_28263 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _28263 + -mem[64] + 132
                                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19344 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19344] = 30
                                        mem[_19344 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _19533 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19533 + 68] = mem[idx + _19344 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19533 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19533 + -mem[64] + 100
                                        if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _21222 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21222] = 30
                                        mem[_21222 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _21749 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21749 + 68] = mem[idx + _21222 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21749 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21749 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                        _25161 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25161] = 30
                                        mem[_25161 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            _25749 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _25749 + 68] = mem[idx + _25161 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25749 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _25749 + -mem[64] + 100
                                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _29296 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_29296] = 40
                                        mem[_29296 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _29993 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29993 + 68] = mem[idx + _29296 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29993 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29993 + -mem[64] + 132
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg3 / 100:
                                        _19343 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19343] = 30
                                        mem[_19343 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                                            _19532 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19532 + 68] = mem[idx + _19343 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19532 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19532 + -mem[64] + 100
                                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _21221 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21221] = 30
                                        mem[_21221 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            _21748 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21748 + 68] = mem[idx + _21221 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21748 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21748 + -mem[64] + 100
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                        _25160 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25160] = 30
                                        mem[_25160 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _25748 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _25748 + 68] = mem[idx + _25160 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25748 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _25748 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _29293 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_29293] = 40
                                        mem[_29293 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _29992 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29992 + 68] = mem[idx + _29293 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29992 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29992 + -mem[64] + 132
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20190 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20190] = 30
                                    mem[_20190 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                        _20699 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20699 + 68] = mem[idx + _20190 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20699 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20699 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22918 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22918] = 30
                                    mem[_22918 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _23412 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _23412 + 68] = mem[idx + _22918 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23412 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23412 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _26614 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26614] = 30
                                    mem[_26614 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        _27034 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _27034 + 68] = mem[idx + _26614 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27034 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _27034 + -mem[64] + 100
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _31295 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_31295] = 40
                                    mem[_31295 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _32295 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _32295 + 68] = mem[idx + _31295 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_32295 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _32295 + -mem[64] + 132
                                _17916 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17916] = 26
                                mem[_17916 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 100000000 * 10^18:
                                    _18315 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18315] = 26
                                    mem[_18315 + 32] = 'SafeMath: division by zero'
                                    if not arg3:
                                        if not 15 * arg3 / 100:
                                            _19155 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19155] = 30
                                            mem[_19155 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _20696 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20696] = 30
                                            mem[_20696 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor1[arg2] > -1:
                                                revert with 0, 17
                                            if stor1[arg2] < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2]
                                            _24841 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24841] = 30
                                            mem[_24841 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _28728 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28728] = 40
                                            mem[_28728 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28728 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                        else:
                                            if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                                revert with 0, 17
                                            if not 15 * arg3 / 100:
                                                revert with 0, 18
                                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _19860 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19860] = 30
                                            mem[_19860 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _22216 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22216] = 30
                                            mem[_22216 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                            _26161 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26161] = 30
                                            mem[_26161 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _30689 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_30689] = 40
                                            mem[_30689 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30689 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 15 * arg3 / 100:
                                            _19859 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19859] = 30
                                            mem[_19859 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg3 * stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg3 * stor6 / 100000000 * 10^18 < 0:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _22215 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22215] = 30
                                            mem[_22215 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                            if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                            _26160 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26160] = 30
                                            mem[_26160 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _30686 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_30686] = 40
                                            mem[_30686 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30686 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                        else:
                                            if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                                revert with 0, 17
                                            if not 15 * arg3 / 100:
                                                revert with 0, 18
                                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _21216 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21216] = 30
                                            mem[_21216 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _23780 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23780] = 30
                                            mem[_23780 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                            if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                                revert with 0, 17
                                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                            _27422 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_27422] = 30
                                            mem[_27422 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _33034 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_33034] = 40
                                            mem[_33034 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_33034 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    _18314 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18314] = 26
                                    mem[_18314 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        if not 15 * arg3 / 100:
                                            _19153 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19153] = 30
                                            mem[_19153 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _20694 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20694] = 30
                                            mem[_20694 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor1[arg2] > -1:
                                                revert with 0, 17
                                            if stor1[arg2] < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2]
                                            _24839 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24839] = 30
                                            mem[_24839 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _28724 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28724] = 40
                                            mem[_28724 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28724 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                        else:
                                            if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                                revert with 0, 17
                                            if not 15 * arg3 / 100:
                                                revert with 0, 18
                                            if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _19858 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19858] = 30
                                            mem[_19858 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg3 / 100 * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if 0 < 15 * arg3 / 100 * t / s:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _22214 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22214] = 30
                                            mem[_22214 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor1[arg2] > !(-15 * arg3 / 100 * t / s):
                                                revert with 0, 17
                                            if stor1[arg2] - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * t / s)
                                            _26159 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26159] = 30
                                            mem[_26159 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg3 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 15 * arg3 / 100 * t / s:
                                                revert with 0, 17
                                            stor6 += -15 * arg3 / 100 * t / s
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _30683 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_30683] = 40
                                            mem[_30683 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30683 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and t / s > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * t / s / arg3 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 15 * arg3 / 100:
                                            _19857 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19857] = 30
                                            mem[_19857 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg3 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg3 * t / s < 0:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _22213 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22213] = 30
                                            mem[_22213 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * t / s > stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(arg1)] < arg3 * t / s:
                                                revert with 0, 17
                                            stor1[address(arg1)] += -1 * arg3 * t / s
                                            if stor1[arg2] > !(arg3 * t / s):
                                                revert with 0, 17
                                            if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                            _26158 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26158] = 30
                                            mem[_26158 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _30680 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_30680] = 40
                                            mem[_30680 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30680 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                        else:
                                            if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                                revert with 0, 17
                                            if not 15 * arg3 / 100:
                                                revert with 0, 18
                                            if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _21214 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21214] = 30
                                            mem[_21214 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg3 / 100 * t / s > arg3 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg3 * t / s < 15 * arg3 / 100 * t / s:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _23778 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23778] = 30
                                            mem[_23778 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * t / s > stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(arg1)] < arg3 * t / s:
                                                revert with 0, 17
                                            stor1[address(arg1)] += -1 * arg3 * t / s
                                            if stor1[arg2] > !((arg3 * t / s) - (15 * arg3 / 100 * t / s)):
                                                revert with 0, 17
                                            if stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s)
                                            _27420 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_27420] = 30
                                            mem[_27420 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg3 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 15 * arg3 / 100 * t / s:
                                                revert with 0, 17
                                            stor6 += -15 * arg3 / 100 * t / s
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _33030 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_33030] = 40
                                            mem[_33030 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_33030 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                        else:
                            if not arg3 / 100:
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 0 > arg3:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 < 0:
                                    revert with 0, 17
                                idx = 0
                                s = 100000000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _18085 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18085] = 26
                                        mem[_18085 + 32] = 'SafeMath: division by zero'
                                        if not arg3:
                                            _18826 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18826] = 30
                                            mem[_18826 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _19542 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19542] = 30
                                            mem[_19542 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(arg1)]:
                                                _19879 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _19879 + 68] = mem[idx + _19542 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19879 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19879 + -mem[64] + 100
                                            if stor1[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor1[arg2] > -1:
                                                revert with 0, 17
                                            if stor1[arg2] < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2]
                                            _23288 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23288] = 30
                                            mem[_23288 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _23622 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _23622 + 68] = mem[idx + _23288 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_23622 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _23622 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > -1:
                                                revert with 0, 17
                                            if totalFees < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            emit Transfer(arg3, arg1, arg2);
                                            _27288 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27288] = 40
                                            mem[_27288 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            mem[32] = sha3(address(arg1), 3)
                                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                                if allowance[address(arg1)][msg.sender] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                                return 1
                                            _27758 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _27758 + 68] = mem[idx + _27288 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_27758 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _27758 + -mem[64] + 132
                                        if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19175 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19175] = 30
                                        mem[_19175 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                                            _19351 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19351 + 68] = mem[idx + _19175 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19351 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19351 + -mem[64] + 100
                                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20717 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20717] = 30
                                        mem[_20717 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            _21239 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21239 + 68] = mem[idx + _20717 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21239 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21239 + -mem[64] + 100
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                        _24871 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24871] = 30
                                        mem[_24871 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _25178 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _25178 + 68] = mem[idx + _24871 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25178 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _25178 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg3, arg1, arg2);
                                        _28771 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28771] = 40
                                        mem[_28771 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _29332 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _29332 + 68] = mem[idx + _28771 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_29332 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _29332 + -mem[64] + 132
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _18200 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18200] = 30
                                        mem[_18200 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _18235 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18235 + 68] = mem[idx + _18200 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18235 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18235 + -mem[64] + 100
                                        if t < stor1[stor5[idx]]:
                                            revert with 0, 17
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _18591 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18591] = 30
                                        mem[_18591 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            if s < stor2[stor5[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _18651 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18651 + 68] = mem[idx + _18591 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18651 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18651 + -mem[64] + 100
                                    _18201 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18201] = 26
                                    mem[_18201 + 32] = 'SafeMath: division by zero'
                                    if not arg3:
                                        _18951 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18951] = 30
                                        mem[_18951 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _19880 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19880] = 30
                                        mem[_19880 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _20208 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _20208 + 68] = mem[idx + _19880 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_20208 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _20208 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _23623 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_23623] = 30
                                        mem[_23623 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _24320 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _24320 + 68] = mem[idx + _23623 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_24320 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _24320 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg3, arg1, arg2);
                                        _27759 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_27759] = 40
                                        mem[_27759 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _28283 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _28283 + 68] = mem[idx + _27759 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_28283 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _28283 + -mem[64] + 132
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _19352 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_19352] = 30
                                    mem[_19352 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg3 * stor6 / 100000000 * 10^18:
                                        _19543 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _19543 + 68] = mem[idx + _19352 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_19543 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _19543 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 0:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _21241 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_21241] = 30
                                    mem[_21241 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _21767 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _21767 + 68] = mem[idx + _21241 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_21767 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _21767 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                    _25180 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_25180] = 30
                                    mem[_25180 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > stor6:
                                        _25780 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _25780 + 68] = mem[idx + _25180 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_25780 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _25780 + -mem[64] + 100
                                    if stor6 < 0:
                                        revert with 0, 17
                                    if totalFees > -1:
                                        revert with 0, 17
                                    if totalFees < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    emit Transfer(arg3, arg1, arg2);
                                    _29335 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_29335] = 40
                                    mem[_29335 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _30016 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _30016 + 68] = mem[idx + _29335 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_30016 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _30016 + -mem[64] + 132
                                _17925 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17925] = 26
                                mem[_17925 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 100000000 * 10^18:
                                    _18321 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18321] = 26
                                    mem[_18321 + 32] = 'SafeMath: division by zero'
                                    if not arg3:
                                        _19174 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19174] = 30
                                        mem[_19174 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20716 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20716] = 30
                                        mem[_20716 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _24870 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24870] = 30
                                        mem[_24870 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg3, arg1, arg2);
                                        _28768 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28768] = 40
                                        mem[_28768 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28768 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19878 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19878] = 30
                                        mem[_19878 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22231 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22231] = 30
                                        mem[_22231 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                        _26178 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26178] = 30
                                        mem[_26178 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg3, arg1, arg2);
                                        _30727 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30727] = 40
                                        mem[_30727 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30727 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    _18320 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18320] = 26
                                    mem[_18320 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        _19172 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19172] = 30
                                        mem[_19172 + 32] = 'SafeMath: subtraction overflow'
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _20715 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_20715] = 30
                                        mem[_20715 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > -1:
                                            revert with 0, 17
                                        if stor1[arg2] < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2]
                                        _24869 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_24869] = 30
                                        mem[_24869 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg3, arg1, arg2);
                                        _28765 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_28765] = 40
                                        mem[_28765 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28765 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and t / s > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * t / s / arg3 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19877 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19877] = 30
                                        mem[_19877 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * t / s:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if arg3 * t / s < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22230 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22230] = 30
                                        mem[_22230 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * t / s > stor1[address(arg1)]:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor1[address(arg1)] < arg3 * t / s:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * t / s
                                        if stor1[arg2] > !(arg3 * t / s):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                        _26177 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26177] = 30
                                        mem[_26177 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > -1:
                                            revert with 0, 17
                                        if totalFees < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        emit Transfer(arg3, arg1, arg2);
                                        _30724 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30724] = 40
                                        mem[_30724 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        if arg3 > allowance[address(arg1)][msg.sender]:
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30724 + 72 len 24]
                                            revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                            else:
                                if arg3 / 100 and 15 > -1 / arg3 / 100:
                                    revert with 0, 17
                                if not arg3 / 100:
                                    revert with 0, 18
                                if 15 * arg3 / 100 / arg3 / 100 != 15:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                mem[64] = 224
                                mem[160] = 30
                                mem[192] = 'SafeMath: subtraction overflow'
                                if 15 * arg3 / 100 > arg3:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg3 < 15 * arg3 / 100:
                                    revert with 0, 17
                                idx = 0
                                s = 100000000 * 10^18
                                t = stor6
                                while idx < stor5.length:
                                    mem[0] = stor5[idx]
                                    mem[32] = 1
                                    if stor1[stor5[idx]] > t:
                                        _18084 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18084] = 26
                                        mem[_18084 + 32] = 'SafeMath: division by zero'
                                        if not arg3:
                                            if not 15 * arg3 / 100:
                                                _18823 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_18823] = 30
                                                mem[_18823 + 32] = 'SafeMath: subtraction overflow'
                                                mem[0] = arg1
                                                mem[32] = 1
                                                _19539 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_19539] = 30
                                                mem[_19539 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor1[address(arg1)]:
                                                    _19874 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _19874 + 68] = mem[idx + _19539 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_19874 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _19874 + -mem[64] + 100
                                                if stor1[address(arg1)] < 0:
                                                    revert with 0, 17
                                                if stor1[arg2] > -1:
                                                    revert with 0, 17
                                                if stor1[arg2] < stor1[arg2]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                mem[0] = arg2
                                                mem[32] = 1
                                                stor1[address(arg2)] = stor1[arg2]
                                                _23277 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_23277] = 30
                                                mem[_23277 + 32] = 'SafeMath: subtraction overflow'
                                                if 0 > stor6:
                                                    _23617 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 30
                                                    idx = 0
                                                    while idx < 30:
                                                        mem[idx + _23617 + 68] = mem[idx + _23277 + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_23617 + 98] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _23617 + -mem[64] + 100
                                                if stor6 < 0:
                                                    revert with 0, 17
                                                if totalFees > !(15 * arg3 / 100):
                                                    revert with 0, 17
                                                if totalFees + (15 * arg3 / 100) < totalFees:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalFees += 15 * arg3 / 100
                                                emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                                _27281 = mem[64]
                                                mem[64] = mem[64] + 96
                                                mem[_27281] = 40
                                                mem[_27281 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                                mem[32] = sha3(address(arg1), 3)
                                                if arg3 <= allowance[address(arg1)][msg.sender]:
                                                    if allowance[address(arg1)][msg.sender] < arg3:
                                                        revert with 0, 17
                                                    if not arg1:
                                                        revert with 0, 'ERC20: approve from the zero address'
                                                    if not msg.sender:
                                                        revert with 0, 'ERC20: approve to the zero address'
                                                    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                                    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                                    return 1
                                                _27748 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                idx = 0
                                                while idx < 40:
                                                    mem[idx + _27748 + 68] = mem[idx + _27281 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_27748 + 108] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _27748 + -mem[64] + 132
                                            if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                                revert with 0, 17
                                            if not 15 * arg3 / 100:
                                                revert with 0, 18
                                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _19169 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19169] = 30
                                            mem[_19169 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                                _19348 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _19348 + 68] = mem[idx + _19169 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19348 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19348 + -mem[64] + 100
                                            if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _20711 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20711] = 30
                                            mem[_20711 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(arg1)]:
                                                _21233 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _21233 + 68] = mem[idx + _20711 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_21233 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _21233 + -mem[64] + 100
                                            if stor1[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                            _24861 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24861] = 30
                                            mem[_24861 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                                _25172 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _25172 + 68] = mem[idx + _24861 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_25172 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _25172 + -mem[64] + 100
                                            if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _28760 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28760] = 40
                                            mem[_28760 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            mem[32] = sha3(address(arg1), 3)
                                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                                if allowance[address(arg1)][msg.sender] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                                return 1
                                            _29319 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _29319 + 68] = mem[idx + _28760 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29319 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _29319 + -mem[64] + 132
                                        if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 15 * arg3 / 100:
                                            _19168 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19168] = 30
                                            mem[_19168 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg3 * stor6 / 100000000 * 10^18:
                                                _19347 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _19347 + 68] = mem[idx + _19168 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_19347 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _19347 + -mem[64] + 100
                                            if arg3 * stor6 / 100000000 * 10^18 < 0:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _20710 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20710] = 30
                                            mem[_20710 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                                _21232 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _21232 + 68] = mem[idx + _20710 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_21232 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _21232 + -mem[64] + 100
                                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                            if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                            _24860 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24860] = 30
                                            mem[_24860 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _25171 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _25171 + 68] = mem[idx + _24860 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_25171 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _25171 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _28757 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28757] = 40
                                            mem[_28757 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            mem[32] = sha3(address(arg1), 3)
                                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                                if allowance[address(arg1)][msg.sender] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                                return 1
                                            _29318 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _29318 + 68] = mem[idx + _28757 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_29318 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _29318 + -mem[64] + 132
                                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19873 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19873] = 30
                                        mem[_19873 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                            _20200 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _20200 + 68] = mem[idx + _19873 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_20200 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _20200 + -mem[64] + 100
                                        if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _22227 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_22227] = 30
                                        mem[_22227 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            _22932 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _22932 + 68] = mem[idx + _22227 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_22932 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _22932 + -mem[64] + 100
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                        _26173 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_26173] = 30
                                        mem[_26173 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            _26629 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _26629 + 68] = mem[idx + _26173 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_26629 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _26629 + -mem[64] + 100
                                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _30718 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_30718] = 40
                                        mem[_30718 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _31318 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _31318 + 68] = mem[idx + _30718 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_31318 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _31318 + -mem[64] + 132
                                    if idx >= stor5.length:
                                        revert with 0, 50
                                    mem[0] = stor5[idx]
                                    mem[32] = 2
                                    if stor2[stor5[idx]] <= s:
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 1
                                        _18198 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18198] = 30
                                        mem[_18198 + 32] = 'SafeMath: subtraction overflow'
                                        if stor1[stor5[idx]] > t:
                                            _18234 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _18234 + 68] = mem[idx + _18198 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18234 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18234 + -mem[64] + 100
                                        if t < stor1[stor5[idx]]:
                                            revert with 0, 17
                                        if idx >= stor5.length:
                                            revert with 0, 50
                                        mem[0] = stor5[idx]
                                        mem[32] = 2
                                        _18589 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18589] = 30
                                        mem[_18589 + 32] = 'SafeMath: subtraction overflow'
                                        if stor2[stor5[idx]] <= s:
                                            if s < stor2[stor5[idx]]:
                                                revert with 0, 17
                                            if idx == -1:
                                                revert with 0, 17
                                            idx = idx + 1
                                            s = s - stor2[stor5[idx]]
                                            t = t - stor1[stor5[idx]]
                                            continue 
                                        _18649 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _18649 + 68] = mem[idx + _18589 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18649 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18649 + -mem[64] + 100
                                    _18199 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18199] = 26
                                    mem[_18199 + 32] = 'SafeMath: division by zero'
                                    if not arg3:
                                        if not 15 * arg3 / 100:
                                            _18949 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_18949] = 30
                                            mem[_18949 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _19876 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19876] = 30
                                            mem[_19876 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(arg1)]:
                                                _20204 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _20204 + 68] = mem[idx + _19876 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_20204 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _20204 + -mem[64] + 100
                                            if stor1[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor1[arg2] > -1:
                                                revert with 0, 17
                                            if stor1[arg2] < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2]
                                            _23619 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23619] = 30
                                            mem[_23619 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                _24307 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 30
                                                idx = 0
                                                while idx < 30:
                                                    mem[idx + _24307 + 68] = mem[idx + _23619 + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_24307 + 98] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _24307 + -mem[64] + 100
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _27750 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_27750] = 40
                                            mem[_27750 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            mem[32] = sha3(address(arg1), 3)
                                            if arg3 <= allowance[address(arg1)][msg.sender]:
                                                if allowance[address(arg1)][msg.sender] < arg3:
                                                    revert with 0, 17
                                                if not arg1:
                                                    revert with 0, 'ERC20: approve from the zero address'
                                                if not msg.sender:
                                                    revert with 0, 'ERC20: approve to the zero address'
                                                allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                                emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                                return 1
                                            _28278 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 40
                                            idx = 0
                                            while idx < 40:
                                                mem[idx + _28278 + 68] = mem[idx + _27750 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_28278 + 108] = 0
                                            revert with memory
                                              from mem[64]
                                               len _28278 + -mem[64] + 132
                                        if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                            revert with 0, 17
                                        if not 15 * arg3 / 100:
                                            revert with 0, 18
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _19350 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19350] = 30
                                        mem[_19350 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                            _19541 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19541 + 68] = mem[idx + _19350 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19541 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19541 + -mem[64] + 100
                                        if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _21236 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21236] = 30
                                        mem[_21236 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor1[address(arg1)]:
                                            _21763 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21763 + 68] = mem[idx + _21236 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21763 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21763 + -mem[64] + 100
                                        if stor1[address(arg1)] < 0:
                                            revert with 0, 17
                                        if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                        _25175 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25175] = 30
                                        mem[_25175 + 32] = 'SafeMath: subtraction overflow'
                                        if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                            _25774 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _25774 + 68] = mem[idx + _25175 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25774 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _25774 + -mem[64] + 100
                                        if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _29325 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_29325] = 40
                                        mem[_29325 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _30010 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _30010 + 68] = mem[idx + _29325 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_30010 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _30010 + -mem[64] + 132
                                    if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                        revert with 0, 17
                                    if not arg3:
                                        revert with 0, 18
                                    if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not 15 * arg3 / 100:
                                        _19349 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_19349] = 30
                                        mem[_19349 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > arg3 * stor6 / 100000000 * 10^18:
                                            _19540 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _19540 + 68] = mem[idx + _19349 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_19540 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _19540 + -mem[64] + 100
                                        if arg3 * stor6 / 100000000 * 10^18 < 0:
                                            revert with 0, 17
                                        mem[0] = arg1
                                        mem[32] = 1
                                        _21235 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_21235] = 30
                                        mem[_21235 + 32] = 'SafeMath: subtraction overflow'
                                        if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                            _21762 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _21762 + 68] = mem[idx + _21235 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_21762 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _21762 + -mem[64] + 100
                                        if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                            revert with 0, 17
                                        stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                        if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                            revert with 0, 17
                                        if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[0] = arg2
                                        mem[32] = 1
                                        stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                        _25174 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_25174] = 30
                                        mem[_25174 + 32] = 'SafeMath: subtraction overflow'
                                        if 0 > stor6:
                                            _25773 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 30
                                            idx = 0
                                            while idx < 30:
                                                mem[idx + _25773 + 68] = mem[idx + _25174 + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_25773 + 98] = 0
                                            revert with memory
                                              from mem[64]
                                               len _25773 + -mem[64] + 100
                                        if stor6 < 0:
                                            revert with 0, 17
                                        if totalFees > !(15 * arg3 / 100):
                                            revert with 0, 17
                                        if totalFees + (15 * arg3 / 100) < totalFees:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalFees += 15 * arg3 / 100
                                        emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                        _29322 = mem[64]
                                        mem[64] = mem[64] + 96
                                        mem[_29322] = 40
                                        mem[_29322 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                        mem[32] = sha3(address(arg1), 3)
                                        if arg3 <= allowance[address(arg1)][msg.sender]:
                                            if allowance[address(arg1)][msg.sender] < arg3:
                                                revert with 0, 17
                                            if not arg1:
                                                revert with 0, 'ERC20: approve from the zero address'
                                            if not msg.sender:
                                                revert with 0, 'ERC20: approve to the zero address'
                                            allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                            emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                            return 1
                                        _30009 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 40
                                        idx = 0
                                        while idx < 40:
                                            mem[idx + _30009 + 68] = mem[idx + _29322 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_30009 + 108] = 0
                                        revert with memory
                                          from mem[64]
                                           len _30009 + -mem[64] + 132
                                    if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                        revert with 0, 17
                                    if not 15 * arg3 / 100:
                                        revert with 0, 18
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _20203 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_20203] = 30
                                    mem[_20203 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                        _20712 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _20712 + 68] = mem[idx + _20203 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_20712 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _20712 + -mem[64] + 100
                                    if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    mem[0] = arg1
                                    mem[32] = 1
                                    _22935 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_22935] = 30
                                    mem[_22935 + 32] = 'SafeMath: subtraction overflow'
                                    if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                        _23418 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _23418 + 68] = mem[idx + _22935 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_23418 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _23418 + -mem[64] + 100
                                    if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                    if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                        revert with 0, 17
                                    if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[0] = arg2
                                    mem[32] = 1
                                    stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                    _26633 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_26633] = 30
                                    mem[_26633 + 32] = 'SafeMath: subtraction overflow'
                                    if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                        _27044 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _27044 + 68] = mem[idx + _26633 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_27044 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _27044 + -mem[64] + 100
                                    if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                        revert with 0, 17
                                    stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                    if totalFees > !(15 * arg3 / 100):
                                        revert with 0, 17
                                    if totalFees + (15 * arg3 / 100) < totalFees:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalFees += 15 * arg3 / 100
                                    emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                    _31323 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_31323] = 40
                                    mem[_31323 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                    mem[32] = sha3(address(arg1), 3)
                                    if arg3 <= allowance[address(arg1)][msg.sender]:
                                        if allowance[address(arg1)][msg.sender] < arg3:
                                            revert with 0, 17
                                        if not arg1:
                                            revert with 0, 'ERC20: approve from the zero address'
                                        if not msg.sender:
                                            revert with 0, 'ERC20: approve to the zero address'
                                        allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
                                        emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
                                        return 1
                                    _32311 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 40
                                    idx = 0
                                    while idx < 40:
                                        mem[idx + _32311 + 68] = mem[idx + _31323 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_32311 + 108] = 0
                                    revert with memory
                                      from mem[64]
                                       len _32311 + -mem[64] + 132
                                _17922 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17922] = 26
                                mem[_17922 + 32] = 'SafeMath: division by zero'
                                if t < stor6 / 100000000 * 10^18:
                                    _18319 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18319] = 26
                                    mem[_18319 + 32] = 'SafeMath: division by zero'
                                    if not arg3:
                                        if not 15 * arg3 / 100:
                                            _19167 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19167] = 30
                                            mem[_19167 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _20709 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20709] = 30
                                            mem[_20709 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor1[arg2] > -1:
                                                revert with 0, 17
                                            if stor1[arg2] < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2]
                                            _24859 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24859] = 30
                                            mem[_24859 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _28754 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28754] = 40
                                            mem[_28754 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28754 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                        else:
                                            if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                                revert with 0, 17
                                            if not 15 * arg3 / 100:
                                                revert with 0, 18
                                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _19872 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19872] = 30
                                            mem[_19872 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if 0 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _22226 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22226] = 30
                                            mem[_22226 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor1[arg2] > !(-15 * arg3 / 100 * stor6 / 100000000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                            _26172 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26172] = 30
                                            mem[_26172 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _30715 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_30715] = 40
                                            mem[_30715 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30715 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and stor6 / 100000000 * 10^18 > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * stor6 / 100000000 * 10^18 / arg3 != stor6 / 100000000 * 10^18:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 15 * arg3 / 100:
                                            _19871 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19871] = 30
                                            mem[_19871 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg3 * stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg3 * stor6 / 100000000 * 10^18 < 0:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _22225 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22225] = 30
                                            mem[_22225 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                            if stor1[arg2] > !(arg3 * stor6 / 100000000 * 10^18):
                                                revert with 0, 17
                                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18)
                                            _26171 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26171] = 30
                                            mem[_26171 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _30712 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_30712] = 40
                                            mem[_30712 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30712 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                        else:
                                            if 15 * arg3 / 100 and stor6 / 100000000 * 10^18 > -1 / 15 * arg3 / 100:
                                                revert with 0, 17
                                            if not 15 * arg3 / 100:
                                                revert with 0, 18
                                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 / 15 * arg3 / 100 != stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _21230 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21230] = 30
                                            mem[_21230 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > arg3 * stor6 / 100000000 * 10^18:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg3 * stor6 / 100000000 * 10^18 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _23791 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23791] = 30
                                            mem[_23791 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * stor6 / 100000000 * 10^18 > stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(arg1)] < arg3 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor1[address(arg1)] += -1 * arg3 * stor6 / 100000000 * 10^18
                                            if stor1[arg2] > !((arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)):
                                                revert with 0, 17
                                            if stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18) < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2] + (arg3 * stor6 / 100000000 * 10^18) - (15 * arg3 / 100 * stor6 / 100000000 * 10^18)
                                            _27431 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_27431] = 30
                                            mem[_27431 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg3 / 100 * stor6 / 100000000 * 10^18 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 15 * arg3 / 100 * stor6 / 100000000 * 10^18:
                                                revert with 0, 17
                                            stor6 += -15 * arg3 / 100 * stor6 / 100000000 * 10^18
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _33050 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_33050] = 40
                                            mem[_33050 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_33050 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                else:
                                    _18318 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18318] = 26
                                    mem[_18318 + 32] = 'SafeMath: division by zero'
                                    if not s:
                                        revert with 0, 'SafeMath: division by zero', 0
                                    if not arg3:
                                        if not 15 * arg3 / 100:
                                            _19165 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19165] = 30
                                            mem[_19165 + 32] = 'SafeMath: subtraction overflow'
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _20707 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_20707] = 30
                                            mem[_20707 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor1[arg2] > -1:
                                                revert with 0, 17
                                            if stor1[arg2] < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2]
                                            _24857 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_24857] = 30
                                            mem[_24857 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _28750 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_28750] = 40
                                            mem[_28750 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_28750 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                        else:
                                            if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                                revert with 0, 17
                                            if not 15 * arg3 / 100:
                                                revert with 0, 18
                                            if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _19870 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19870] = 30
                                            mem[_19870 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg3 / 100 * t / s > 0:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if 0 < 15 * arg3 / 100 * t / s:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _22224 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22224] = 30
                                            mem[_22224 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(arg1)] < 0:
                                                revert with 0, 17
                                            if stor1[arg2] > !(-15 * arg3 / 100 * t / s):
                                                revert with 0, 17
                                            if stor1[arg2] - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2] - (15 * arg3 / 100 * t / s)
                                            _26170 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26170] = 30
                                            mem[_26170 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg3 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 15 * arg3 / 100 * t / s:
                                                revert with 0, 17
                                            stor6 += -15 * arg3 / 100 * t / s
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _30709 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_30709] = 40
                                            mem[_30709 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30709 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                    else:
                                        if arg3 and t / s > -1 / arg3:
                                            revert with 0, 17
                                        if not arg3:
                                            revert with 0, 18
                                        if arg3 * t / s / arg3 != t / s:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        if not 15 * arg3 / 100:
                                            _19869 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_19869] = 30
                                            mem[_19869 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > arg3 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg3 * t / s < 0:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _22223 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_22223] = 30
                                            mem[_22223 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * t / s > stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(arg1)] < arg3 * t / s:
                                                revert with 0, 17
                                            stor1[address(arg1)] += -1 * arg3 * t / s
                                            if stor1[arg2] > !(arg3 * t / s):
                                                revert with 0, 17
                                            if stor1[arg2] + (arg3 * t / s) < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s)
                                            _26169 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_26169] = 30
                                            mem[_26169 + 32] = 'SafeMath: subtraction overflow'
                                            if 0 > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 0:
                                                revert with 0, 17
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _30706 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_30706] = 40
                                            mem[_30706 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_30706 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
                                        else:
                                            if 15 * arg3 / 100 and t / s > -1 / 15 * arg3 / 100:
                                                revert with 0, 17
                                            if not 15 * arg3 / 100:
                                                revert with 0, 18
                                            if 15 * arg3 / 100 * t / s / 15 * arg3 / 100 != t / s:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _21228 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_21228] = 30
                                            mem[_21228 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg3 / 100 * t / s > arg3 * t / s:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if arg3 * t / s < 15 * arg3 / 100 * t / s:
                                                revert with 0, 17
                                            mem[0] = arg1
                                            mem[32] = 1
                                            _23789 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_23789] = 30
                                            mem[_23789 + 32] = 'SafeMath: subtraction overflow'
                                            if arg3 * t / s > stor1[address(arg1)]:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor1[address(arg1)] < arg3 * t / s:
                                                revert with 0, 17
                                            stor1[address(arg1)] += -1 * arg3 * t / s
                                            if stor1[arg2] > !((arg3 * t / s) - (15 * arg3 / 100 * t / s)):
                                                revert with 0, 17
                                            if stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s) < stor1[arg2]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[0] = arg2
                                            mem[32] = 1
                                            stor1[address(arg2)] = stor1[arg2] + (arg3 * t / s) - (15 * arg3 / 100 * t / s)
                                            _27429 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_27429] = 30
                                            mem[_27429 + 32] = 'SafeMath: subtraction overflow'
                                            if 15 * arg3 / 100 * t / s > stor6:
                                                revert with 0, 'SafeMath: subtraction overflow', 0
                                            if stor6 < 15 * arg3 / 100 * t / s:
                                                revert with 0, 17
                                            stor6 += -15 * arg3 / 100 * t / s
                                            if totalFees > !(15 * arg3 / 100):
                                                revert with 0, 17
                                            if totalFees + (15 * arg3 / 100) < totalFees:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalFees += 15 * arg3 / 100
                                            emit Transfer((arg3 - (15 * arg3 / 100)), arg1, arg2);
                                            _33046 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_33046] = 40
                                            mem[_33046 + 32 len 40] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63
                                            if arg3 > allowance[address(arg1)][msg.sender]:
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 40
                                                mem[mem[64] + 68 len 64] = 0xfe45524332303a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63, mem[_33046 + 72 len 24]
                                                revert with 0, 32, 40, mem[mem[64] + 68 len 40], 0
    ('le', ('param', 'arg3'), ('stor', ('map', 'msg.sender', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'allowance', 3)))))
    if allowance[address(arg1)][msg.sender] < arg3:
        revert with 0, 17
    if not arg1:
        revert with 0, 'ERC20: approve from the zero address'
    if not msg.sender:
        revert with 0, 'ERC20: approve to the zero address'
    allowance[address(arg1)][address(msg.sender)] = allowance[address(arg1)][msg.sender] - arg3
    emit Approval((allowance[address(arg1)][msg.sender] - arg3), arg1, msg.sender);
    return 1
}



}

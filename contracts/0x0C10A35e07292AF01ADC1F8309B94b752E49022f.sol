contract main {




// =====================  Runtime code  =====================


const decimals = 18

const DOMAIN_TYPEHASH = 0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f

const PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9

const VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6


array of struct name;
array of uint256 symbol;
uint256 totalSupply;
mapping of uint256 allowance;
mapping of uint256 balanceOf;
mapping of uint256 nonces;
address owner;
uint256 totalDeposits;
address routerAddress;
address depositTokenAddress;
address stor10;
address stor11;
address rewardTokenAddress;
address stakingContractAddress;
uint256 PID;
uint256 MIN_TOKENS_TO_REINVEST;
uint256 REINVEST_REWARD_BIPS;
uint256 ADMIN_FEE_BIPS;
uint8 stor18;
uint256 stor18;
uint256 MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT;

function name() payable {
    return name[0 len name.length].field_0
}

function ADMIN_FEE_BIPS() payable {
    return ADMIN_FEE_BIPS
}

function MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT() payable {
    return MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT
}

function REQUIRE_REINVEST_BEFORE_DEPOSIT() payable {
    return bool(uint8(stor18))
}

function totalSupply() payable {
    return totalSupply
}

function PID() payable {
    return PID
}

function balanceOf(address arg1) payable {
    require calldata.size - 4 >= 32
    return balanceOf[address(arg1)]
}

function totalDeposits() payable {
    return totalDeposits
}

function nonces(address arg1) payable {
    require calldata.size - 4 >= 32
    return nonces[arg1]
}

function REINVEST_REWARD_BIPS() payable {
    return REINVEST_REWARD_BIPS
}

function owner() payable {
    return owner
}

function symbol() payable {
    return symbol[0 len symbol.length]
}

function MIN_TOKENS_TO_REINVEST() payable {
    return MIN_TOKENS_TO_REINVEST
}

function depositToken() payable {
    return depositTokenAddress
}

function allowance(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    return allowance[address(arg1)][address(arg2)]
}

function stakingContract() payable {
    return stakingContractAddress
}

function rewardToken() payable {
    return rewardTokenAddress
}

function router() payable {
    return routerAddress
}

function _fallback() payable {
    revert
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function updateMinTokensToReinvest(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit UpdateMinTokensToReinvest(MIN_TOKENS_TO_REINVEST, arg1);
    MIN_TOKENS_TO_REINVEST = arg1
}

function updateRequireReinvestBeforeDeposit() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    uint256(stor18) = not bool(uint8(stor18)) or Mask(248, 8, uint256(stor18))
    emit UpdateRequireReinvestBeforeDeposit(bool(uint8(stor18)));
}

function updateMinTokensToReinvestBeforeDeposit(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit UpdateMinTokensToReinvestBeforeDeposit(MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT, arg1);
    MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT = arg1
}

function approve(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if not msg.sender:
        revert with 0, '_approve::owner zero address'
    if not arg1:
        revert with 0, '_approve::spender zero address'
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function emergencyWithdraw() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(stakingContractAddress)
    call stakingContractAddress.emergencyWithdraw(uint256 rg1) with:
         gas gas_remaining wei
        args PID
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    totalDeposits = 0
}

function updateAdminFee(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 + REINVEST_REWARD_BIPS < arg1:
        revert with 0, 'SafeMath: addition overflow'
    if arg1 + REINVEST_REWARD_BIPS > 10000:
        revert with 0, 'admin fee too high'
    emit UpdateAdminFee(ADMIN_FEE_BIPS, arg1);
    ADMIN_FEE_BIPS = arg1
}

function recoverAVAX(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 <= 0:
        revert with 0, 'amount too low'
    call msg.sender with:
       value arg1 wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    emit Recovered(0, arg1);
}

function updateReinvestReward(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 + ADMIN_FEE_BIPS < arg1:
        revert with 0, 'SafeMath: addition overflow'
    if arg1 + ADMIN_FEE_BIPS > 10000:
        revert with 0, 'reinvest reward too high'
    emit UpdateReinvestReward(REINVEST_REWARD_BIPS, arg1);
    REINVEST_REWARD_BIPS = arg1
}

function getDomainSeparator() payable {
    mem[96] = uint256(name.field_0)
    idx = 96
    s = 0
    while name.length + 96 > idx + 32:
        mem[idx + 32] = name[s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    return sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, sha3(mem[96 len name.length]), 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, chainid, this.address)
}

function revokeAllowance(address arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(arg1)
    call arg1.approve(address rg1, uint256 rg2) with:
         gas gas_remaining wei
        args address(arg2), 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0]
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0xfe4f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function recoverERC20(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg2 <= 0:
        revert with 0, 'amount too low'
    if arg1 == depositTokenAddress:
        revert with 0, 'cannot recover deposit token'
    require ext_code.size(arg1)
    call arg1.0xa9059cbb with:
         gas gas_remaining wei
        args msg.sender, arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    emit Recovered(address(arg1), arg2);
}

function checkReward() payable {
    require ext_code.size(stakingContractAddress)
    staticcall stakingContractAddress.pendingOlive(uint256 rg1, address rg2) with:
            gas gas_remaining wei
           args PID, this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(rewardTokenAddress)
    staticcall rewardTokenAddress.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
        revert with 0, 'SafeMath: addition overflow'
    return (2 * ext_call.return_data[0])
}

function transfer(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    52,
                    0x775f7472616e73666572546f6b656e733a2063616e6e6f74207472616e7366657220746f20746865207a65726f20616464726573,
                    mem[216 len 12]
    if arg2 > balanceOf[address(msg.sender)]:
        revert with 0, 
                    32,
                    46,
                    0x655f7472616e73666572546f6b656e733a207472616e7366657220657863656564732066726f6d2062616c616e63,
                    mem[174 len 18],
                    mem[210 len 14]
    balanceOf[address(msg.sender)] -= arg2
    if balanceOf[address(arg1)] + arg2 < balanceOf[address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    balanceOf[address(arg1)] += arg2
    emit Transfer(arg2, msg.sender, arg1);
    return 1
}

function getDepositTokensForShares(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if not totalSupply:
        return 0
    require totalSupply
    if totalSupply * totalDeposits / totalSupply != totalDeposits:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if not totalSupply * totalDeposits:
        return 0
    if not arg1:
        if totalSupply <= 0:
            revert with 0, 'SafeMath: division by zero'
        if totalSupply:
            return (0 / totalSupply)
    else:
        if arg1:
            if arg1 * totalDeposits / arg1 != totalDeposits:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalSupply <= 0:
                revert with 0, 'SafeMath: division by zero'
            if totalSupply:
                return (arg1 * totalDeposits / totalSupply)
    revert
}

function getSharesForDepositTokens(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if not totalSupply:
        return arg1
    require totalSupply
    if totalSupply * totalDeposits / totalSupply != totalDeposits:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    if not totalSupply * totalDeposits:
        return arg1
    if not arg1:
        if totalDeposits <= 0:
            revert with 0, 'SafeMath: division by zero'
        if totalDeposits:
            return (0 / totalDeposits)
    else:
        if arg1:
            if arg1 * totalSupply / arg1 != totalSupply:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if totalDeposits <= 0:
                revert with 0, 'SafeMath: division by zero'
            if totalDeposits:
                return (arg1 * totalSupply / totalDeposits)
    revert
}

function setAllowances() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(depositTokenAddress)
    call depositTokenAddress.approve(address rg1, uint256 rg2) with:
         gas gas_remaining wei
        args stakingContractAddress, -1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(rewardTokenAddress)
    call rewardTokenAddress.approve(address rg1, uint256 rg2) with:
         gas gas_remaining wei
        args routerAddress, -1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(stor10)
    call stor10.approve(address rg1, uint256 rg2) with:
         gas gas_remaining wei
        args routerAddress, -1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(stor11)
    call stor11.approve(address rg1, uint256 rg2) with:
         gas gas_remaining wei
        args routerAddress, -1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
}

function estimateReinvestReward() payable {
    require ext_code.size(stakingContractAddress)
    staticcall stakingContractAddress.pendingOlive(uint256 rg1, address rg2) with:
            gas gas_remaining wei
           args PID, this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(rewardTokenAddress)
    staticcall rewardTokenAddress.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
        revert with 0, 'SafeMath: addition overflow'
    if 2 * ext_call.return_data[0] < MIN_TOKENS_TO_REINVEST:
        return 0
    if not uint255(ext_call.return_data[0]):
        return 0
    require 2 * ext_call.return_data[0]
    if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 2 * ext_call.return_data[0] != REINVEST_REWARD_BIPS:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    33,
                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                    mem[197 len 31]
    return ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)
}

function permit(address arg1, address arg2, uint256 arg3, uint256 arg4, uint8 arg5, bytes32 arg6, bytes32 arg7) payable {
    require calldata.size - 4 >= 224
    if arg4 < block.timestamp:
        revert with 0, 'permit::expired'
    nonces[address(arg1)]++
    mem[320] = uint256(name.field_0)
    idx = 320
    s = 0
    while name.length + 320 > idx + 32:
        mem[idx + 32] = name[s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    signer = erecover(sha3(0, sha3(0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f, sha3(mem[320 len name.length]), 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, chainid, this.address), sha3(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9, address(arg1), address(arg2), arg3, nonces[address(arg1)], arg4)), arg5 << 248, arg6, arg7) 
    if not erecover.result:
        revert with ext_call.return_data[0 len return_data.size]
    if not address(signer):
        revert with 0, 
                    32,
                    36,
                    0x73417263683a3a76616c69646174655369673a20696e76616c6964207369676e61747572,
                    Mask(192, 0, arg7),
                    mem[770 len 4]
    if address(signer) != arg1:
        revert with 0, 
                    32,
                    36,
                    0x73417263683a3a76616c69646174655369673a20696e76616c6964207369676e61747572,
                    Mask(192, 0, arg7),
                    mem[770 len 4]
    if not arg1:
        revert with 0, '_approve::owner zero address'
    if not arg2:
        revert with 0, '_approve::spender zero address'
    allowance[address(arg1)][address(arg2)] = arg3
    emit Approval(arg3, arg1, arg2);
}

function transferFrom(address arg1, address arg2, uint256 arg3) payable {
    require calldata.size - 4 >= 96
    if msg.sender == arg1:
        if not arg2:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        52,
                        0x775f7472616e73666572546f6b656e733a2063616e6e6f74207472616e7366657220746f20746865207a65726f20616464726573,
                        mem[216 len 12]
        if arg3 > balanceOf[address(arg1)]:
            revert with 0, 
                        32,
                        46,
                        0x655f7472616e73666572546f6b656e733a207472616e7366657220657863656564732066726f6d2062616c616e63,
                        mem[174 len 18],
                        mem[210 len 14]
    else:
        if allowance[address(arg1)][address(msg.sender)] == -1:
            if not arg2:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            52,
                            0x775f7472616e73666572546f6b656e733a2063616e6e6f74207472616e7366657220746f20746865207a65726f20616464726573,
                            mem[216 len 12]
            if arg3 > balanceOf[address(arg1)]:
                revert with 0, 
                            32,
                            46,
                            0x655f7472616e73666572546f6b656e733a207472616e7366657220657863656564732066726f6d2062616c616e63,
                            mem[174 len 18],
                            mem[210 len 14]
        else:
            if arg3 > allowance[address(arg1)][address(msg.sender)]:
                revert with 0, 
                            32,
                            47,
                            0x737472616e7366657246726f6d3a207472616e7366657220616d6f756e74206578636565647320616c6c6f77616e63,
                            mem[175 len 17],
                            mem[209 len 15]
            allowance[address(arg1)][address(msg.sender)] -= arg3
            emit Approval((allowance[address(arg1)][address(msg.sender)] - arg3), arg1, msg.sender);
            if not arg2:
                revert with 0, 
                            32,
                            52,
                            0x775f7472616e73666572546f6b656e733a2063616e6e6f74207472616e7366657220746f20746865207a65726f20616464726573,
                            mem[312 len 12]
            if arg3 > balanceOf[address(arg1)]:
                revert with 0, 
                            32,
                            46,
                            0x655f7472616e73666572546f6b656e733a207472616e7366657220657863656564732066726f6d2062616c616e63,
                            mem[270 len 18],
                            mem[306 len 14]
    ('le', ('param', 'arg3'), ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg1')), ('name', 'balanceOf', 4))))
    balanceOf[address(arg1)] -= arg3
    if balanceOf[address(arg2)] + arg3 < balanceOf[address(arg2)]:
        revert with 0, 'SafeMath: addition overflow'
    balanceOf[address(arg2)] += arg3
    emit Transfer(arg3, arg1, arg2);
    return 1
}

function withdraw(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if totalSupply:
        require totalSupply
        if totalSupply * totalDeposits / totalSupply != totalDeposits:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if totalSupply * totalDeposits:
            if not arg1:
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalSupply
                if 0 / totalSupply > 0:
                    require ext_code.size(stakingContractAddress)
                    call stakingContractAddress.0x441a3e70 with:
                         gas gas_remaining wei
                        args PID, 0 / totalSupply
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(depositTokenAddress)
                    call depositTokenAddress.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, 0 / totalSupply
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0, 'transfer failed'
                    if arg1 > balanceOf[address(msg.sender)]:
                        revert with 0, 
                                    32,
                                    39,
                                    0x655f6275726e3a206275726e20616d6f756e7420657863656564732066726f6d2062616c616e63,
                                    mem[231 len 25],
                                    mem[281 len 7]
                    balanceOf[address(msg.sender)] -= arg1
                    if arg1 > totalSupply:
                        revert with 0, 
                                    32,
                                    39,
                                    0x655f6275726e3a206275726e20616d6f756e74206578636565647320746f74616c20737570706c,
                                    mem[327 len 25],
                                    mem[377 len 7]
                    totalSupply -= arg1
                    emit Transfer(arg1, msg.sender, 0);
                    if 0 / totalSupply > totalDeposits:
                        revert with 0, 'SafeMath: subtraction underflow'
                    totalDeposits -= 0 / totalSupply
                    emit Withdraw((0 / totalSupply), msg.sender);
            else:
                require arg1
                if arg1 * totalDeposits / arg1 != totalDeposits:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if totalSupply <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalSupply
                if arg1 * totalDeposits / totalSupply > 0:
                    require ext_code.size(stakingContractAddress)
                    call stakingContractAddress.0x441a3e70 with:
                         gas gas_remaining wei
                        args PID, arg1 * totalDeposits / totalSupply
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(depositTokenAddress)
                    call depositTokenAddress.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, arg1 * totalDeposits / totalSupply
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0, 'transfer failed'
                    if arg1 > balanceOf[address(msg.sender)]:
                        revert with 0, 
                                    32,
                                    39,
                                    0x655f6275726e3a206275726e20616d6f756e7420657863656564732066726f6d2062616c616e63,
                                    mem[231 len 25],
                                    mem[281 len 7]
                    balanceOf[address(msg.sender)] -= arg1
                    if arg1 > totalSupply:
                        revert with 0, 
                                    32,
                                    39,
                                    0x655f6275726e3a206275726e20616d6f756e74206578636565647320746f74616c20737570706c,
                                    mem[327 len 25],
                                    mem[377 len 7]
                    totalSupply -= arg1
                    emit Transfer(arg1, msg.sender, 0);
                    if arg1 * totalDeposits / totalSupply > totalDeposits:
                        revert with 0, 'SafeMath: subtraction underflow'
                    totalDeposits -= arg1 * totalDeposits / totalSupply
                    emit Withdraw((arg1 * totalDeposits / totalSupply), msg.sender);
}

function reinvest() payable {
    if msg.sender != tx.origin:
        revert with 0, 'onlyEOA'
    require ext_code.size(stakingContractAddress)
    staticcall stakingContractAddress.pendingOlive(uint256 rg1, address rg2) with:
            gas gas_remaining wei
           args PID, this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(rewardTokenAddress)
    staticcall rewardTokenAddress.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
        revert with 0, 'SafeMath: addition overflow'
    if 2 * ext_call.return_data[0] < MIN_TOKENS_TO_REINVEST:
        revert with 0, 'MIN_TOKENS_TO_REINVEST'
    require ext_code.size(stakingContractAddress)
    call stakingContractAddress.0xe2bbb158 with:
         gas gas_remaining wei
        args PID, 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if not uint255(ext_call.return_data[0]):
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not uint255(ext_call.return_data[0]):
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            mem[224] = 31
            mem[256] = 'SafeMath: subtraction underflow'
            if 0 > 2 * ext_call.return_data[0]:
                revert with 0, 'SafeMath: subtraction underflow'
            mem[288] = 31
            mem[320] = 'SafeMath: subtraction underflow'
            mem[352] = 26
            mem[384] = 'SafeMath: division by zero'
            if uint255(ext_call.return_data[0]) <= 0:
                revert with 0, 'amount too low'
            mem[416] = 2
            mem[448] = rewardTokenAddress
            mem[480] = stor10
            if rewardTokenAddress == stor10:
                mem[512] = 2
                mem[544] = rewardTokenAddress
                mem[576] = stor11
                if rewardTokenAddress == stor11:
                    require ext_code.size(routerAddress)
                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                         gas gas_remaining wei
                        args stor10, stor11, 2 * ext_call.return_data[0], 2 * ext_call.return_data[0], 0, 0, address(this.address), block.timestamp
                else:
                    mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[612] = uint255(ext_call.return_data[0])
                    mem[644] = 64
                    mem[676] = 2
                    mem[708 len 0] = None
                    require ext_code.size(routerAddress)
                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                            gas gas_remaining wei
                           args 2 * ext_call.return_data[0], Array(len=2, data=mem[708 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(return_data.size) + 608
                    require return_data.size >= 32
                    _1923 = mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31
                    require mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 <= 4294967296
                    require mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 32 <= return_data.size
                    require mem[mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * mem[mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 608]) + 32 <= return_data.size
                    mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 608]
                    _1961 = mem[_1923 + 608]
                    mem[ceil32(return_data.size) + 640 len floor32(mem[_1923 + 608])] = mem[_1923 + 640 len floor32(mem[_1923 + 608])]
                    mem[64] = (32 * _1961) + ceil32(return_data.size) + 640
                    require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                    _3143 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                    mem[(32 * _1961) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(32 * _1961) + ceil32(return_data.size) + 644] = uint255(ext_call.return_data[0])
                    mem[(32 * _1961) + ceil32(return_data.size) + 676] = _3143
                    mem[(32 * _1961) + ceil32(return_data.size) + 740] = this.address
                    mem[(32 * _1961) + ceil32(return_data.size) + 772] = block.timestamp
                    mem[(32 * _1961) + ceil32(return_data.size) + 708] = 160
                    mem[(32 * _1961) + ceil32(return_data.size) + 804] = 2
                    mem[(32 * _1961) + ceil32(return_data.size) + 836 len 0] = None
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args 2 * ext_call.return_data[0], _3143, Array(len=2, data=mem[(32 * _1961) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(32 * _1961) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (32 * _1961) + (2 * ceil32(return_data.size)) + 640
                    require return_data.size >= 32
                    require mem[(32 * _1961) + ceil32(return_data.size) + 640 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 <= 4294967296
                    require mem[(32 * _1961) + ceil32(return_data.size) + 640 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 32 <= return_data.size
                    require mem[mem[(32 * _1961) + ceil32(return_data.size) + 640 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _1961) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _1961) + ceil32(return_data.size) + 640 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * mem[mem[(32 * _1961) + ceil32(return_data.size) + 640 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _1961) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                    require ext_code.size(routerAddress)
                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                         gas gas_remaining wei
                        args stor10, stor11, 2 * ext_call.return_data[0], _3143, 0, 0, address(this.address), block.timestamp
            else:
                mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                mem[516] = uint255(ext_call.return_data[0])
                mem[548] = 64
                mem[580] = 2
                mem[612 len 0] = None
                require ext_code.size(routerAddress)
                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                        gas gas_remaining wei
                       args 2 * ext_call.return_data[0], Array(len=2, data=mem[612 len 64])
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(return_data.size) + 512
                require return_data.size >= 32
                _1925 = mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31
                require mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 <= 4294967296
                require mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 32 <= return_data.size
                require mem[mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * mem[mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 512]) + 32 <= return_data.size
                mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 512]
                _1962 = mem[_1925 + 512]
                mem[ceil32(return_data.size) + 544 len floor32(mem[_1925 + 512])] = mem[_1925 + 544 len floor32(mem[_1925 + 512])]
                mem[64] = (32 * _1962) + ceil32(return_data.size) + 544
                require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                _3147 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                mem[(32 * _1962) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                mem[(32 * _1962) + ceil32(return_data.size) + 548] = uint255(ext_call.return_data[0])
                mem[(32 * _1962) + ceil32(return_data.size) + 580] = _3147
                mem[(32 * _1962) + ceil32(return_data.size) + 644] = this.address
                mem[(32 * _1962) + ceil32(return_data.size) + 676] = block.timestamp
                mem[(32 * _1962) + ceil32(return_data.size) + 612] = 160
                mem[(32 * _1962) + ceil32(return_data.size) + 708] = 2
                mem[(32 * _1962) + ceil32(return_data.size) + 740 len 0] = None
                require ext_code.size(routerAddress)
                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                     gas gas_remaining wei
                    args 2 * ext_call.return_data[0], _3147, Array(len=2, data=mem[(32 * _1962) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[(32 * _1962) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = (32 * _1962) + (2 * ceil32(return_data.size)) + 544
                require return_data.size >= 32
                _4175 = mem[(32 * _1962) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31
                require mem[(32 * _1962) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 <= 4294967296
                require mem[(32 * _1962) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 32 <= return_data.size
                require mem[mem[(32 * _1962) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _1962) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _1962) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * mem[mem[(32 * _1962) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _1962) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                mem[(32 * _1962) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _1962) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _1962) + ceil32(return_data.size) + 544]
                _4212 = mem[_4175 + (32 * _1962) + ceil32(return_data.size) + 544]
                mem[(32 * _1962) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_4175 + (32 * _1962) + ceil32(return_data.size) + 544])] = mem[_4175 + (32 * _1962) + ceil32(return_data.size) + 576 len floor32(mem[_4175 + (32 * _1962) + ceil32(return_data.size) + 544])]
                mem[(32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 576] = 2
                mem[(32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                mem[(32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 640] = stor11
                if rewardTokenAddress == stor11:
                    require ext_code.size(routerAddress)
                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                         gas gas_remaining wei
                        args stor10, stor11, _3147, 2 * ext_call.return_data[0], 0, 0, address(this.address), block.timestamp
                else:
                    mem[(32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[(32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 676] = uint255(ext_call.return_data[0])
                    mem[(32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 708] = 64
                    mem[(32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 740] = 2
                    mem[(32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                    require ext_code.size(routerAddress)
                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                            gas gas_remaining wei
                           args 2 * ext_call.return_data[0], Array(len=2, data=mem[(32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 772 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 672
                    require return_data.size >= 32
                    _5876 = mem[(32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31
                    require mem[(32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 <= 4294967296
                    require mem[(32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 32 <= return_data.size
                    require mem[mem[(32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * mem[mem[(32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                    mem[(32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 672]
                    _5895 = mem[_5876 + (32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 672]
                    mem[(32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_5876 + (32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 672])] = mem[_5876 + (32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_5876 + (32 * _4212) + (32 * _1962) + (2 * ceil32(return_data.size)) + 672])]
                    mem[64] = (32 * _5895) + (32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 704
                    require mem[(32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 672]
                    _6252 = mem[(32 * mem[(32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 704]
                    mem[(32 * _5895) + (32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(32 * _5895) + (32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 708] = uint255(ext_call.return_data[0])
                    mem[(32 * _5895) + (32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 740] = _6252
                    mem[(32 * _5895) + (32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 804] = this.address
                    mem[(32 * _5895) + (32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                    mem[(32 * _5895) + (32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 772] = 160
                    mem[(32 * _5895) + (32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 868] = 2
                    mem[(32 * _5895) + (32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args 2 * ext_call.return_data[0], _6252, Array(len=2, data=mem[(32 * _5895) + (32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(32 * _5895) + (32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (32 * _5895) + (32 * _4212) + (32 * _1962) + (6 * ceil32(return_data.size)) + 704
                    require return_data.size >= 32
                    require mem[(32 * _5895) + (32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 <= 4294967296
                    require mem[(32 * _5895) + (32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 32 <= return_data.size
                    require mem[mem[(32 * _5895) + (32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _5895) + (32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _5895) + (32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * mem[mem[(32 * _5895) + (32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _5895) + (32 * _4212) + (32 * _1962) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                    require ext_code.size(routerAddress)
                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                         gas gas_remaining wei
                        args stor10, stor11, _3147, _6252, 0, 0, address(this.address), block.timestamp
        else:
            require 2 * ext_call.return_data[0]
            if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 2 * ext_call.return_data[0] != REINVEST_REWARD_BIPS:
                revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 <= 0:
                mem[224] = 31
                mem[256] = 'SafeMath: subtraction underflow'
                if 0 > 2 * ext_call.return_data[0]:
                    revert with 0, 'SafeMath: subtraction underflow'
                mem[288] = 31
                mem[320] = 'SafeMath: subtraction underflow'
                if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                    revert with 0, 'SafeMath: subtraction underflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2 <= 0:
                    revert with 0, 'amount too low'
                mem[416] = 2
                mem[448] = rewardTokenAddress
                mem[480] = stor10
                if rewardTokenAddress == stor10:
                    mem[512] = 2
                    mem[544] = rewardTokenAddress
                    mem[576] = stor11
                    if rewardTokenAddress == stor11:
                        require ext_code.size(routerAddress)
                        call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                             gas gas_remaining wei
                            args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                    else:
                        mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                        mem[644] = 64
                        mem[676] = 2
                        mem[708 len 0] = None
                        require ext_code.size(routerAddress)
                        staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + 608
                        require return_data.size >= 32
                        _1915 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                        require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]
                        _1957 = mem[_1915 + 608]
                        mem[ceil32(return_data.size) + 640 len floor32(mem[_1915 + 608])] = mem[_1915 + 640 len floor32(mem[_1915 + 608])]
                        mem[64] = (32 * _1957) + ceil32(return_data.size) + 640
                        require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                        _3127 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                        mem[(32 * _1957) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1957) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                        mem[(32 * _1957) + ceil32(return_data.size) + 676] = _3127
                        mem[(32 * _1957) + ceil32(return_data.size) + 740] = this.address
                        mem[(32 * _1957) + ceil32(return_data.size) + 772] = block.timestamp
                        mem[(32 * _1957) + ceil32(return_data.size) + 708] = 160
                        mem[(32 * _1957) + ceil32(return_data.size) + 804] = 2
                        mem[(32 * _1957) + ceil32(return_data.size) + 836 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _3127, Array(len=2, data=mem[(32 * _1957) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1957) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1957) + (2 * ceil32(return_data.size)) + 640
                        require return_data.size >= 32
                        require mem[(32 * _1957) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[(32 * _1957) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1957) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1957) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _1957) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _1957) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1957) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                        require ext_code.size(routerAddress)
                        call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                             gas gas_remaining wei
                            args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _3127, 0, 0, address(this.address), block.timestamp
                else:
                    mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                    mem[548] = 64
                    mem[580] = 2
                    mem[612 len 0] = None
                    require ext_code.size(routerAddress)
                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                            gas gas_remaining wei
                           args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(return_data.size) + 512
                    require return_data.size >= 32
                    _1917 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                    require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                    require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                    require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                    mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]
                    _1958 = mem[_1917 + 512]
                    mem[ceil32(return_data.size) + 544 len floor32(mem[_1917 + 512])] = mem[_1917 + 544 len floor32(mem[_1917 + 512])]
                    mem[64] = (32 * _1958) + ceil32(return_data.size) + 544
                    require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                    _3131 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                    mem[(32 * _1958) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(32 * _1958) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                    mem[(32 * _1958) + ceil32(return_data.size) + 580] = _3131
                    mem[(32 * _1958) + ceil32(return_data.size) + 644] = this.address
                    mem[(32 * _1958) + ceil32(return_data.size) + 676] = block.timestamp
                    mem[(32 * _1958) + ceil32(return_data.size) + 612] = 160
                    mem[(32 * _1958) + ceil32(return_data.size) + 708] = 2
                    mem[(32 * _1958) + ceil32(return_data.size) + 740 len 0] = None
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _3131, Array(len=2, data=mem[(32 * _1958) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(32 * _1958) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (32 * _1958) + (2 * ceil32(return_data.size)) + 544
                    require return_data.size >= 32
                    _4167 = mem[(32 * _1958) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                    require mem[(32 * _1958) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                    require mem[(32 * _1958) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                    require mem[mem[(32 * _1958) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1958) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _1958) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _1958) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1958) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                    mem[(32 * _1958) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _1958) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1958) + ceil32(return_data.size) + 544]
                    _4208 = mem[_4167 + (32 * _1958) + ceil32(return_data.size) + 544]
                    mem[(32 * _1958) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_4167 + (32 * _1958) + ceil32(return_data.size) + 544])] = mem[_4167 + (32 * _1958) + ceil32(return_data.size) + 576 len floor32(mem[_4167 + (32 * _1958) + ceil32(return_data.size) + 544])]
                    mem[(32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 576] = 2
                    mem[(32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                    mem[(32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 640] = stor11
                    if rewardTokenAddress == stor11:
                        require ext_code.size(routerAddress)
                        call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                             gas gas_remaining wei
                            args stor10, stor11, _3131, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                    else:
                        mem[(32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[(32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                        mem[(32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 708] = 64
                        mem[(32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 740] = 2
                        mem[(32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                        require ext_code.size(routerAddress)
                        staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[(32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 772 len 64])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 672
                        require return_data.size >= 32
                        _5872 = mem[(32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                        require mem[(32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[(32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                        mem[(32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 672]
                        _5893 = mem[_5872 + (32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 672]
                        mem[(32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_5872 + (32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 672])] = mem[_5872 + (32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_5872 + (32 * _4208) + (32 * _1958) + (2 * ceil32(return_data.size)) + 672])]
                        require mem[(32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 672]
                        _6244 = mem[(32 * mem[(32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 704]
                        mem[(32 * _5893) + (32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _5893) + (32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                        mem[(32 * _5893) + (32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 740] = _6244
                        mem[(32 * _5893) + (32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 804] = this.address
                        mem[(32 * _5893) + (32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                        mem[(32 * _5893) + (32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 772] = 160
                        mem[(32 * _5893) + (32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 868] = 2
                        mem[(32 * _5893) + (32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _6244, Array(len=2, data=mem[(32 * _5893) + (32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _5893) + (32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _5893) + (32 * _4208) + (32 * _1958) + (6 * ceil32(return_data.size)) + 704
                        require return_data.size >= 32
                        require mem[(32 * _5893) + (32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[(32 * _5893) + (32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _5893) + (32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5893) + (32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _5893) + (32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5893) + (32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5893) + (32 * _4208) + (32 * _1958) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                        require ext_code.size(routerAddress)
                        call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                             gas gas_remaining wei
                            args stor10, stor11, _3131, _6244, 0, 0, address(this.address), block.timestamp
            else:
                require ext_code.size(rewardTokenAddress)
                call rewardTokenAddress.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if not ext_call.return_data[0]:
                    revert with 0, 'reinvest fee transfer failed'
                mem[224] = 31
                mem[256] = 'SafeMath: subtraction underflow'
                if 0 > 2 * ext_call.return_data[0]:
                    revert with 0, 'SafeMath: subtraction underflow'
                mem[288] = 31
                mem[320] = 'SafeMath: subtraction underflow'
                if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                    revert with 0, 'SafeMath: subtraction underflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2 <= 0:
                    revert with 0, 'amount too low'
                mem[416] = 2
                mem[448] = rewardTokenAddress
                mem[480] = stor10
                if rewardTokenAddress == stor10:
                    mem[512] = 2
                    mem[544] = rewardTokenAddress
                    mem[576] = stor11
                    if rewardTokenAddress == stor11:
                        require ext_code.size(routerAddress)
                        call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                             gas gas_remaining wei
                            args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                    else:
                        mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                        mem[644] = 64
                        mem[676] = 2
                        mem[708 len 0] = None
                        require ext_code.size(routerAddress)
                        staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + 608
                        require return_data.size >= 32
                        _1919 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                        require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]
                        _1959 = mem[_1919 + 608]
                        mem[ceil32(return_data.size) + 640 len floor32(mem[_1919 + 608])] = mem[_1919 + 640 len floor32(mem[_1919 + 608])]
                        mem[64] = (32 * _1959) + ceil32(return_data.size) + 640
                        require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                        _3135 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                        mem[(32 * _1959) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1959) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                        mem[(32 * _1959) + ceil32(return_data.size) + 676] = _3135
                        mem[(32 * _1959) + ceil32(return_data.size) + 740] = this.address
                        mem[(32 * _1959) + ceil32(return_data.size) + 772] = block.timestamp
                        mem[(32 * _1959) + ceil32(return_data.size) + 708] = 160
                        mem[(32 * _1959) + ceil32(return_data.size) + 804] = 2
                        mem[(32 * _1959) + ceil32(return_data.size) + 836 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _3135, Array(len=2, data=mem[(32 * _1959) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1959) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1959) + (2 * ceil32(return_data.size)) + 640
                        require return_data.size >= 32
                        require mem[(32 * _1959) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[(32 * _1959) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1959) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1959) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _1959) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _1959) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1959) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                        require ext_code.size(routerAddress)
                        call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                             gas gas_remaining wei
                            args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _3135, 0, 0, address(this.address), block.timestamp
                else:
                    mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                    mem[548] = 64
                    mem[580] = 2
                    mem[612 len 0] = None
                    require ext_code.size(routerAddress)
                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                            gas gas_remaining wei
                           args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(return_data.size) + 512
                    require return_data.size >= 32
                    _1921 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                    require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                    require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                    require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                    mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]
                    _1960 = mem[_1921 + 512]
                    mem[ceil32(return_data.size) + 544 len floor32(mem[_1921 + 512])] = mem[_1921 + 544 len floor32(mem[_1921 + 512])]
                    mem[64] = (32 * _1960) + ceil32(return_data.size) + 544
                    require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                    _3139 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                    mem[(32 * _1960) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(32 * _1960) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                    mem[(32 * _1960) + ceil32(return_data.size) + 580] = _3139
                    mem[(32 * _1960) + ceil32(return_data.size) + 644] = this.address
                    mem[(32 * _1960) + ceil32(return_data.size) + 676] = block.timestamp
                    mem[(32 * _1960) + ceil32(return_data.size) + 612] = 160
                    mem[(32 * _1960) + ceil32(return_data.size) + 708] = 2
                    mem[(32 * _1960) + ceil32(return_data.size) + 740 len 0] = None
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _3139, Array(len=2, data=mem[(32 * _1960) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(32 * _1960) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (32 * _1960) + (2 * ceil32(return_data.size)) + 544
                    require return_data.size >= 32
                    _4171 = mem[(32 * _1960) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                    require mem[(32 * _1960) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                    require mem[(32 * _1960) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                    require mem[mem[(32 * _1960) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1960) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _1960) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _1960) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1960) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                    mem[(32 * _1960) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _1960) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1960) + ceil32(return_data.size) + 544]
                    _4210 = mem[_4171 + (32 * _1960) + ceil32(return_data.size) + 544]
                    mem[(32 * _1960) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_4171 + (32 * _1960) + ceil32(return_data.size) + 544])] = mem[_4171 + (32 * _1960) + ceil32(return_data.size) + 576 len floor32(mem[_4171 + (32 * _1960) + ceil32(return_data.size) + 544])]
                    mem[(32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 576] = 2
                    mem[(32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                    mem[(32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 640] = stor11
                    if rewardTokenAddress == stor11:
                        require ext_code.size(routerAddress)
                        call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                             gas gas_remaining wei
                            args stor10, stor11, _3139, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                    else:
                        mem[(32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[(32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                        mem[(32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 708] = 64
                        mem[(32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 740] = 2
                        mem[(32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                        require ext_code.size(routerAddress)
                        staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[(32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 772 len 64])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 672
                        require return_data.size >= 32
                        _5874 = mem[(32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                        require mem[(32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[(32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                        mem[(32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 672]
                        _5894 = mem[_5874 + (32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 672]
                        mem[(32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_5874 + (32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 672])] = mem[_5874 + (32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_5874 + (32 * _4210) + (32 * _1960) + (2 * ceil32(return_data.size)) + 672])]
                        mem[64] = (32 * _5894) + (32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 704
                        require mem[(32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 672]
                        _6248 = mem[(32 * mem[(32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 704]
                        mem[(32 * _5894) + (32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _5894) + (32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                        mem[(32 * _5894) + (32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 740] = _6248
                        mem[(32 * _5894) + (32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 804] = this.address
                        mem[(32 * _5894) + (32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                        mem[(32 * _5894) + (32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 772] = 160
                        mem[(32 * _5894) + (32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 868] = 2
                        mem[(32 * _5894) + (32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _6248, Array(len=2, data=mem[(32 * _5894) + (32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _5894) + (32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _5894) + (32 * _4210) + (32 * _1960) + (6 * ceil32(return_data.size)) + 704
                        require return_data.size >= 32
                        require mem[(32 * _5894) + (32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[(32 * _5894) + (32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _5894) + (32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5894) + (32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _5894) + (32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5894) + (32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5894) + (32 * _4210) + (32 * _1960) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                        require ext_code.size(routerAddress)
                        call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                             gas gas_remaining wei
                            args stor10, stor11, _3139, _6248, 0, 0, address(this.address), block.timestamp
    else:
        require 2 * ext_call.return_data[0]
        if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 2 * ext_call.return_data[0] != ADMIN_FEE_BIPS:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 <= 0:
            if not uint255(ext_call.return_data[0]):
                mem[160] = 26
                mem[192] = 'SafeMath: division by zero'
                mem[224] = 31
                mem[256] = 'SafeMath: subtraction underflow'
                if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                    revert with 0, 'SafeMath: subtraction underflow'
                mem[288] = 31
                mem[320] = 'SafeMath: subtraction underflow'
                if 0 > (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000):
                    revert with 0, 'SafeMath: subtraction underflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2 <= 0:
                    revert with 0, 'amount too low'
                mem[416] = 2
                mem[448] = rewardTokenAddress
                mem[480] = stor10
                if rewardTokenAddress == stor10:
                    mem[512] = 2
                    mem[544] = rewardTokenAddress
                    mem[576] = stor11
                    if rewardTokenAddress == stor11:
                        require ext_code.size(routerAddress)
                        call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                             gas gas_remaining wei
                            args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                    else:
                        mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                        mem[644] = 64
                        mem[676] = 2
                        mem[708 len 0] = None
                        require ext_code.size(routerAddress)
                        staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + 608
                        require return_data.size >= 32
                        _1899 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                        require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 608]
                        _1949 = mem[_1899 + 608]
                        mem[ceil32(return_data.size) + 640 len floor32(mem[_1899 + 608])] = mem[_1899 + 640 len floor32(mem[_1899 + 608])]
                        mem[64] = (32 * _1949) + ceil32(return_data.size) + 640
                        require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                        _3095 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                        mem[(32 * _1949) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1949) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                        mem[(32 * _1949) + ceil32(return_data.size) + 676] = _3095
                        mem[(32 * _1949) + ceil32(return_data.size) + 740] = this.address
                        mem[(32 * _1949) + ceil32(return_data.size) + 772] = block.timestamp
                        mem[(32 * _1949) + ceil32(return_data.size) + 708] = 160
                        mem[(32 * _1949) + ceil32(return_data.size) + 804] = 2
                        mem[(32 * _1949) + ceil32(return_data.size) + 836 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _3095, Array(len=2, data=mem[(32 * _1949) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1949) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1949) + (2 * ceil32(return_data.size)) + 640
                        require return_data.size >= 32
                        require mem[(32 * _1949) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[(32 * _1949) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1949) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _1949) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _1949) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _1949) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _1949) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                        require ext_code.size(routerAddress)
                        call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                             gas gas_remaining wei
                            args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _3095, 0, 0, address(this.address), block.timestamp
                else:
                    mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                    mem[548] = 64
                    mem[580] = 2
                    mem[612 len 0] = None
                    require ext_code.size(routerAddress)
                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                            gas gas_remaining wei
                           args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(return_data.size) + 512
                    require return_data.size >= 32
                    _1901 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                    require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                    require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                    require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                    mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 512]
                    _1950 = mem[_1901 + 512]
                    mem[ceil32(return_data.size) + 544 len floor32(mem[_1901 + 512])] = mem[_1901 + 544 len floor32(mem[_1901 + 512])]
                    mem[64] = (32 * _1950) + ceil32(return_data.size) + 544
                    require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                    _3099 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                    mem[(32 * _1950) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(32 * _1950) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                    mem[(32 * _1950) + ceil32(return_data.size) + 580] = _3099
                    mem[(32 * _1950) + ceil32(return_data.size) + 644] = this.address
                    mem[(32 * _1950) + ceil32(return_data.size) + 676] = block.timestamp
                    mem[(32 * _1950) + ceil32(return_data.size) + 612] = 160
                    mem[(32 * _1950) + ceil32(return_data.size) + 708] = 2
                    mem[(32 * _1950) + ceil32(return_data.size) + 740 len 0] = None
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _3099, Array(len=2, data=mem[(32 * _1950) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(32 * _1950) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (32 * _1950) + (2 * ceil32(return_data.size)) + 544
                    require return_data.size >= 32
                    _4151 = mem[(32 * _1950) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                    require mem[(32 * _1950) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                    require mem[(32 * _1950) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                    require mem[mem[(32 * _1950) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _1950) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _1950) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _1950) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _1950) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                    mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _1950) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _1950) + ceil32(return_data.size) + 544]
                    _4200 = mem[_4151 + (32 * _1950) + ceil32(return_data.size) + 544]
                    mem[(32 * _1950) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_4151 + (32 * _1950) + ceil32(return_data.size) + 544])] = mem[_4151 + (32 * _1950) + ceil32(return_data.size) + 576 len floor32(mem[_4151 + (32 * _1950) + ceil32(return_data.size) + 544])]
                    mem[(32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 576] = 2
                    mem[(32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                    mem[(32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 640] = stor11
                    if rewardTokenAddress == stor11:
                        require ext_code.size(routerAddress)
                        call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                             gas gas_remaining wei
                            args stor10, stor11, _3099, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                    else:
                        mem[(32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[(32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                        mem[(32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 708] = 64
                        mem[(32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 740] = 2
                        mem[(32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                        require ext_code.size(routerAddress)
                        staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Array(len=2, data=mem[(32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 772 len 64])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 672
                        require return_data.size >= 32
                        _5864 = mem[(32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                        require mem[(32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[(32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                        mem[(32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 672]
                        _5889 = mem[_5864 + (32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 672]
                        mem[(32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_5864 + (32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 672])] = mem[_5864 + (32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_5864 + (32 * _4200) + (32 * _1950) + (2 * ceil32(return_data.size)) + 672])]
                        mem[64] = (32 * _5889) + (32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 704
                        require mem[(32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 672]
                        _6228 = mem[(32 * mem[(32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 704]
                        mem[(32 * _5889) + (32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _5889) + (32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                        mem[(32 * _5889) + (32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 740] = _6228
                        mem[(32 * _5889) + (32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 804] = this.address
                        mem[(32 * _5889) + (32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                        mem[(32 * _5889) + (32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 772] = 160
                        mem[(32 * _5889) + (32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 868] = 2
                        mem[(32 * _5889) + (32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _6228, Array(len=2, data=mem[(32 * _5889) + (32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _5889) + (32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _5889) + (32 * _4200) + (32 * _1950) + (6 * ceil32(return_data.size)) + 704
                        require return_data.size >= 32
                        require mem[(32 * _5889) + (32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[(32 * _5889) + (32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _5889) + (32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5889) + (32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _5889) + (32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5889) + (32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5889) + (32 * _4200) + (32 * _1950) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                        require ext_code.size(routerAddress)
                        call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                             gas gas_remaining wei
                            args stor10, stor11, _3099, _6228, 0, 0, address(this.address), block.timestamp
            else:
                require 2 * ext_call.return_data[0]
                if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 2 * ext_call.return_data[0] != REINVEST_REWARD_BIPS:
                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                mem[160] = 26
                mem[192] = 'SafeMath: division by zero'
                if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 <= 0:
                    mem[224] = 31
                    mem[256] = 'SafeMath: subtraction underflow'
                    if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                        revert with 0, 'SafeMath: subtraction underflow'
                    mem[288] = 31
                    mem[320] = 'SafeMath: subtraction underflow'
                    if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 > (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000):
                        revert with 0, 'SafeMath: subtraction underflow'
                    mem[352] = 26
                    mem[384] = 'SafeMath: division by zero'
                    if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2 <= 0:
                        revert with 0, 'amount too low'
                    mem[416] = 2
                    mem[448] = rewardTokenAddress
                    mem[480] = stor10
                    if rewardTokenAddress == stor10:
                        mem[512] = 2
                        mem[544] = rewardTokenAddress
                        mem[576] = stor11
                        if rewardTokenAddress == stor11:
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                        else:
                            mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[644] = 64
                            mem[676] = 2
                            mem[708 len 0] = None
                            require ext_code.size(routerAddress)
                            staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 608
                            require return_data.size >= 32
                            _1891 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                            require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]
                            _1945 = mem[_1891 + 608]
                            mem[ceil32(return_data.size) + 640 len floor32(mem[_1891 + 608])] = mem[_1891 + 640 len floor32(mem[_1891 + 608])]
                            mem[64] = (32 * _1945) + ceil32(return_data.size) + 640
                            require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                            _3079 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                            mem[(32 * _1945) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(32 * _1945) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[(32 * _1945) + ceil32(return_data.size) + 676] = _3079
                            mem[(32 * _1945) + ceil32(return_data.size) + 740] = this.address
                            mem[(32 * _1945) + ceil32(return_data.size) + 772] = block.timestamp
                            mem[(32 * _1945) + ceil32(return_data.size) + 708] = 160
                            mem[(32 * _1945) + ceil32(return_data.size) + 804] = 2
                            mem[(32 * _1945) + ceil32(return_data.size) + 836 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _3079, Array(len=2, data=mem[(32 * _1945) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _1945) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _1945) + (2 * ceil32(return_data.size)) + 640
                            require return_data.size >= 32
                            require mem[(32 * _1945) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[(32 * _1945) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[(32 * _1945) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1945) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _1945) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _1945) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1945) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _3079, 0, 0, address(this.address), block.timestamp
                    else:
                        mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                        mem[548] = 64
                        mem[580] = 2
                        mem[612 len 0] = None
                        require ext_code.size(routerAddress)
                        staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + 512
                        require return_data.size >= 32
                        _1893 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                        require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]
                        _1946 = mem[_1893 + 512]
                        mem[ceil32(return_data.size) + 544 len floor32(mem[_1893 + 512])] = mem[_1893 + 544 len floor32(mem[_1893 + 512])]
                        mem[64] = (32 * _1946) + ceil32(return_data.size) + 544
                        require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                        _3083 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                        mem[(32 * _1946) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1946) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                        mem[(32 * _1946) + ceil32(return_data.size) + 580] = _3083
                        mem[(32 * _1946) + ceil32(return_data.size) + 644] = this.address
                        mem[(32 * _1946) + ceil32(return_data.size) + 676] = block.timestamp
                        mem[(32 * _1946) + ceil32(return_data.size) + 612] = 160
                        mem[(32 * _1946) + ceil32(return_data.size) + 708] = 2
                        mem[(32 * _1946) + ceil32(return_data.size) + 740 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _3083, Array(len=2, data=mem[(32 * _1946) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1946) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1946) + (2 * ceil32(return_data.size)) + 544
                        require return_data.size >= 32
                        _4143 = mem[(32 * _1946) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                        require mem[(32 * _1946) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[(32 * _1946) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1946) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1946) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _1946) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _1946) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1946) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                        mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _1946) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1946) + ceil32(return_data.size) + 544]
                        _4196 = mem[_4143 + (32 * _1946) + ceil32(return_data.size) + 544]
                        mem[(32 * _1946) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_4143 + (32 * _1946) + ceil32(return_data.size) + 544])] = mem[_4143 + (32 * _1946) + ceil32(return_data.size) + 576 len floor32(mem[_4143 + (32 * _1946) + ceil32(return_data.size) + 544])]
                        mem[(32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 576] = 2
                        mem[(32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                        mem[(32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 640] = stor11
                        if rewardTokenAddress == stor11:
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, _3083, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                        else:
                            mem[(32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[(32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[(32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 708] = 64
                            mem[(32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 740] = 2
                            mem[(32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                            require ext_code.size(routerAddress)
                            staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[(32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 772 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 672
                            require return_data.size >= 32
                            _5860 = mem[(32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                            require mem[(32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[(32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[(32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                            mem[(32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 672]
                            _5887 = mem[_5860 + (32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 672]
                            mem[(32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_5860 + (32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 672])] = mem[_5860 + (32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_5860 + (32 * _4196) + (32 * _1946) + (2 * ceil32(return_data.size)) + 672])]
                            mem[64] = (32 * _5887) + (32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 704
                            require mem[(32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 672]
                            _6220 = mem[(32 * mem[(32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 704]
                            mem[(32 * _5887) + (32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(32 * _5887) + (32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[(32 * _5887) + (32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 740] = _6220
                            mem[(32 * _5887) + (32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 804] = this.address
                            mem[(32 * _5887) + (32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                            mem[(32 * _5887) + (32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 772] = 160
                            mem[(32 * _5887) + (32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 868] = 2
                            mem[(32 * _5887) + (32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _6220, Array(len=2, data=mem[(32 * _5887) + (32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _5887) + (32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _5887) + (32 * _4196) + (32 * _1946) + (6 * ceil32(return_data.size)) + 704
                            require return_data.size >= 32
                            require mem[(32 * _5887) + (32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[(32 * _5887) + (32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[(32 * _5887) + (32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5887) + (32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _5887) + (32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5887) + (32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5887) + (32 * _4196) + (32 * _1946) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, _3083, _6220, 0, 0, address(this.address), block.timestamp
                else:
                    require ext_code.size(rewardTokenAddress)
                    call rewardTokenAddress.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0, 'reinvest fee transfer failed'
                    mem[224] = 31
                    mem[256] = 'SafeMath: subtraction underflow'
                    if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                        revert with 0, 'SafeMath: subtraction underflow'
                    mem[288] = 31
                    mem[320] = 'SafeMath: subtraction underflow'
                    if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 > (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000):
                        revert with 0, 'SafeMath: subtraction underflow'
                    mem[352] = 26
                    mem[384] = 'SafeMath: division by zero'
                    if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2 <= 0:
                        revert with 0, 'amount too low'
                    mem[416] = 2
                    mem[448] = rewardTokenAddress
                    mem[480] = stor10
                    if rewardTokenAddress == stor10:
                        mem[512] = 2
                        mem[544] = rewardTokenAddress
                        mem[576] = stor11
                        if rewardTokenAddress == stor11:
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                        else:
                            mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[644] = 64
                            mem[676] = 2
                            mem[708 len 0] = None
                            require ext_code.size(routerAddress)
                            staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 608
                            require return_data.size >= 32
                            _1895 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                            require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]
                            _1947 = mem[_1895 + 608]
                            mem[ceil32(return_data.size) + 640 len floor32(mem[_1895 + 608])] = mem[_1895 + 640 len floor32(mem[_1895 + 608])]
                            mem[64] = (32 * _1947) + ceil32(return_data.size) + 640
                            require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                            _3087 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                            mem[(32 * _1947) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(32 * _1947) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[(32 * _1947) + ceil32(return_data.size) + 676] = _3087
                            mem[(32 * _1947) + ceil32(return_data.size) + 740] = this.address
                            mem[(32 * _1947) + ceil32(return_data.size) + 772] = block.timestamp
                            mem[(32 * _1947) + ceil32(return_data.size) + 708] = 160
                            mem[(32 * _1947) + ceil32(return_data.size) + 804] = 2
                            mem[(32 * _1947) + ceil32(return_data.size) + 836 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _3087, Array(len=2, data=mem[(32 * _1947) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _1947) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _1947) + (2 * ceil32(return_data.size)) + 640
                            require return_data.size >= 32
                            require mem[(32 * _1947) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[(32 * _1947) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[(32 * _1947) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1947) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _1947) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _1947) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1947) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _3087, 0, 0, address(this.address), block.timestamp
                    else:
                        mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                        mem[548] = 64
                        mem[580] = 2
                        mem[612 len 0] = None
                        require ext_code.size(routerAddress)
                        staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + 512
                        require return_data.size >= 32
                        _1897 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                        require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]
                        _1948 = mem[_1897 + 512]
                        mem[ceil32(return_data.size) + 544 len floor32(mem[_1897 + 512])] = mem[_1897 + 544 len floor32(mem[_1897 + 512])]
                        mem[64] = (32 * _1948) + ceil32(return_data.size) + 544
                        require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                        _3091 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                        mem[(32 * _1948) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1948) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                        mem[(32 * _1948) + ceil32(return_data.size) + 580] = _3091
                        mem[(32 * _1948) + ceil32(return_data.size) + 644] = this.address
                        mem[(32 * _1948) + ceil32(return_data.size) + 676] = block.timestamp
                        mem[(32 * _1948) + ceil32(return_data.size) + 612] = 160
                        mem[(32 * _1948) + ceil32(return_data.size) + 708] = 2
                        mem[(32 * _1948) + ceil32(return_data.size) + 740 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _3091, Array(len=2, data=mem[(32 * _1948) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1948) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1948) + (2 * ceil32(return_data.size)) + 544
                        require return_data.size >= 32
                        _4147 = mem[(32 * _1948) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                        require mem[(32 * _1948) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[(32 * _1948) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1948) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1948) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _1948) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _1948) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1948) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                        mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _1948) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1948) + ceil32(return_data.size) + 544]
                        _4198 = mem[_4147 + (32 * _1948) + ceil32(return_data.size) + 544]
                        mem[(32 * _1948) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_4147 + (32 * _1948) + ceil32(return_data.size) + 544])] = mem[_4147 + (32 * _1948) + ceil32(return_data.size) + 576 len floor32(mem[_4147 + (32 * _1948) + ceil32(return_data.size) + 544])]
                        mem[(32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 576] = 2
                        mem[(32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                        mem[(32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 640] = stor11
                        if rewardTokenAddress == stor11:
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, _3091, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                        else:
                            mem[(32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[(32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[(32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 708] = 64
                            mem[(32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 740] = 2
                            mem[(32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                            require ext_code.size(routerAddress)
                            staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[(32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 772 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 672
                            require return_data.size >= 32
                            _5862 = mem[(32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                            require mem[(32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[(32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[(32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                            mem[(32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 672]
                            _5888 = mem[_5862 + (32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 672]
                            mem[(32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_5862 + (32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 672])] = mem[_5862 + (32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_5862 + (32 * _4198) + (32 * _1948) + (2 * ceil32(return_data.size)) + 672])]
                            mem[64] = (32 * _5888) + (32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 704
                            require mem[(32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 672]
                            _6224 = mem[(32 * mem[(32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 704]
                            mem[(32 * _5888) + (32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(32 * _5888) + (32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[(32 * _5888) + (32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 740] = _6224
                            mem[(32 * _5888) + (32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 804] = this.address
                            mem[(32 * _5888) + (32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                            mem[(32 * _5888) + (32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 772] = 160
                            mem[(32 * _5888) + (32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 868] = 2
                            mem[(32 * _5888) + (32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _6224, Array(len=2, data=mem[(32 * _5888) + (32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _5888) + (32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _5888) + (32 * _4198) + (32 * _1948) + (6 * ceil32(return_data.size)) + 704
                            require return_data.size >= 32
                            require mem[(32 * _5888) + (32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[(32 * _5888) + (32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[(32 * _5888) + (32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5888) + (32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _5888) + (32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5888) + (32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5888) + (32 * _4198) + (32 * _1948) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, _3091, _6224, 0, 0, address(this.address), block.timestamp
        else:
            require ext_code.size(rewardTokenAddress)
            call rewardTokenAddress.0xa9059cbb with:
                 gas gas_remaining wei
                args owner, (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'admin fee transfer failed'
            if not uint255(ext_call.return_data[0]):
                mem[160] = 26
                mem[192] = 'SafeMath: division by zero'
                mem[224] = 31
                mem[256] = 'SafeMath: subtraction underflow'
                if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                    revert with 0, 'SafeMath: subtraction underflow'
                mem[288] = 31
                mem[320] = 'SafeMath: subtraction underflow'
                if 0 > (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000):
                    revert with 0, 'SafeMath: subtraction underflow'
                mem[352] = 26
                mem[384] = 'SafeMath: division by zero'
                if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2 <= 0:
                    revert with 0, 'amount too low'
                mem[416] = 2
                mem[448] = rewardTokenAddress
                mem[480] = stor10
                if rewardTokenAddress == stor10:
                    mem[512] = 2
                    mem[544] = rewardTokenAddress
                    mem[576] = stor11
                    if rewardTokenAddress == stor11:
                        require ext_code.size(routerAddress)
                        call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                             gas gas_remaining wei
                            args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                    else:
                        mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                        mem[644] = 64
                        mem[676] = 2
                        mem[708 len 0] = None
                        require ext_code.size(routerAddress)
                        staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + 608
                        require return_data.size >= 32
                        _1911 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                        require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 608]
                        _1955 = mem[_1911 + 608]
                        mem[ceil32(return_data.size) + 640 len floor32(mem[_1911 + 608])] = mem[_1911 + 640 len floor32(mem[_1911 + 608])]
                        mem[64] = (32 * _1955) + ceil32(return_data.size) + 640
                        require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                        _3119 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                        mem[(32 * _1955) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1955) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                        mem[(32 * _1955) + ceil32(return_data.size) + 676] = _3119
                        mem[(32 * _1955) + ceil32(return_data.size) + 740] = this.address
                        mem[(32 * _1955) + ceil32(return_data.size) + 772] = block.timestamp
                        mem[(32 * _1955) + ceil32(return_data.size) + 708] = 160
                        mem[(32 * _1955) + ceil32(return_data.size) + 804] = 2
                        mem[(32 * _1955) + ceil32(return_data.size) + 836 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _3119, Array(len=2, data=mem[(32 * _1955) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1955) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1955) + (2 * ceil32(return_data.size)) + 640
                        require return_data.size >= 32
                        require mem[(32 * _1955) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[(32 * _1955) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1955) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _1955) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _1955) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _1955) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _1955) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                        require ext_code.size(routerAddress)
                        call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                             gas gas_remaining wei
                            args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _3119, 0, 0, address(this.address), block.timestamp
                else:
                    mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                    mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                    mem[548] = 64
                    mem[580] = 2
                    mem[612 len 0] = None
                    require ext_code.size(routerAddress)
                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                            gas gas_remaining wei
                           args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(return_data.size) + 512
                    require return_data.size >= 32
                    _1913 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                    require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                    require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                    require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                    mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 512]
                    _1956 = mem[_1913 + 512]
                    mem[ceil32(return_data.size) + 544 len floor32(mem[_1913 + 512])] = mem[_1913 + 544 len floor32(mem[_1913 + 512])]
                    mem[64] = (32 * _1956) + ceil32(return_data.size) + 544
                    require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                    _3123 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                    mem[(32 * _1956) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                    mem[(32 * _1956) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                    mem[(32 * _1956) + ceil32(return_data.size) + 580] = _3123
                    mem[(32 * _1956) + ceil32(return_data.size) + 644] = this.address
                    mem[(32 * _1956) + ceil32(return_data.size) + 676] = block.timestamp
                    mem[(32 * _1956) + ceil32(return_data.size) + 612] = 160
                    mem[(32 * _1956) + ceil32(return_data.size) + 708] = 2
                    mem[(32 * _1956) + ceil32(return_data.size) + 740 len 0] = None
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _3123, Array(len=2, data=mem[(32 * _1956) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[(32 * _1956) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = (32 * _1956) + (2 * ceil32(return_data.size)) + 544
                    require return_data.size >= 32
                    _4163 = mem[(32 * _1956) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                    require mem[(32 * _1956) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                    require mem[(32 * _1956) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                    require mem[mem[(32 * _1956) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _1956) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _1956) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _1956) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _1956) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                    mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _1956) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _1956) + ceil32(return_data.size) + 544]
                    _4206 = mem[_4163 + (32 * _1956) + ceil32(return_data.size) + 544]
                    mem[(32 * _1956) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_4163 + (32 * _1956) + ceil32(return_data.size) + 544])] = mem[_4163 + (32 * _1956) + ceil32(return_data.size) + 576 len floor32(mem[_4163 + (32 * _1956) + ceil32(return_data.size) + 544])]
                    mem[(32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 576] = 2
                    mem[(32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                    mem[(32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 640] = stor11
                    if rewardTokenAddress == stor11:
                        require ext_code.size(routerAddress)
                        call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                             gas gas_remaining wei
                            args stor10, stor11, _3123, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                    else:
                        mem[(32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[(32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                        mem[(32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 708] = 64
                        mem[(32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 740] = 2
                        mem[(32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                        require ext_code.size(routerAddress)
                        staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Array(len=2, data=mem[(32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 772 len 64])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 672
                        require return_data.size >= 32
                        _5870 = mem[(32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                        require mem[(32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[(32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                        mem[(32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 672]
                        _5892 = mem[_5870 + (32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 672]
                        mem[(32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_5870 + (32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 672])] = mem[_5870 + (32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_5870 + (32 * _4206) + (32 * _1956) + (2 * ceil32(return_data.size)) + 672])]
                        mem[64] = (32 * _5892) + (32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 704
                        require mem[(32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 672]
                        _6240 = mem[(32 * mem[(32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 704]
                        mem[(32 * _5892) + (32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _5892) + (32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                        mem[(32 * _5892) + (32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 740] = _6240
                        mem[(32 * _5892) + (32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 804] = this.address
                        mem[(32 * _5892) + (32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                        mem[(32 * _5892) + (32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 772] = 160
                        mem[(32 * _5892) + (32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 868] = 2
                        mem[(32 * _5892) + (32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _6240, Array(len=2, data=mem[(32 * _5892) + (32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _5892) + (32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _5892) + (32 * _4206) + (32 * _1956) + (6 * ceil32(return_data.size)) + 704
                        require return_data.size >= 32
                        require mem[(32 * _5892) + (32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[(32 * _5892) + (32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _5892) + (32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5892) + (32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _5892) + (32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5892) + (32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5892) + (32 * _4206) + (32 * _1956) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                        require ext_code.size(routerAddress)
                        call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                             gas gas_remaining wei
                            args stor10, stor11, _3123, _6240, 0, 0, address(this.address), block.timestamp
            else:
                require 2 * ext_call.return_data[0]
                if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 2 * ext_call.return_data[0] != REINVEST_REWARD_BIPS:
                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                mem[160] = 26
                mem[192] = 'SafeMath: division by zero'
                if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 <= 0:
                    mem[224] = 31
                    mem[256] = 'SafeMath: subtraction underflow'
                    if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                        revert with 0, 'SafeMath: subtraction underflow'
                    mem[288] = 31
                    mem[320] = 'SafeMath: subtraction underflow'
                    if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 > (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000):
                        revert with 0, 'SafeMath: subtraction underflow'
                    mem[352] = 26
                    mem[384] = 'SafeMath: division by zero'
                    if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2 <= 0:
                        revert with 0, 'amount too low'
                    mem[416] = 2
                    mem[448] = rewardTokenAddress
                    mem[480] = stor10
                    if rewardTokenAddress == stor10:
                        mem[512] = 2
                        mem[544] = rewardTokenAddress
                        mem[576] = stor11
                        if rewardTokenAddress == stor11:
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                        else:
                            mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[644] = 64
                            mem[676] = 2
                            mem[708 len 0] = None
                            require ext_code.size(routerAddress)
                            staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 608
                            require return_data.size >= 32
                            _1903 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                            require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]
                            _1951 = mem[_1903 + 608]
                            mem[ceil32(return_data.size) + 640 len floor32(mem[_1903 + 608])] = mem[_1903 + 640 len floor32(mem[_1903 + 608])]
                            mem[64] = (32 * _1951) + ceil32(return_data.size) + 640
                            require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                            _3103 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                            mem[(32 * _1951) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(32 * _1951) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[(32 * _1951) + ceil32(return_data.size) + 676] = _3103
                            mem[(32 * _1951) + ceil32(return_data.size) + 740] = this.address
                            mem[(32 * _1951) + ceil32(return_data.size) + 772] = block.timestamp
                            mem[(32 * _1951) + ceil32(return_data.size) + 708] = 160
                            mem[(32 * _1951) + ceil32(return_data.size) + 804] = 2
                            mem[(32 * _1951) + ceil32(return_data.size) + 836 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _3103, Array(len=2, data=mem[(32 * _1951) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _1951) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _1951) + (2 * ceil32(return_data.size)) + 640
                            require return_data.size >= 32
                            require mem[(32 * _1951) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[(32 * _1951) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[(32 * _1951) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1951) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _1951) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _1951) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1951) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _3103, 0, 0, address(this.address), block.timestamp
                    else:
                        mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                        mem[548] = 64
                        mem[580] = 2
                        mem[612 len 0] = None
                        require ext_code.size(routerAddress)
                        staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + 512
                        require return_data.size >= 32
                        _1905 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                        require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]
                        _1952 = mem[_1905 + 512]
                        mem[ceil32(return_data.size) + 544 len floor32(mem[_1905 + 512])] = mem[_1905 + 544 len floor32(mem[_1905 + 512])]
                        mem[64] = (32 * _1952) + ceil32(return_data.size) + 544
                        require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                        _3107 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                        mem[(32 * _1952) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1952) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                        mem[(32 * _1952) + ceil32(return_data.size) + 580] = _3107
                        mem[(32 * _1952) + ceil32(return_data.size) + 644] = this.address
                        mem[(32 * _1952) + ceil32(return_data.size) + 676] = block.timestamp
                        mem[(32 * _1952) + ceil32(return_data.size) + 612] = 160
                        mem[(32 * _1952) + ceil32(return_data.size) + 708] = 2
                        mem[(32 * _1952) + ceil32(return_data.size) + 740 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _3107, Array(len=2, data=mem[(32 * _1952) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1952) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1952) + (2 * ceil32(return_data.size)) + 544
                        require return_data.size >= 32
                        _4155 = mem[(32 * _1952) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                        require mem[(32 * _1952) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[(32 * _1952) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1952) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1952) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _1952) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _1952) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1952) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                        mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _1952) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1952) + ceil32(return_data.size) + 544]
                        _4202 = mem[_4155 + (32 * _1952) + ceil32(return_data.size) + 544]
                        mem[(32 * _1952) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_4155 + (32 * _1952) + ceil32(return_data.size) + 544])] = mem[_4155 + (32 * _1952) + ceil32(return_data.size) + 576 len floor32(mem[_4155 + (32 * _1952) + ceil32(return_data.size) + 544])]
                        mem[(32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 576] = 2
                        mem[(32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                        mem[(32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 640] = stor11
                        if rewardTokenAddress == stor11:
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, _3107, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                        else:
                            mem[(32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[(32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[(32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 708] = 64
                            mem[(32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 740] = 2
                            mem[(32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                            require ext_code.size(routerAddress)
                            staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[(32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 772 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 672
                            require return_data.size >= 32
                            _5866 = mem[(32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                            require mem[(32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[(32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[(32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                            mem[(32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 672]
                            _5890 = mem[_5866 + (32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 672]
                            mem[(32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_5866 + (32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 672])] = mem[_5866 + (32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_5866 + (32 * _4202) + (32 * _1952) + (2 * ceil32(return_data.size)) + 672])]
                            require mem[(32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 672]
                            _6232 = mem[(32 * mem[(32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 704]
                            mem[(32 * _5890) + (32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(32 * _5890) + (32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[(32 * _5890) + (32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 740] = _6232
                            mem[(32 * _5890) + (32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 804] = this.address
                            mem[(32 * _5890) + (32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                            mem[(32 * _5890) + (32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 772] = 160
                            mem[(32 * _5890) + (32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 868] = 2
                            mem[(32 * _5890) + (32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _6232, Array(len=2, data=mem[(32 * _5890) + (32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _5890) + (32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _5890) + (32 * _4202) + (32 * _1952) + (6 * ceil32(return_data.size)) + 704
                            require return_data.size >= 32
                            require mem[(32 * _5890) + (32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[(32 * _5890) + (32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[(32 * _5890) + (32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5890) + (32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _5890) + (32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5890) + (32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5890) + (32 * _4202) + (32 * _1952) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, _3107, _6232, 0, 0, address(this.address), block.timestamp
                else:
                    require ext_code.size(rewardTokenAddress)
                    call rewardTokenAddress.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0, 'reinvest fee transfer failed'
                    mem[224] = 31
                    mem[256] = 'SafeMath: subtraction underflow'
                    if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                        revert with 0, 'SafeMath: subtraction underflow'
                    mem[288] = 31
                    mem[320] = 'SafeMath: subtraction underflow'
                    if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 > (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000):
                        revert with 0, 'SafeMath: subtraction underflow'
                    mem[352] = 26
                    mem[384] = 'SafeMath: division by zero'
                    if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2 <= 0:
                        revert with 0, 'amount too low'
                    mem[416] = 2
                    mem[448] = rewardTokenAddress
                    mem[480] = stor10
                    if rewardTokenAddress == stor10:
                        mem[512] = 2
                        mem[544] = rewardTokenAddress
                        mem[576] = stor11
                        if rewardTokenAddress == stor11:
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                        else:
                            mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[644] = 64
                            mem[676] = 2
                            mem[708 len 0] = None
                            require ext_code.size(routerAddress)
                            staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 608
                            require return_data.size >= 32
                            _1907 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                            require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]
                            _1953 = mem[_1907 + 608]
                            mem[ceil32(return_data.size) + 640 len floor32(mem[_1907 + 608])] = mem[_1907 + 640 len floor32(mem[_1907 + 608])]
                            mem[64] = (32 * _1953) + ceil32(return_data.size) + 640
                            require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                            _3111 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                            mem[(32 * _1953) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(32 * _1953) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[(32 * _1953) + ceil32(return_data.size) + 676] = _3111
                            mem[(32 * _1953) + ceil32(return_data.size) + 740] = this.address
                            mem[(32 * _1953) + ceil32(return_data.size) + 772] = block.timestamp
                            mem[(32 * _1953) + ceil32(return_data.size) + 708] = 160
                            mem[(32 * _1953) + ceil32(return_data.size) + 804] = 2
                            mem[(32 * _1953) + ceil32(return_data.size) + 836 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _3111, Array(len=2, data=mem[(32 * _1953) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _1953) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _1953) + (2 * ceil32(return_data.size)) + 640
                            require return_data.size >= 32
                            require mem[(32 * _1953) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[(32 * _1953) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[(32 * _1953) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1953) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _1953) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _1953) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1953) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _3111, 0, 0, address(this.address), block.timestamp
                    else:
                        mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                        mem[548] = 64
                        mem[580] = 2
                        mem[612 len 0] = None
                        require ext_code.size(routerAddress)
                        staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + 512
                        require return_data.size >= 32
                        _1909 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                        require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]
                        _1954 = mem[_1909 + 512]
                        mem[ceil32(return_data.size) + 544 len floor32(mem[_1909 + 512])] = mem[_1909 + 544 len floor32(mem[_1909 + 512])]
                        mem[64] = (32 * _1954) + ceil32(return_data.size) + 544
                        require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                        _3115 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                        mem[(32 * _1954) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _1954) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                        mem[(32 * _1954) + ceil32(return_data.size) + 580] = _3115
                        mem[(32 * _1954) + ceil32(return_data.size) + 644] = this.address
                        mem[(32 * _1954) + ceil32(return_data.size) + 676] = block.timestamp
                        mem[(32 * _1954) + ceil32(return_data.size) + 612] = 160
                        mem[(32 * _1954) + ceil32(return_data.size) + 708] = 2
                        mem[(32 * _1954) + ceil32(return_data.size) + 740 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _3115, Array(len=2, data=mem[(32 * _1954) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _1954) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _1954) + (2 * ceil32(return_data.size)) + 544
                        require return_data.size >= 32
                        _4159 = mem[(32 * _1954) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                        require mem[(32 * _1954) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                        require mem[(32 * _1954) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                        require mem[mem[(32 * _1954) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1954) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _1954) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _1954) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1954) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                        mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _1954) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _1954) + ceil32(return_data.size) + 544]
                        _4204 = mem[_4159 + (32 * _1954) + ceil32(return_data.size) + 544]
                        mem[(32 * _1954) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_4159 + (32 * _1954) + ceil32(return_data.size) + 544])] = mem[_4159 + (32 * _1954) + ceil32(return_data.size) + 576 len floor32(mem[_4159 + (32 * _1954) + ceil32(return_data.size) + 544])]
                        mem[(32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 576] = 2
                        mem[(32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                        mem[(32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 640] = stor11
                        if rewardTokenAddress == stor11:
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, _3115, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                        else:
                            mem[(32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[(32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[(32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 708] = 64
                            mem[(32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 740] = 2
                            mem[(32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                            require ext_code.size(routerAddress)
                            staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[(32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 772 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 672
                            require return_data.size >= 32
                            _5868 = mem[(32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                            require mem[(32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[(32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[(32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                            mem[(32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 672]
                            _5891 = mem[_5868 + (32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 672]
                            mem[(32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_5868 + (32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 672])] = mem[_5868 + (32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_5868 + (32 * _4204) + (32 * _1954) + (2 * ceil32(return_data.size)) + 672])]
                            mem[64] = (32 * _5891) + (32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 704
                            require mem[(32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 672]
                            _6236 = mem[(32 * mem[(32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 704]
                            mem[(32 * _5891) + (32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(32 * _5891) + (32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[(32 * _5891) + (32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 740] = _6236
                            mem[(32 * _5891) + (32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 804] = this.address
                            mem[(32 * _5891) + (32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                            mem[(32 * _5891) + (32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 772] = 160
                            mem[(32 * _5891) + (32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 868] = 2
                            mem[(32 * _5891) + (32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _6236, Array(len=2, data=mem[(32 * _5891) + (32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _5891) + (32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _5891) + (32 * _4204) + (32 * _1954) + (6 * ceil32(return_data.size)) + 704
                            require return_data.size >= 32
                            require mem[(32 * _5891) + (32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[(32 * _5891) + (32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[(32 * _5891) + (32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5891) + (32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _5891) + (32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5891) + (32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5891) + (32 * _4204) + (32 * _1954) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, _3115, _6236, 0, 0, address(this.address), block.timestamp
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    if ext_call.return_data[64] <= 0:
        revert with 0, 'amount too low'
    require ext_code.size(stakingContractAddress)
    call stakingContractAddress.0xe2bbb158 with:
         gas gas_remaining wei
        args PID, ext_call.return_data[64]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if totalDeposits + ext_call.return_data[64] < totalDeposits:
        revert with 0, 'SafeMath: addition overflow'
    totalDeposits += ext_call.return_data[64]
    emit Reinvest(totalDeposits, totalSupply);
}

function deposit(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if totalDeposits < totalSupply:
        revert with 0, 'deposit failed'
    if not uint8(stor18):
        require ext_code.size(depositTokenAddress)
        call depositTokenAddress.0x23b872dd with:
             gas gas_remaining wei
            args msg.sender, address(this.address), arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            revert with 0, 'transferFrom failed'
        if arg1 <= 0:
            revert with 0, 'amount too low'
        require ext_code.size(stakingContractAddress)
        call stakingContractAddress.0xe2bbb158 with:
             gas gas_remaining wei
            args PID, arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if not totalSupply:
            if totalSupply + arg1 < totalSupply:
                revert with 0, 'SafeMath: addition overflow'
            totalSupply += arg1
            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                revert with 0, 'SafeMath: addition overflow'
            balanceOf[address(msg.sender)] += arg1
            emit Transfer(arg1, 0, msg.sender);
        else:
            require totalSupply
            if totalSupply * totalDeposits / totalSupply != totalDeposits:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if not totalSupply * totalDeposits:
                if totalSupply + arg1 < totalSupply:
                    revert with 0, 'SafeMath: addition overflow'
                totalSupply += arg1
                if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(msg.sender)] += arg1
                emit Transfer(arg1, 0, msg.sender);
            else:
                if not arg1:
                    if totalDeposits <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalDeposits
                    if totalSupply + (0 / totalDeposits) < totalSupply:
                        revert with 0, 'SafeMath: addition overflow'
                    totalSupply += 0 / totalDeposits
                    if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(msg.sender)] += 0 / totalDeposits
                    emit Transfer((0 / totalDeposits), 0, msg.sender);
                else:
                    require arg1
                    if arg1 * totalSupply / arg1 != totalSupply:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if totalDeposits <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalDeposits
                    if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                        revert with 0, 'SafeMath: addition overflow'
                    totalSupply += arg1 * totalSupply / totalDeposits
                    if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                    emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
    else:
        require ext_code.size(stakingContractAddress)
        staticcall stakingContractAddress.pendingOlive(uint256 rg1, address rg2) with:
                gas gas_remaining wei
               args PID, this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(rewardTokenAddress)
        staticcall rewardTokenAddress.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
            revert with 0, 'SafeMath: addition overflow'
        if 2 * ext_call.return_data[0] < MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT:
            require ext_code.size(depositTokenAddress)
            call depositTokenAddress.0x23b872dd with:
                 gas gas_remaining wei
                args msg.sender, address(this.address), arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'transferFrom failed'
            if arg1 <= 0:
                revert with 0, 'amount too low'
            require ext_code.size(stakingContractAddress)
            call stakingContractAddress.0xe2bbb158 with:
                 gas gas_remaining wei
                args PID, arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not totalSupply:
                if totalSupply + arg1 < totalSupply:
                    revert with 0, 'SafeMath: addition overflow'
                totalSupply += arg1
                if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(msg.sender)] += arg1
                emit Transfer(arg1, 0, msg.sender);
            else:
                require totalSupply
                if totalSupply * totalDeposits / totalSupply != totalDeposits:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if not totalSupply * totalDeposits:
                    if totalSupply + arg1 < totalSupply:
                        revert with 0, 'SafeMath: addition overflow'
                    totalSupply += arg1
                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(msg.sender)] += arg1
                    emit Transfer(arg1, 0, msg.sender);
                else:
                    if not arg1:
                        if totalDeposits <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalDeposits
                        if totalSupply + (0 / totalDeposits) < totalSupply:
                            revert with 0, 'SafeMath: addition overflow'
                        totalSupply += 0 / totalDeposits
                        if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(msg.sender)] += 0 / totalDeposits
                        emit Transfer((0 / totalDeposits), 0, msg.sender);
                    else:
                        require arg1
                        if arg1 * totalSupply / arg1 != totalSupply:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[197 len 31]
                        if totalDeposits <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalDeposits
                        if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                            revert with 0, 'SafeMath: addition overflow'
                        totalSupply += arg1 * totalSupply / totalDeposits
                        if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                        emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
        else:
            require ext_code.size(stakingContractAddress)
            call stakingContractAddress.0xe2bbb158 with:
                 gas gas_remaining wei
                args PID, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not uint255(ext_call.return_data[0]):
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if not uint255(ext_call.return_data[0]):
                    mem[160] = 26
                    mem[192] = 'SafeMath: division by zero'
                    mem[224] = 31
                    mem[256] = 'SafeMath: subtraction underflow'
                    if 0 > 2 * ext_call.return_data[0]:
                        revert with 0, 'SafeMath: subtraction underflow'
                    mem[288] = 31
                    mem[320] = 'SafeMath: subtraction underflow'
                    mem[352] = 26
                    mem[384] = 'SafeMath: division by zero'
                    if uint255(ext_call.return_data[0]) <= 0:
                        revert with 0, 'amount too low'
                    mem[416] = 2
                    mem[448] = rewardTokenAddress
                    mem[480] = stor10
                    if rewardTokenAddress == stor10:
                        mem[512] = 2
                        mem[544] = rewardTokenAddress
                        mem[576] = stor11
                        if rewardTokenAddress == stor11:
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, 2 * ext_call.return_data[0], 2 * ext_call.return_data[0], 0, 0, address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 96
                            if ext_call.return_data[64] <= 0:
                                revert with 0, 'amount too low'
                            require ext_code.size(stakingContractAddress)
                            call stakingContractAddress.0xe2bbb158 with:
                                 gas gas_remaining wei
                                args PID, ext_call.return_data[64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                revert with 0, 'SafeMath: addition overflow'
                            totalDeposits += ext_call.return_data[64]
                            emit Reinvest(totalDeposits, totalSupply);
                            require ext_code.size(depositTokenAddress)
                            call depositTokenAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                revert with 0, 'transferFrom failed'
                            if arg1 <= 0:
                                revert with 0, 'amount too low'
                            require ext_code.size(stakingContractAddress)
                            call stakingContractAddress.0xe2bbb158 with:
                                 gas gas_remaining wei
                                args PID, arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not totalSupply:
                                if totalSupply + arg1 < totalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalSupply += arg1
                                if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(msg.sender)] += arg1
                                emit Transfer(arg1, 0, msg.sender);
                            else:
                                require totalSupply
                                if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                2 * Mask(247, 0, ext_call.return_data[0])
                                if not totalSupply * totalDeposits:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    if not arg1:
                                        if totalDeposits <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalDeposits
                                        if totalSupply + (0 / totalDeposits) < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += 0 / totalDeposits
                                        if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += 0 / totalDeposits
                                        emit Transfer((0 / totalDeposits), 0, msg.sender);
                                    else:
                                        require arg1
                                        if arg1 * totalSupply / arg1 != totalSupply:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        2 * Mask(247, 0, ext_call.return_data[0])
                                        if totalDeposits <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalDeposits
                                        if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1 * totalSupply / totalDeposits
                                        if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                        emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                        else:
                            mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[612] = uint255(ext_call.return_data[0])
                            mem[644] = 64
                            mem[676] = 2
                            mem[708 len 0] = None
                            require ext_code.size(routerAddress)
                            staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args 2 * ext_call.return_data[0], Array(len=2, data=mem[708 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 608
                            require return_data.size >= 32
                            _4973 = mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31
                            require mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 <= 4294967296
                            require mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 32 <= return_data.size
                            require mem[mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * mem[mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 608]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 608]
                            _5011 = mem[_4973 + 608]
                            mem[ceil32(return_data.size) + 640 len floor32(mem[_4973 + 608])] = mem[_4973 + 640 len floor32(mem[_4973 + 608])]
                            mem[64] = (32 * _5011) + ceil32(return_data.size) + 640
                            require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                            _8299 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                            mem[(32 * _5011) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(32 * _5011) + ceil32(return_data.size) + 644] = uint255(ext_call.return_data[0])
                            mem[(32 * _5011) + ceil32(return_data.size) + 676] = _8299
                            mem[(32 * _5011) + ceil32(return_data.size) + 740] = this.address
                            mem[(32 * _5011) + ceil32(return_data.size) + 772] = block.timestamp
                            mem[(32 * _5011) + ceil32(return_data.size) + 708] = 160
                            mem[(32 * _5011) + ceil32(return_data.size) + 804] = 2
                            mem[(32 * _5011) + ceil32(return_data.size) + 836 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args 2 * ext_call.return_data[0], _8299, Array(len=2, data=mem[(32 * _5011) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _5011) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _5011) + (2 * ceil32(return_data.size)) + 640
                            require return_data.size >= 32
                            require mem[(32 * _5011) + ceil32(return_data.size) + 640 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 <= 4294967296
                            require mem[(32 * _5011) + ceil32(return_data.size) + 640 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 32 <= return_data.size
                            require mem[mem[(32 * _5011) + ceil32(return_data.size) + 640 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _5011) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _5011) + ceil32(return_data.size) + 640 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * mem[mem[(32 * _5011) + ceil32(return_data.size) + 640 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _5011) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, 2 * ext_call.return_data[0], _8299, 0, 0, address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 96
                            if ext_call.return_data[64] <= 0:
                                revert with 0, 'amount too low'
                            require ext_code.size(stakingContractAddress)
                            call stakingContractAddress.0xe2bbb158 with:
                                 gas gas_remaining wei
                                args PID, ext_call.return_data[64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                revert with 0, 'SafeMath: addition overflow'
                            totalDeposits += ext_call.return_data[64]
                            emit Reinvest(totalDeposits, totalSupply);
                            require ext_code.size(depositTokenAddress)
                            call depositTokenAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                revert with 0, 'transferFrom failed'
                            if arg1 <= 0:
                                revert with 0, 'amount too low'
                            require ext_code.size(stakingContractAddress)
                            call stakingContractAddress.0xe2bbb158 with:
                                 gas gas_remaining wei
                                args PID, arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not totalSupply:
                                if totalSupply + arg1 < totalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalSupply += arg1
                                if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(msg.sender)] += arg1
                                emit Transfer(arg1, 0, msg.sender);
                            else:
                                require totalSupply
                                if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8299)
                                if not totalSupply * totalDeposits:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    if not arg1:
                                        if totalDeposits <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalDeposits
                                        if totalSupply + (0 / totalDeposits) < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += 0 / totalDeposits
                                        if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += 0 / totalDeposits
                                        emit Transfer((0 / totalDeposits), 0, msg.sender);
                                    else:
                                        require arg1
                                        if arg1 * totalSupply / arg1 != totalSupply:
                                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8299)
                                        if totalDeposits <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalDeposits
                                        if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1 * totalSupply / totalDeposits
                                        if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                        emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                    else:
                        mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[516] = uint255(ext_call.return_data[0])
                        mem[548] = 64
                        mem[580] = 2
                        mem[612 len 0] = None
                        require ext_code.size(routerAddress)
                        staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args 2 * ext_call.return_data[0], Array(len=2, data=mem[612 len 64])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + 512
                        require return_data.size >= 32
                        _4975 = mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31
                        require mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 <= 4294967296
                        require mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 32 <= return_data.size
                        require mem[mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * mem[mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 512]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 512]
                        _5012 = mem[_4975 + 512]
                        mem[ceil32(return_data.size) + 544 len floor32(mem[_4975 + 512])] = mem[_4975 + 544 len floor32(mem[_4975 + 512])]
                        mem[64] = (32 * _5012) + ceil32(return_data.size) + 544
                        require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                        _8303 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                        mem[(32 * _5012) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _5012) + ceil32(return_data.size) + 548] = uint255(ext_call.return_data[0])
                        mem[(32 * _5012) + ceil32(return_data.size) + 580] = _8303
                        mem[(32 * _5012) + ceil32(return_data.size) + 644] = this.address
                        mem[(32 * _5012) + ceil32(return_data.size) + 676] = block.timestamp
                        mem[(32 * _5012) + ceil32(return_data.size) + 612] = 160
                        mem[(32 * _5012) + ceil32(return_data.size) + 708] = 2
                        mem[(32 * _5012) + ceil32(return_data.size) + 740 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args 2 * ext_call.return_data[0], _8303, Array(len=2, data=mem[(32 * _5012) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _5012) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _5012) + (2 * ceil32(return_data.size)) + 544
                        require return_data.size >= 32
                        _11437 = mem[(32 * _5012) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31
                        require mem[(32 * _5012) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 <= 4294967296
                        require mem[(32 * _5012) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 32 <= return_data.size
                        require mem[mem[(32 * _5012) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _5012) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _5012) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * mem[mem[(32 * _5012) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _5012) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                        mem[(32 * _5012) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _5012) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _5012) + ceil32(return_data.size) + 544]
                        _11474 = mem[_11437 + (32 * _5012) + ceil32(return_data.size) + 544]
                        mem[(32 * _5012) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_11437 + (32 * _5012) + ceil32(return_data.size) + 544])] = mem[_11437 + (32 * _5012) + ceil32(return_data.size) + 576 len floor32(mem[_11437 + (32 * _5012) + ceil32(return_data.size) + 544])]
                        mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 576] = 2
                        mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                        mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 640] = stor11
                        if rewardTokenAddress == stor11:
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, _8303, 2 * ext_call.return_data[0], 0, 0, address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 96
                            if ext_call.return_data[64] <= 0:
                                revert with 0, 'amount too low'
                            require ext_code.size(stakingContractAddress)
                            call stakingContractAddress.0xe2bbb158 with:
                                 gas gas_remaining wei
                                args PID, ext_call.return_data[64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                revert with 0, 'SafeMath: addition overflow'
                            totalDeposits += ext_call.return_data[64]
                            emit Reinvest(totalDeposits, totalSupply);
                            require ext_code.size(depositTokenAddress)
                            call depositTokenAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                revert with 0, 'transferFrom failed'
                            if arg1 <= 0:
                                revert with 0, 'amount too low'
                            require ext_code.size(stakingContractAddress)
                            call stakingContractAddress.0xe2bbb158 with:
                                 gas gas_remaining wei
                                args PID, arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not totalSupply:
                                if totalSupply + arg1 < totalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalSupply += arg1
                                if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(msg.sender)] += arg1
                                emit Transfer(arg1, 0, msg.sender);
                            else:
                                require totalSupply
                                if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                2 * Mask(247, 0, ext_call.return_data[0])
                                if not totalSupply * totalDeposits:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    if not arg1:
                                        if totalDeposits <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalDeposits
                                        if totalSupply + (0 / totalDeposits) < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += 0 / totalDeposits
                                        if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += 0 / totalDeposits
                                        emit Transfer((0 / totalDeposits), 0, msg.sender);
                                    else:
                                        require arg1
                                        if arg1 * totalSupply / arg1 != totalSupply:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        2 * Mask(247, 0, ext_call.return_data[0])
                                        if totalDeposits <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalDeposits
                                        if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1 * totalSupply / totalDeposits
                                        if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                        emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                        else:
                            mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 676] = uint255(ext_call.return_data[0])
                            mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 708] = 64
                            mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 740] = 2
                            mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                            require ext_code.size(routerAddress)
                            staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args 2 * ext_call.return_data[0], Array(len=2, data=mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 772 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 672
                            require return_data.size >= 32
                            _17494 = mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31
                            require mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 <= 4294967296
                            require mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 32 <= return_data.size
                            require mem[mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * mem[mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                            mem[(32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672]
                            _17513 = mem[_17494 + (32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672]
                            mem[(32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_17494 + (32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672])] = mem[_17494 + (32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_17494 + (32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672])]
                            mem[64] = (32 * _17513) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704
                            require mem[(32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 672]
                            _18572 = mem[(32 * mem[(32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704]
                            mem[(32 * _17513) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(32 * _17513) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 708] = uint255(ext_call.return_data[0])
                            mem[(32 * _17513) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 740] = _18572
                            mem[(32 * _17513) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 804] = this.address
                            mem[(32 * _17513) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                            mem[(32 * _17513) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 772] = 160
                            mem[(32 * _17513) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 868] = 2
                            mem[(32 * _17513) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args 2 * ext_call.return_data[0], _18572, Array(len=2, data=mem[(32 * _17513) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _17513) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _17513) + (32 * _11474) + (32 * _5012) + (6 * ceil32(return_data.size)) + 704
                            require return_data.size >= 32
                            require mem[(32 * _17513) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 <= 4294967296
                            require mem[(32 * _17513) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 32 <= return_data.size
                            require mem[mem[(32 * _17513) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _17513) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _17513) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * mem[mem[(32 * _17513) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _17513) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, _8303, _18572, 0, 0, address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 96
                            if ext_call.return_data[64] <= 0:
                                revert with 0, 'amount too low'
                            require ext_code.size(stakingContractAddress)
                            call stakingContractAddress.0xe2bbb158 with:
                                 gas gas_remaining wei
                                args PID, ext_call.return_data[64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                revert with 0, 'SafeMath: addition overflow'
                            totalDeposits += ext_call.return_data[64]
                            emit Reinvest(totalDeposits, totalSupply);
                            require ext_code.size(depositTokenAddress)
                            call depositTokenAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                revert with 0, 'transferFrom failed'
                            if arg1 <= 0:
                                revert with 0, 'amount too low'
                            require ext_code.size(stakingContractAddress)
                            call stakingContractAddress.0xe2bbb158 with:
                                 gas gas_remaining wei
                                args PID, arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not totalSupply:
                                if totalSupply + arg1 < totalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalSupply += arg1
                                if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(msg.sender)] += arg1
                                emit Transfer(arg1, 0, msg.sender);
                            else:
                                require totalSupply
                                if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18572)
                                if not totalSupply * totalDeposits:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    if not arg1:
                                        if totalDeposits <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalDeposits
                                        if totalSupply + (0 / totalDeposits) < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += 0 / totalDeposits
                                        if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += 0 / totalDeposits
                                        emit Transfer((0 / totalDeposits), 0, msg.sender);
                                    else:
                                        require arg1
                                        if arg1 * totalSupply / arg1 != totalSupply:
                                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18572)
                                        if totalDeposits <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalDeposits
                                        if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1 * totalSupply / totalDeposits
                                        if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                        emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                else:
                    require 2 * ext_call.return_data[0]
                    if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 2 * ext_call.return_data[0] != REINVEST_REWARD_BIPS:
                        revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    mem[160] = 26
                    mem[192] = 'SafeMath: division by zero'
                    if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 <= 0:
                        mem[224] = 31
                        mem[256] = 'SafeMath: subtraction underflow'
                        if 0 > 2 * ext_call.return_data[0]:
                            revert with 0, 'SafeMath: subtraction underflow'
                        mem[288] = 31
                        mem[320] = 'SafeMath: subtraction underflow'
                        if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                            revert with 0, 'SafeMath: subtraction underflow'
                        mem[352] = 26
                        mem[384] = 'SafeMath: division by zero'
                        if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2 <= 0:
                            revert with 0, 'amount too low'
                        mem[416] = 2
                        mem[448] = rewardTokenAddress
                        mem[480] = stor10
                        if rewardTokenAddress == stor10:
                            mem[512] = 2
                            mem[544] = rewardTokenAddress
                            mem[576] = stor11
                            if rewardTokenAddress == stor11:
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[644] = 64
                                mem[676] = 2
                                mem[708 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 608
                                require return_data.size >= 32
                                _4965 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]
                                _5007 = mem[_4965 + 608]
                                mem[ceil32(return_data.size) + 640 len floor32(mem[_4965 + 608])] = mem[_4965 + 640 len floor32(mem[_4965 + 608])]
                                mem[64] = (32 * _5007) + ceil32(return_data.size) + 640
                                require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                                _8283 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                                mem[(32 * _5007) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _5007) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[(32 * _5007) + ceil32(return_data.size) + 676] = _8283
                                mem[(32 * _5007) + ceil32(return_data.size) + 740] = this.address
                                mem[(32 * _5007) + ceil32(return_data.size) + 772] = block.timestamp
                                mem[(32 * _5007) + ceil32(return_data.size) + 708] = 160
                                mem[(32 * _5007) + ceil32(return_data.size) + 804] = 2
                                mem[(32 * _5007) + ceil32(return_data.size) + 836 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8283, Array(len=2, data=mem[(32 * _5007) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _5007) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _5007) + (2 * ceil32(return_data.size)) + 640
                                require return_data.size >= 32
                                require mem[(32 * _5007) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _5007) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _5007) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5007) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _5007) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5007) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5007) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8283, 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8283)
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8283)
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                        else:
                            mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[548] = 64
                            mem[580] = 2
                            mem[612 len 0] = None
                            require ext_code.size(routerAddress)
                            staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 512
                            require return_data.size >= 32
                            _4967 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                            require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]
                            _5008 = mem[_4967 + 512]
                            mem[ceil32(return_data.size) + 544 len floor32(mem[_4967 + 512])] = mem[_4967 + 544 len floor32(mem[_4967 + 512])]
                            mem[64] = (32 * _5008) + ceil32(return_data.size) + 544
                            require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                            _8287 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                            mem[(32 * _5008) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(32 * _5008) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[(32 * _5008) + ceil32(return_data.size) + 580] = _8287
                            mem[(32 * _5008) + ceil32(return_data.size) + 644] = this.address
                            mem[(32 * _5008) + ceil32(return_data.size) + 676] = block.timestamp
                            mem[(32 * _5008) + ceil32(return_data.size) + 612] = 160
                            mem[(32 * _5008) + ceil32(return_data.size) + 708] = 2
                            mem[(32 * _5008) + ceil32(return_data.size) + 740 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8287, Array(len=2, data=mem[(32 * _5008) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _5008) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _5008) + (2 * ceil32(return_data.size)) + 544
                            require return_data.size >= 32
                            _11429 = mem[(32 * _5008) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                            require mem[(32 * _5008) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[(32 * _5008) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[(32 * _5008) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5008) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _5008) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5008) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5008) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                            mem[(32 * _5008) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _5008) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5008) + ceil32(return_data.size) + 544]
                            _11470 = mem[_11429 + (32 * _5008) + ceil32(return_data.size) + 544]
                            mem[(32 * _5008) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_11429 + (32 * _5008) + ceil32(return_data.size) + 544])] = mem[_11429 + (32 * _5008) + ceil32(return_data.size) + 576 len floor32(mem[_11429 + (32 * _5008) + ceil32(return_data.size) + 544])]
                            mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 576] = 2
                            mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                            mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 640] = stor11
                            if rewardTokenAddress == stor11:
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, _8287, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 708] = 64
                                mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 740] = 2
                                mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 772 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 672
                                require return_data.size >= 32
                                _17490 = mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                                mem[(32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672]
                                _17511 = mem[_17490 + (32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672]
                                mem[(32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_17490 + (32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672])] = mem[_17490 + (32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_17490 + (32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672])]
                                mem[64] = (32 * _17511) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704
                                require mem[(32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 672]
                                _18564 = mem[(32 * mem[(32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704]
                                mem[(32 * _17511) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _17511) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[(32 * _17511) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 740] = _18564
                                mem[(32 * _17511) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 804] = this.address
                                mem[(32 * _17511) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                                mem[(32 * _17511) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 772] = 160
                                mem[(32 * _17511) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 868] = 2
                                mem[(32 * _17511) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _18564, Array(len=2, data=mem[(32 * _17511) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _17511) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _17511) + (32 * _11470) + (32 * _5008) + (6 * ceil32(return_data.size)) + 704
                                require return_data.size >= 32
                                require mem[(32 * _17511) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _17511) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _17511) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17511) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _17511) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _17511) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17511) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, _8287, _18564, 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18564)
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18564)
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                    else:
                        require ext_code.size(rewardTokenAddress)
                        call rewardTokenAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'reinvest fee transfer failed'
                        mem[224] = 31
                        mem[256] = 'SafeMath: subtraction underflow'
                        if 0 > 2 * ext_call.return_data[0]:
                            revert with 0, 'SafeMath: subtraction underflow'
                        mem[288] = 31
                        mem[320] = 'SafeMath: subtraction underflow'
                        if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                            revert with 0, 'SafeMath: subtraction underflow'
                        mem[352] = 26
                        mem[384] = 'SafeMath: division by zero'
                        if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2 <= 0:
                            revert with 0, 'amount too low'
                        mem[416] = 2
                        mem[448] = rewardTokenAddress
                        mem[480] = stor10
                        if rewardTokenAddress == stor10:
                            mem[512] = 2
                            mem[544] = rewardTokenAddress
                            mem[576] = stor11
                            if rewardTokenAddress == stor11:
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[644] = 64
                                mem[676] = 2
                                mem[708 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 608
                                require return_data.size >= 32
                                _4969 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]
                                _5009 = mem[_4969 + 608]
                                mem[ceil32(return_data.size) + 640 len floor32(mem[_4969 + 608])] = mem[_4969 + 640 len floor32(mem[_4969 + 608])]
                                mem[64] = (32 * _5009) + ceil32(return_data.size) + 640
                                require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                                _8291 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                                mem[(32 * _5009) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _5009) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[(32 * _5009) + ceil32(return_data.size) + 676] = _8291
                                mem[(32 * _5009) + ceil32(return_data.size) + 740] = this.address
                                mem[(32 * _5009) + ceil32(return_data.size) + 772] = block.timestamp
                                mem[(32 * _5009) + ceil32(return_data.size) + 708] = 160
                                mem[(32 * _5009) + ceil32(return_data.size) + 804] = 2
                                mem[(32 * _5009) + ceil32(return_data.size) + 836 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8291, Array(len=2, data=mem[(32 * _5009) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _5009) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _5009) + (2 * ceil32(return_data.size)) + 640
                                require return_data.size >= 32
                                require mem[(32 * _5009) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _5009) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _5009) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5009) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _5009) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5009) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5009) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8291, 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8291)
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8291)
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                        else:
                            mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[548] = 64
                            mem[580] = 2
                            mem[612 len 0] = None
                            require ext_code.size(routerAddress)
                            staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 512
                            require return_data.size >= 32
                            _4971 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                            require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]
                            _5010 = mem[_4971 + 512]
                            mem[ceil32(return_data.size) + 544 len floor32(mem[_4971 + 512])] = mem[_4971 + 544 len floor32(mem[_4971 + 512])]
                            mem[64] = (32 * _5010) + ceil32(return_data.size) + 544
                            require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                            _8295 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                            mem[(32 * _5010) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(32 * _5010) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[(32 * _5010) + ceil32(return_data.size) + 580] = _8295
                            mem[(32 * _5010) + ceil32(return_data.size) + 644] = this.address
                            mem[(32 * _5010) + ceil32(return_data.size) + 676] = block.timestamp
                            mem[(32 * _5010) + ceil32(return_data.size) + 612] = 160
                            mem[(32 * _5010) + ceil32(return_data.size) + 708] = 2
                            mem[(32 * _5010) + ceil32(return_data.size) + 740 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8295, Array(len=2, data=mem[(32 * _5010) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _5010) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _5010) + (2 * ceil32(return_data.size)) + 544
                            require return_data.size >= 32
                            _11433 = mem[(32 * _5010) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                            require mem[(32 * _5010) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[(32 * _5010) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[(32 * _5010) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5010) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _5010) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5010) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5010) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                            mem[(32 * _5010) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _5010) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5010) + ceil32(return_data.size) + 544]
                            _11472 = mem[_11433 + (32 * _5010) + ceil32(return_data.size) + 544]
                            mem[(32 * _5010) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_11433 + (32 * _5010) + ceil32(return_data.size) + 544])] = mem[_11433 + (32 * _5010) + ceil32(return_data.size) + 576 len floor32(mem[_11433 + (32 * _5010) + ceil32(return_data.size) + 544])]
                            mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 576] = 2
                            mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                            mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 640] = stor11
                            if rewardTokenAddress == stor11:
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, _8295, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 708] = 64
                                mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 740] = 2
                                mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 772 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 672
                                require return_data.size >= 32
                                _17492 = mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                                mem[(32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672]
                                _17512 = mem[_17492 + (32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672]
                                mem[(32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_17492 + (32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672])] = mem[_17492 + (32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_17492 + (32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672])]
                                mem[64] = (32 * _17512) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704
                                require mem[(32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 672]
                                _18568 = mem[(32 * mem[(32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704]
                                mem[(32 * _17512) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _17512) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[(32 * _17512) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 740] = _18568
                                mem[(32 * _17512) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 804] = this.address
                                mem[(32 * _17512) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                                mem[(32 * _17512) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 772] = 160
                                mem[(32 * _17512) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 868] = 2
                                mem[(32 * _17512) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _18568, Array(len=2, data=mem[(32 * _17512) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _17512) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _17512) + (32 * _11472) + (32 * _5010) + (6 * ceil32(return_data.size)) + 704
                                require return_data.size >= 32
                                require mem[(32 * _17512) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _17512) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _17512) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17512) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _17512) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _17512) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17512) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, _8295, _18568, 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18568)
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18568)
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
            else:
                require 2 * ext_call.return_data[0]
                if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 2 * ext_call.return_data[0] != ADMIN_FEE_BIPS:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 <= 0:
                    if not uint255(ext_call.return_data[0]):
                        mem[160] = 26
                        mem[192] = 'SafeMath: division by zero'
                        mem[224] = 31
                        mem[256] = 'SafeMath: subtraction underflow'
                        if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                            revert with 0, 'SafeMath: subtraction underflow'
                        mem[288] = 31
                        mem[320] = 'SafeMath: subtraction underflow'
                        if 0 > (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000):
                            revert with 0, 'SafeMath: subtraction underflow'
                        mem[352] = 26
                        mem[384] = 'SafeMath: division by zero'
                        if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2 <= 0:
                            revert with 0, 'amount too low'
                        mem[416] = 2
                        mem[448] = rewardTokenAddress
                        mem[480] = stor10
                        if rewardTokenAddress == stor10:
                            mem[512] = 2
                            mem[544] = rewardTokenAddress
                            mem[576] = stor11
                            if rewardTokenAddress == stor11:
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000))
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000))
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                                mem[644] = 64
                                mem[676] = 2
                                mem[708 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 608
                                require return_data.size >= 32
                                _4949 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                                require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 608]
                                _4999 = mem[_4949 + 608]
                                mem[ceil32(return_data.size) + 640 len floor32(mem[_4949 + 608])] = mem[_4949 + 640 len floor32(mem[_4949 + 608])]
                                mem[64] = (32 * _4999) + ceil32(return_data.size) + 640
                                require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                                _8251 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                                mem[(32 * _4999) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _4999) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                                mem[(32 * _4999) + ceil32(return_data.size) + 676] = _8251
                                mem[(32 * _4999) + ceil32(return_data.size) + 740] = this.address
                                mem[(32 * _4999) + ceil32(return_data.size) + 772] = block.timestamp
                                mem[(32 * _4999) + ceil32(return_data.size) + 708] = 160
                                mem[(32 * _4999) + ceil32(return_data.size) + 804] = 2
                                mem[(32 * _4999) + ceil32(return_data.size) + 836 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _8251, Array(len=2, data=mem[(32 * _4999) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _4999) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _4999) + (2 * ceil32(return_data.size)) + 640
                                require return_data.size >= 32
                                require mem[(32 * _4999) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _4999) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _4999) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _4999) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _4999) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _4999) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _4999) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _8251, 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8251)
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8251)
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                        else:
                            mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                            mem[548] = 64
                            mem[580] = 2
                            mem[612 len 0] = None
                            require ext_code.size(routerAddress)
                            staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 512
                            require return_data.size >= 32
                            _4951 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                            require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 512]
                            _5000 = mem[_4951 + 512]
                            mem[ceil32(return_data.size) + 544 len floor32(mem[_4951 + 512])] = mem[_4951 + 544 len floor32(mem[_4951 + 512])]
                            mem[64] = (32 * _5000) + ceil32(return_data.size) + 544
                            require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                            _8255 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                            mem[(32 * _5000) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(32 * _5000) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                            mem[(32 * _5000) + ceil32(return_data.size) + 580] = _8255
                            mem[(32 * _5000) + ceil32(return_data.size) + 644] = this.address
                            mem[(32 * _5000) + ceil32(return_data.size) + 676] = block.timestamp
                            mem[(32 * _5000) + ceil32(return_data.size) + 612] = 160
                            mem[(32 * _5000) + ceil32(return_data.size) + 708] = 2
                            mem[(32 * _5000) + ceil32(return_data.size) + 740 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _8255, Array(len=2, data=mem[(32 * _5000) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _5000) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _5000) + (2 * ceil32(return_data.size)) + 544
                            require return_data.size >= 32
                            _11413 = mem[(32 * _5000) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                            require mem[(32 * _5000) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[(32 * _5000) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[(32 * _5000) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5000) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _5000) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5000) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5000) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                            mem[(32 * _5000) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _5000) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5000) + ceil32(return_data.size) + 544]
                            _11462 = mem[_11413 + (32 * _5000) + ceil32(return_data.size) + 544]
                            mem[(32 * _5000) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_11413 + (32 * _5000) + ceil32(return_data.size) + 544])] = mem[_11413 + (32 * _5000) + ceil32(return_data.size) + 576 len floor32(mem[_11413 + (32 * _5000) + ceil32(return_data.size) + 544])]
                            mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 576] = 2
                            mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                            mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 640] = stor11
                            if rewardTokenAddress == stor11:
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, _8255, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000))
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000))
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                                mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 708] = 64
                                mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 740] = 2
                                mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Array(len=2, data=mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 772 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 672
                                require return_data.size >= 32
                                _17482 = mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                                require mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                                mem[(32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672]
                                _17507 = mem[_17482 + (32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672]
                                mem[(32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_17482 + (32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672])] = mem[_17482 + (32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_17482 + (32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672])]
                                mem[64] = (32 * _17507) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704
                                require mem[(32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 672]
                                _18548 = mem[(32 * mem[(32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704]
                                mem[(32 * _17507) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _17507) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                                mem[(32 * _17507) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 740] = _18548
                                mem[(32 * _17507) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 804] = this.address
                                mem[(32 * _17507) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                                mem[(32 * _17507) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 772] = 160
                                mem[(32 * _17507) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 868] = 2
                                mem[(32 * _17507) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _18548, Array(len=2, data=mem[(32 * _17507) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _17507) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _17507) + (32 * _11462) + (32 * _5000) + (6 * ceil32(return_data.size)) + 704
                                require return_data.size >= 32
                                require mem[(32 * _17507) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _17507) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _17507) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _17507) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _17507) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _17507) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _17507) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, _8255, _18548, 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18548)
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18548)
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                    else:
                        require 2 * ext_call.return_data[0]
                        if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 2 * ext_call.return_data[0] != REINVEST_REWARD_BIPS:
                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        mem[160] = 26
                        mem[192] = 'SafeMath: division by zero'
                        if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 <= 0:
                            mem[224] = 31
                            mem[256] = 'SafeMath: subtraction underflow'
                            if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                                revert with 0, 'SafeMath: subtraction underflow'
                            mem[288] = 31
                            mem[320] = 'SafeMath: subtraction underflow'
                            if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 > (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000):
                                revert with 0, 'SafeMath: subtraction underflow'
                            mem[352] = 26
                            mem[384] = 'SafeMath: division by zero'
                            if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2 <= 0:
                                revert with 0, 'amount too low'
                            mem[416] = 2
                            mem[448] = rewardTokenAddress
                            mem[480] = stor10
                            if rewardTokenAddress == stor10:
                                mem[512] = 2
                                mem[544] = rewardTokenAddress
                                mem[576] = stor11
                                if rewardTokenAddress == stor11:
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                                else:
                                    mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[644] = 64
                                    mem[676] = 2
                                    mem[708 len 0] = None
                                    require ext_code.size(routerAddress)
                                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(return_data.size) + 608
                                    require return_data.size >= 32
                                    _4941 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                    require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                                    mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]
                                    _4995 = mem[_4941 + 608]
                                    mem[ceil32(return_data.size) + 640 len floor32(mem[_4941 + 608])] = mem[_4941 + 640 len floor32(mem[_4941 + 608])]
                                    mem[64] = (32 * _4995) + ceil32(return_data.size) + 640
                                    require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                                    _8235 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                                    mem[(32 * _4995) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _4995) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _4995) + ceil32(return_data.size) + 676] = _8235
                                    mem[(32 * _4995) + ceil32(return_data.size) + 740] = this.address
                                    mem[(32 * _4995) + ceil32(return_data.size) + 772] = block.timestamp
                                    mem[(32 * _4995) + ceil32(return_data.size) + 708] = 160
                                    mem[(32 * _4995) + ceil32(return_data.size) + 804] = 2
                                    mem[(32 * _4995) + ceil32(return_data.size) + 836 len 0] = None
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8235, Array(len=2, data=mem[(32 * _4995) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _4995) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _4995) + (2 * ceil32(return_data.size)) + 640
                                    require return_data.size >= 32
                                    require mem[(32 * _4995) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _4995) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _4995) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4995) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _4995) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _4995) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4995) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8235, 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8235)
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8235)
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[548] = 64
                                mem[580] = 2
                                mem[612 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 512
                                require return_data.size >= 32
                                _4943 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]
                                _4996 = mem[_4943 + 512]
                                mem[ceil32(return_data.size) + 544 len floor32(mem[_4943 + 512])] = mem[_4943 + 544 len floor32(mem[_4943 + 512])]
                                mem[64] = (32 * _4996) + ceil32(return_data.size) + 544
                                require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                                _8239 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                                mem[(32 * _4996) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _4996) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[(32 * _4996) + ceil32(return_data.size) + 580] = _8239
                                mem[(32 * _4996) + ceil32(return_data.size) + 644] = this.address
                                mem[(32 * _4996) + ceil32(return_data.size) + 676] = block.timestamp
                                mem[(32 * _4996) + ceil32(return_data.size) + 612] = 160
                                mem[(32 * _4996) + ceil32(return_data.size) + 708] = 2
                                mem[(32 * _4996) + ceil32(return_data.size) + 740 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8239, Array(len=2, data=mem[(32 * _4996) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _4996) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _4996) + (2 * ceil32(return_data.size)) + 544
                                require return_data.size >= 32
                                _11405 = mem[(32 * _4996) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[(32 * _4996) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _4996) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _4996) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4996) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _4996) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _4996) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4996) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                                mem[(32 * _4996) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _4996) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4996) + ceil32(return_data.size) + 544]
                                _11458 = mem[_11405 + (32 * _4996) + ceil32(return_data.size) + 544]
                                mem[(32 * _4996) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_11405 + (32 * _4996) + ceil32(return_data.size) + 544])] = mem[_11405 + (32 * _4996) + ceil32(return_data.size) + 576 len floor32(mem[_11405 + (32 * _4996) + ceil32(return_data.size) + 544])]
                                mem[(32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 576] = 2
                                mem[(32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                                mem[(32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 640] = stor11
                                if rewardTokenAddress == stor11:
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, _8239, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                                else:
                                    mem[(32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 708] = 64
                                    mem[(32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 740] = 2
                                    mem[(32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                                    require ext_code.size(routerAddress)
                                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[(32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 772 len 64])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 672
                                    require return_data.size >= 32
                                    _17478 = mem[(32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                    require mem[(32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                                    mem[(32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 672]
                                    _17505 = mem[_17478 + (32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 672]
                                    mem[(32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_17478 + (32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 672])] = mem[_17478 + (32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_17478 + (32 * _11458) + (32 * _4996) + (2 * ceil32(return_data.size)) + 672])]
                                    require mem[(32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 672]
                                    _18540 = mem[(32 * mem[(32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 704]
                                    mem[(32 * _17505) + (32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _17505) + (32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _17505) + (32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 740] = _18540
                                    mem[(32 * _17505) + (32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 804] = this.address
                                    mem[(32 * _17505) + (32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                                    mem[(32 * _17505) + (32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 772] = 160
                                    mem[(32 * _17505) + (32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 868] = 2
                                    mem[(32 * _17505) + (32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _18540, Array(len=2, data=mem[(32 * _17505) + (32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _17505) + (32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _17505) + (32 * _11458) + (32 * _4996) + (6 * ceil32(return_data.size)) + 704
                                    require return_data.size >= 32
                                    require mem[(32 * _17505) + (32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _17505) + (32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _17505) + (32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17505) + (32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _17505) + (32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _17505) + (32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17505) + (32 * _11458) + (32 * _4996) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, _8239, _18540, 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18540)
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18540)
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                        else:
                            require ext_code.size(rewardTokenAddress)
                            call rewardTokenAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                revert with 0, 'reinvest fee transfer failed'
                            mem[224] = 31
                            mem[256] = 'SafeMath: subtraction underflow'
                            if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                                revert with 0, 'SafeMath: subtraction underflow'
                            mem[288] = 31
                            mem[320] = 'SafeMath: subtraction underflow'
                            if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 > (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000):
                                revert with 0, 'SafeMath: subtraction underflow'
                            mem[352] = 26
                            mem[384] = 'SafeMath: division by zero'
                            if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2 <= 0:
                                revert with 0, 'amount too low'
                            mem[416] = 2
                            mem[448] = rewardTokenAddress
                            mem[480] = stor10
                            if rewardTokenAddress == stor10:
                                mem[512] = 2
                                mem[544] = rewardTokenAddress
                                mem[576] = stor11
                                if rewardTokenAddress == stor11:
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                                else:
                                    mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[644] = 64
                                    mem[676] = 2
                                    mem[708 len 0] = None
                                    require ext_code.size(routerAddress)
                                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(return_data.size) + 608
                                    require return_data.size >= 32
                                    _4945 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                    require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                                    mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]
                                    _4997 = mem[_4945 + 608]
                                    mem[ceil32(return_data.size) + 640 len floor32(mem[_4945 + 608])] = mem[_4945 + 640 len floor32(mem[_4945 + 608])]
                                    mem[64] = (32 * _4997) + ceil32(return_data.size) + 640
                                    require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                                    _8243 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                                    mem[(32 * _4997) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _4997) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _4997) + ceil32(return_data.size) + 676] = _8243
                                    mem[(32 * _4997) + ceil32(return_data.size) + 740] = this.address
                                    mem[(32 * _4997) + ceil32(return_data.size) + 772] = block.timestamp
                                    mem[(32 * _4997) + ceil32(return_data.size) + 708] = 160
                                    mem[(32 * _4997) + ceil32(return_data.size) + 804] = 2
                                    mem[(32 * _4997) + ceil32(return_data.size) + 836 len 0] = None
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8243, Array(len=2, data=mem[(32 * _4997) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _4997) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _4997) + (2 * ceil32(return_data.size)) + 640
                                    require return_data.size >= 32
                                    require mem[(32 * _4997) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _4997) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _4997) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4997) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _4997) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _4997) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4997) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8243, 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8243)
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8243)
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[548] = 64
                                mem[580] = 2
                                mem[612 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 512
                                require return_data.size >= 32
                                _4947 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]
                                _4998 = mem[_4947 + 512]
                                mem[ceil32(return_data.size) + 544 len floor32(mem[_4947 + 512])] = mem[_4947 + 544 len floor32(mem[_4947 + 512])]
                                mem[64] = (32 * _4998) + ceil32(return_data.size) + 544
                                require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                                _8247 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                                mem[(32 * _4998) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _4998) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[(32 * _4998) + ceil32(return_data.size) + 580] = _8247
                                mem[(32 * _4998) + ceil32(return_data.size) + 644] = this.address
                                mem[(32 * _4998) + ceil32(return_data.size) + 676] = block.timestamp
                                mem[(32 * _4998) + ceil32(return_data.size) + 612] = 160
                                mem[(32 * _4998) + ceil32(return_data.size) + 708] = 2
                                mem[(32 * _4998) + ceil32(return_data.size) + 740 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8247, Array(len=2, data=mem[(32 * _4998) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _4998) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _4998) + (2 * ceil32(return_data.size)) + 544
                                require return_data.size >= 32
                                _11409 = mem[(32 * _4998) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[(32 * _4998) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _4998) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _4998) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4998) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _4998) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _4998) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4998) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                                mem[(32 * _4998) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _4998) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4998) + ceil32(return_data.size) + 544]
                                _11460 = mem[_11409 + (32 * _4998) + ceil32(return_data.size) + 544]
                                mem[(32 * _4998) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_11409 + (32 * _4998) + ceil32(return_data.size) + 544])] = mem[_11409 + (32 * _4998) + ceil32(return_data.size) + 576 len floor32(mem[_11409 + (32 * _4998) + ceil32(return_data.size) + 544])]
                                mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 576] = 2
                                mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                                mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 640] = stor11
                                if rewardTokenAddress == stor11:
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, _8247, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                                else:
                                    mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 708] = 64
                                    mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 740] = 2
                                    mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                                    require ext_code.size(routerAddress)
                                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 772 len 64])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 672
                                    require return_data.size >= 32
                                    _17480 = mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                    require mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                                    mem[(32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672]
                                    _17506 = mem[_17480 + (32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672]
                                    mem[(32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_17480 + (32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672])] = mem[_17480 + (32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_17480 + (32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672])]
                                    mem[64] = (32 * _17506) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704
                                    require mem[(32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 672]
                                    _18544 = mem[(32 * mem[(32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704]
                                    mem[(32 * _17506) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _17506) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _17506) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 740] = _18544
                                    mem[(32 * _17506) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 804] = this.address
                                    mem[(32 * _17506) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                                    mem[(32 * _17506) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 772] = 160
                                    mem[(32 * _17506) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 868] = 2
                                    mem[(32 * _17506) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _18544, Array(len=2, data=mem[(32 * _17506) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _17506) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _17506) + (32 * _11460) + (32 * _4998) + (6 * ceil32(return_data.size)) + 704
                                    require return_data.size >= 32
                                    require mem[(32 * _17506) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _17506) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _17506) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17506) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _17506) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _17506) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17506) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, _8247, _18544, 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18544)
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18544)
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                else:
                    require ext_code.size(rewardTokenAddress)
                    call rewardTokenAddress.0xa9059cbb with:
                         gas gas_remaining wei
                        args owner, (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0, 'admin fee transfer failed'
                    if not uint255(ext_call.return_data[0]):
                        mem[160] = 26
                        mem[192] = 'SafeMath: division by zero'
                        mem[224] = 31
                        mem[256] = 'SafeMath: subtraction underflow'
                        if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                            revert with 0, 'SafeMath: subtraction underflow'
                        mem[288] = 31
                        mem[320] = 'SafeMath: subtraction underflow'
                        if 0 > (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000):
                            revert with 0, 'SafeMath: subtraction underflow'
                        mem[352] = 26
                        mem[384] = 'SafeMath: division by zero'
                        if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2 <= 0:
                            revert with 0, 'amount too low'
                        mem[416] = 2
                        mem[448] = rewardTokenAddress
                        mem[480] = stor10
                        if rewardTokenAddress == stor10:
                            mem[512] = 2
                            mem[544] = rewardTokenAddress
                            mem[576] = stor11
                            if rewardTokenAddress == stor11:
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000))
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000))
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                                mem[644] = 64
                                mem[676] = 2
                                mem[708 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 608
                                require return_data.size >= 32
                                _4961 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                                require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 608]
                                _5005 = mem[_4961 + 608]
                                mem[ceil32(return_data.size) + 640 len floor32(mem[_4961 + 608])] = mem[_4961 + 640 len floor32(mem[_4961 + 608])]
                                mem[64] = (32 * _5005) + ceil32(return_data.size) + 640
                                require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                                _8275 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                                mem[(32 * _5005) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _5005) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                                mem[(32 * _5005) + ceil32(return_data.size) + 676] = _8275
                                mem[(32 * _5005) + ceil32(return_data.size) + 740] = this.address
                                mem[(32 * _5005) + ceil32(return_data.size) + 772] = block.timestamp
                                mem[(32 * _5005) + ceil32(return_data.size) + 708] = 160
                                mem[(32 * _5005) + ceil32(return_data.size) + 804] = 2
                                mem[(32 * _5005) + ceil32(return_data.size) + 836 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _8275, Array(len=2, data=mem[(32 * _5005) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _5005) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _5005) + (2 * ceil32(return_data.size)) + 640
                                require return_data.size >= 32
                                require mem[(32 * _5005) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _5005) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _5005) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5005) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _5005) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5005) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5005) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _8275, 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8275)
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8275)
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                        else:
                            mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                            mem[548] = 64
                            mem[580] = 2
                            mem[612 len 0] = None
                            require ext_code.size(routerAddress)
                            staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 512
                            require return_data.size >= 32
                            _4963 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                            require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 512]
                            _5006 = mem[_4963 + 512]
                            mem[ceil32(return_data.size) + 544 len floor32(mem[_4963 + 512])] = mem[_4963 + 544 len floor32(mem[_4963 + 512])]
                            mem[64] = (32 * _5006) + ceil32(return_data.size) + 544
                            require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                            _8279 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                            mem[(32 * _5006) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(32 * _5006) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                            mem[(32 * _5006) + ceil32(return_data.size) + 580] = _8279
                            mem[(32 * _5006) + ceil32(return_data.size) + 644] = this.address
                            mem[(32 * _5006) + ceil32(return_data.size) + 676] = block.timestamp
                            mem[(32 * _5006) + ceil32(return_data.size) + 612] = 160
                            mem[(32 * _5006) + ceil32(return_data.size) + 708] = 2
                            mem[(32 * _5006) + ceil32(return_data.size) + 740 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _8279, Array(len=2, data=mem[(32 * _5006) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _5006) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _5006) + (2 * ceil32(return_data.size)) + 544
                            require return_data.size >= 32
                            _11425 = mem[(32 * _5006) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                            require mem[(32 * _5006) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[(32 * _5006) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[(32 * _5006) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5006) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _5006) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5006) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5006) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                            mem[(32 * _5006) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _5006) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5006) + ceil32(return_data.size) + 544]
                            _11468 = mem[_11425 + (32 * _5006) + ceil32(return_data.size) + 544]
                            mem[(32 * _5006) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_11425 + (32 * _5006) + ceil32(return_data.size) + 544])] = mem[_11425 + (32 * _5006) + ceil32(return_data.size) + 576 len floor32(mem[_11425 + (32 * _5006) + ceil32(return_data.size) + 544])]
                            mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 576] = 2
                            mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                            mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 640] = stor11
                            if rewardTokenAddress == stor11:
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, _8279, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000))
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000))
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                                mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 708] = 64
                                mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 740] = 2
                                mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Array(len=2, data=mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 772 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 672
                                require return_data.size >= 32
                                _17488 = mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                                require mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                                mem[(32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672]
                                _17510 = mem[_17488 + (32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672]
                                mem[(32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_17488 + (32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672])] = mem[_17488 + (32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_17488 + (32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672])]
                                mem[64] = (32 * _17510) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704
                                require mem[(32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 672]
                                _18560 = mem[(32 * mem[(32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704]
                                mem[(32 * _17510) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _17510) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                                mem[(32 * _17510) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 740] = _18560
                                mem[(32 * _17510) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 804] = this.address
                                mem[(32 * _17510) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                                mem[(32 * _17510) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 772] = 160
                                mem[(32 * _17510) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 868] = 2
                                mem[(32 * _17510) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _18560, Array(len=2, data=mem[(32 * _17510) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _17510) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _17510) + (32 * _11468) + (32 * _5006) + (6 * ceil32(return_data.size)) + 704
                                require return_data.size >= 32
                                require mem[(32 * _17510) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _17510) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _17510) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _17510) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _17510) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _17510) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _17510) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, _8279, _18560, 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18560)
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18560)
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                    else:
                        require 2 * ext_call.return_data[0]
                        if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 2 * ext_call.return_data[0] != REINVEST_REWARD_BIPS:
                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                        mem[160] = 26
                        mem[192] = 'SafeMath: division by zero'
                        if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 <= 0:
                            mem[224] = 31
                            mem[256] = 'SafeMath: subtraction underflow'
                            if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                                revert with 0, 'SafeMath: subtraction underflow'
                            mem[288] = 31
                            mem[320] = 'SafeMath: subtraction underflow'
                            if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 > (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000):
                                revert with 0, 'SafeMath: subtraction underflow'
                            mem[352] = 26
                            mem[384] = 'SafeMath: division by zero'
                            if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2 <= 0:
                                revert with 0, 'amount too low'
                            mem[416] = 2
                            mem[448] = rewardTokenAddress
                            mem[480] = stor10
                            if rewardTokenAddress == stor10:
                                mem[512] = 2
                                mem[544] = rewardTokenAddress
                                mem[576] = stor11
                                if rewardTokenAddress == stor11:
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                                else:
                                    mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[644] = 64
                                    mem[676] = 2
                                    mem[708 len 0] = None
                                    require ext_code.size(routerAddress)
                                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(return_data.size) + 608
                                    require return_data.size >= 32
                                    _4953 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                    require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                                    mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]
                                    _5001 = mem[_4953 + 608]
                                    mem[ceil32(return_data.size) + 640 len floor32(mem[_4953 + 608])] = mem[_4953 + 640 len floor32(mem[_4953 + 608])]
                                    mem[64] = (32 * _5001) + ceil32(return_data.size) + 640
                                    require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                                    _8259 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                                    mem[(32 * _5001) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _5001) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _5001) + ceil32(return_data.size) + 676] = _8259
                                    mem[(32 * _5001) + ceil32(return_data.size) + 740] = this.address
                                    mem[(32 * _5001) + ceil32(return_data.size) + 772] = block.timestamp
                                    mem[(32 * _5001) + ceil32(return_data.size) + 708] = 160
                                    mem[(32 * _5001) + ceil32(return_data.size) + 804] = 2
                                    mem[(32 * _5001) + ceil32(return_data.size) + 836 len 0] = None
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8259, Array(len=2, data=mem[(32 * _5001) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _5001) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _5001) + (2 * ceil32(return_data.size)) + 640
                                    require return_data.size >= 32
                                    require mem[(32 * _5001) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _5001) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _5001) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5001) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _5001) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5001) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5001) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8259, 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8259)
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8259)
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[548] = 64
                                mem[580] = 2
                                mem[612 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 512
                                require return_data.size >= 32
                                _4955 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]
                                _5002 = mem[_4955 + 512]
                                mem[ceil32(return_data.size) + 544 len floor32(mem[_4955 + 512])] = mem[_4955 + 544 len floor32(mem[_4955 + 512])]
                                mem[64] = (32 * _5002) + ceil32(return_data.size) + 544
                                require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                                _8263 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                                mem[(32 * _5002) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _5002) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[(32 * _5002) + ceil32(return_data.size) + 580] = _8263
                                mem[(32 * _5002) + ceil32(return_data.size) + 644] = this.address
                                mem[(32 * _5002) + ceil32(return_data.size) + 676] = block.timestamp
                                mem[(32 * _5002) + ceil32(return_data.size) + 612] = 160
                                mem[(32 * _5002) + ceil32(return_data.size) + 708] = 2
                                mem[(32 * _5002) + ceil32(return_data.size) + 740 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8263, Array(len=2, data=mem[(32 * _5002) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _5002) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _5002) + (2 * ceil32(return_data.size)) + 544
                                require return_data.size >= 32
                                _11417 = mem[(32 * _5002) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[(32 * _5002) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _5002) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _5002) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5002) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _5002) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5002) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5002) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                                mem[(32 * _5002) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _5002) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5002) + ceil32(return_data.size) + 544]
                                _11464 = mem[_11417 + (32 * _5002) + ceil32(return_data.size) + 544]
                                mem[(32 * _5002) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_11417 + (32 * _5002) + ceil32(return_data.size) + 544])] = mem[_11417 + (32 * _5002) + ceil32(return_data.size) + 576 len floor32(mem[_11417 + (32 * _5002) + ceil32(return_data.size) + 544])]
                                mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 576] = 2
                                mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                                mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 640] = stor11
                                if rewardTokenAddress == stor11:
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, _8263, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                                else:
                                    mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 708] = 64
                                    mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 740] = 2
                                    mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                                    require ext_code.size(routerAddress)
                                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 772 len 64])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 672
                                    require return_data.size >= 32
                                    _17484 = mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                    require mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                                    mem[(32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672]
                                    _17508 = mem[_17484 + (32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672]
                                    mem[(32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_17484 + (32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672])] = mem[_17484 + (32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_17484 + (32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672])]
                                    mem[64] = (32 * _17508) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704
                                    require mem[(32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 672]
                                    _18552 = mem[(32 * mem[(32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704]
                                    mem[(32 * _17508) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _17508) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _17508) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 740] = _18552
                                    mem[(32 * _17508) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 804] = this.address
                                    mem[(32 * _17508) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                                    mem[(32 * _17508) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 772] = 160
                                    mem[(32 * _17508) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 868] = 2
                                    mem[(32 * _17508) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _18552, Array(len=2, data=mem[(32 * _17508) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _17508) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _17508) + (32 * _11464) + (32 * _5002) + (6 * ceil32(return_data.size)) + 704
                                    require return_data.size >= 32
                                    require mem[(32 * _17508) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _17508) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _17508) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17508) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _17508) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _17508) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17508) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, _8263, _18552, 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18552)
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18552)
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                        else:
                            require ext_code.size(rewardTokenAddress)
                            call rewardTokenAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                revert with 0, 'reinvest fee transfer failed'
                            mem[224] = 31
                            mem[256] = 'SafeMath: subtraction underflow'
                            if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                                revert with 0, 'SafeMath: subtraction underflow'
                            mem[288] = 31
                            mem[320] = 'SafeMath: subtraction underflow'
                            if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 > (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000):
                                revert with 0, 'SafeMath: subtraction underflow'
                            mem[352] = 26
                            mem[384] = 'SafeMath: division by zero'
                            if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2 <= 0:
                                revert with 0, 'amount too low'
                            mem[416] = 2
                            mem[448] = rewardTokenAddress
                            mem[480] = stor10
                            if rewardTokenAddress == stor10:
                                mem[512] = 2
                                mem[544] = rewardTokenAddress
                                mem[576] = stor11
                                if rewardTokenAddress == stor11:
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                                else:
                                    mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[644] = 64
                                    mem[676] = 2
                                    mem[708 len 0] = None
                                    require ext_code.size(routerAddress)
                                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(return_data.size) + 608
                                    require return_data.size >= 32
                                    _4957 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                    require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                                    mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]
                                    _5003 = mem[_4957 + 608]
                                    mem[ceil32(return_data.size) + 640 len floor32(mem[_4957 + 608])] = mem[_4957 + 640 len floor32(mem[_4957 + 608])]
                                    mem[64] = (32 * _5003) + ceil32(return_data.size) + 640
                                    require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                                    _8267 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                                    mem[(32 * _5003) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _5003) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _5003) + ceil32(return_data.size) + 676] = _8267
                                    mem[(32 * _5003) + ceil32(return_data.size) + 740] = this.address
                                    mem[(32 * _5003) + ceil32(return_data.size) + 772] = block.timestamp
                                    mem[(32 * _5003) + ceil32(return_data.size) + 708] = 160
                                    mem[(32 * _5003) + ceil32(return_data.size) + 804] = 2
                                    mem[(32 * _5003) + ceil32(return_data.size) + 836 len 0] = None
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8267, Array(len=2, data=mem[(32 * _5003) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _5003) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _5003) + (2 * ceil32(return_data.size)) + 640
                                    require return_data.size >= 32
                                    require mem[(32 * _5003) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _5003) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _5003) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5003) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _5003) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5003) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5003) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8267, 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8267)
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8267)
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[548] = 64
                                mem[580] = 2
                                mem[612 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 512
                                require return_data.size >= 32
                                _4959 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]
                                _5004 = mem[_4959 + 512]
                                mem[ceil32(return_data.size) + 544 len floor32(mem[_4959 + 512])] = mem[_4959 + 544 len floor32(mem[_4959 + 512])]
                                mem[64] = (32 * _5004) + ceil32(return_data.size) + 544
                                require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                                _8271 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                                mem[(32 * _5004) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _5004) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[(32 * _5004) + ceil32(return_data.size) + 580] = _8271
                                mem[(32 * _5004) + ceil32(return_data.size) + 644] = this.address
                                mem[(32 * _5004) + ceil32(return_data.size) + 676] = block.timestamp
                                mem[(32 * _5004) + ceil32(return_data.size) + 612] = 160
                                mem[(32 * _5004) + ceil32(return_data.size) + 708] = 2
                                mem[(32 * _5004) + ceil32(return_data.size) + 740 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8271, Array(len=2, data=mem[(32 * _5004) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _5004) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _5004) + (2 * ceil32(return_data.size)) + 544
                                require return_data.size >= 32
                                _11421 = mem[(32 * _5004) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[(32 * _5004) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _5004) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _5004) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5004) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _5004) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5004) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5004) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                                mem[(32 * _5004) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _5004) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5004) + ceil32(return_data.size) + 544]
                                _11466 = mem[_11421 + (32 * _5004) + ceil32(return_data.size) + 544]
                                mem[(32 * _5004) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_11421 + (32 * _5004) + ceil32(return_data.size) + 544])] = mem[_11421 + (32 * _5004) + ceil32(return_data.size) + 576 len floor32(mem[_11421 + (32 * _5004) + ceil32(return_data.size) + 544])]
                                mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 576] = 2
                                mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                                mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 640] = stor11
                                if rewardTokenAddress == stor11:
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, _8271, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                                else:
                                    mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 708] = 64
                                    mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 740] = 2
                                    mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                                    require ext_code.size(routerAddress)
                                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 772 len 64])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 672
                                    require return_data.size >= 32
                                    _17486 = mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                    require mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                                    mem[(32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672]
                                    _17509 = mem[_17486 + (32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672]
                                    mem[(32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_17486 + (32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672])] = mem[_17486 + (32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_17486 + (32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672])]
                                    mem[64] = (32 * _17509) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704
                                    require mem[(32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 672]
                                    _18556 = mem[(32 * mem[(32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704]
                                    mem[(32 * _17509) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _17509) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _17509) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 740] = _18556
                                    mem[(32 * _17509) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 804] = this.address
                                    mem[(32 * _17509) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                                    mem[(32 * _17509) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 772] = 160
                                    mem[(32 * _17509) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 868] = 2
                                    mem[(32 * _17509) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _18556, Array(len=2, data=mem[(32 * _17509) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _17509) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _17509) + (32 * _11466) + (32 * _5004) + (6 * ceil32(return_data.size)) + 704
                                    require return_data.size >= 32
                                    require mem[(32 * _17509) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _17509) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _17509) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17509) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _17509) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _17509) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17509) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, _8271, _18556, 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18556)
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18556)
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
    if totalDeposits + arg1 < totalDeposits:
        revert with 0, 'SafeMath: addition overflow'
    totalDeposits += arg1
    emit Deposit(arg1, msg.sender);
}

function depositWithPermit(uint256 arg1, uint256 arg2, uint8 arg3, bytes32 arg4, bytes32 arg5) payable {
    require calldata.size - 4 >= 160
    require ext_code.size(depositTokenAddress)
    call depositTokenAddress.0xd505accf with:
         gas gas_remaining wei
        args 0, uint32(msg.sender), address(this.address), arg1, arg2, arg3 << 248, arg4, arg5
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if totalDeposits < totalSupply:
        revert with 0, 'deposit failed'
    if not uint8(stor18):
        require ext_code.size(depositTokenAddress)
        call depositTokenAddress.0x23b872dd with:
             gas gas_remaining wei
            args msg.sender, address(this.address), arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            revert with 0, 'transferFrom failed'
        if arg1 <= 0:
            revert with 0, 'amount too low'
        require ext_code.size(stakingContractAddress)
        call stakingContractAddress.0xe2bbb158 with:
             gas gas_remaining wei
            args PID, arg1
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if not totalSupply:
            if totalSupply + arg1 < totalSupply:
                revert with 0, 'SafeMath: addition overflow'
            totalSupply += arg1
            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                revert with 0, 'SafeMath: addition overflow'
            balanceOf[address(msg.sender)] += arg1
            emit Transfer(arg1, 0, msg.sender);
        else:
            require totalSupply
            if totalSupply * totalDeposits / totalSupply != totalDeposits:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            Mask(248, 0, arg2)
            if not totalSupply * totalDeposits:
                if totalSupply + arg1 < totalSupply:
                    revert with 0, 'SafeMath: addition overflow'
                totalSupply += arg1
                if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(msg.sender)] += arg1
                emit Transfer(arg1, 0, msg.sender);
            else:
                if not arg1:
                    if totalDeposits <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalDeposits
                    if totalSupply + (0 / totalDeposits) < totalSupply:
                        revert with 0, 'SafeMath: addition overflow'
                    totalSupply += 0 / totalDeposits
                    if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(msg.sender)] += 0 / totalDeposits
                    emit Transfer((0 / totalDeposits), 0, msg.sender);
                else:
                    require arg1
                    if arg1 * totalSupply / arg1 != totalSupply:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    Mask(248, 0, arg2)
                    if totalDeposits <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalDeposits
                    if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                        revert with 0, 'SafeMath: addition overflow'
                    totalSupply += arg1 * totalSupply / totalDeposits
                    if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                    emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
    else:
        require ext_code.size(stakingContractAddress)
        staticcall stakingContractAddress.pendingOlive(uint256 rg1, address rg2) with:
                gas gas_remaining wei
               args PID, this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(rewardTokenAddress)
        staticcall rewardTokenAddress.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if 2 * ext_call.return_data[0] < ext_call.return_data[0]:
            revert with 0, 'SafeMath: addition overflow'
        if 2 * ext_call.return_data[0] < MIN_TOKENS_TO_REINVEST_BEFORE_DEPOSIT:
            require ext_code.size(depositTokenAddress)
            call depositTokenAddress.0x23b872dd with:
                 gas gas_remaining wei
                args msg.sender, address(this.address), arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                revert with 0, 'transferFrom failed'
            if arg1 <= 0:
                revert with 0, 'amount too low'
            require ext_code.size(stakingContractAddress)
            call stakingContractAddress.0xe2bbb158 with:
                 gas gas_remaining wei
                args PID, arg1
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not totalSupply:
                if totalSupply + arg1 < totalSupply:
                    revert with 0, 'SafeMath: addition overflow'
                totalSupply += arg1
                if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                    revert with 0, 'SafeMath: addition overflow'
                balanceOf[address(msg.sender)] += arg1
                emit Transfer(arg1, 0, msg.sender);
            else:
                require totalSupply
                if totalSupply * totalDeposits / totalSupply != totalDeposits:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                Mask(248, 0, arg2)
                if not totalSupply * totalDeposits:
                    if totalSupply + arg1 < totalSupply:
                        revert with 0, 'SafeMath: addition overflow'
                    totalSupply += arg1
                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                        revert with 0, 'SafeMath: addition overflow'
                    balanceOf[address(msg.sender)] += arg1
                    emit Transfer(arg1, 0, msg.sender);
                else:
                    if not arg1:
                        if totalDeposits <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalDeposits
                        if totalSupply + (0 / totalDeposits) < totalSupply:
                            revert with 0, 'SafeMath: addition overflow'
                        totalSupply += 0 / totalDeposits
                        if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(msg.sender)] += 0 / totalDeposits
                        emit Transfer((0 / totalDeposits), 0, msg.sender);
                    else:
                        require arg1
                        if arg1 * totalSupply / arg1 != totalSupply:
                            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                        32,
                                        33,
                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        Mask(248, 0, arg2)
                        if totalDeposits <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalDeposits
                        if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                            revert with 0, 'SafeMath: addition overflow'
                        totalSupply += arg1 * totalSupply / totalDeposits
                        if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                            revert with 0, 'SafeMath: addition overflow'
                        balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                        emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
        else:
            require ext_code.size(stakingContractAddress)
            call stakingContractAddress.0xe2bbb158 with:
                 gas gas_remaining wei
                args PID, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not uint255(ext_call.return_data[0]):
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if not uint255(ext_call.return_data[0]):
                    mem[160] = 26
                    mem[192] = 'SafeMath: division by zero'
                    mem[224] = 31
                    mem[256] = 'SafeMath: subtraction underflow'
                    if 0 > 2 * ext_call.return_data[0]:
                        revert with 0, 'SafeMath: subtraction underflow'
                    mem[288] = 31
                    mem[320] = 'SafeMath: subtraction underflow'
                    mem[352] = 26
                    mem[384] = 'SafeMath: division by zero'
                    if uint255(ext_call.return_data[0]) <= 0:
                        revert with 0, 'amount too low'
                    mem[416] = 2
                    mem[448] = rewardTokenAddress
                    mem[480] = stor10
                    if rewardTokenAddress == stor10:
                        mem[512] = 2
                        mem[544] = rewardTokenAddress
                        mem[576] = stor11
                        if rewardTokenAddress == stor11:
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, 2 * ext_call.return_data[0], 2 * ext_call.return_data[0], 0, 0, address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 96
                            if ext_call.return_data[64] <= 0:
                                revert with 0, 'amount too low'
                            require ext_code.size(stakingContractAddress)
                            call stakingContractAddress.0xe2bbb158 with:
                                 gas gas_remaining wei
                                args PID, ext_call.return_data[64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                revert with 0, 'SafeMath: addition overflow'
                            totalDeposits += ext_call.return_data[64]
                            emit Reinvest(totalDeposits, totalSupply);
                            require ext_code.size(depositTokenAddress)
                            call depositTokenAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                revert with 0, 'transferFrom failed'
                            if arg1 <= 0:
                                revert with 0, 'amount too low'
                            require ext_code.size(stakingContractAddress)
                            call stakingContractAddress.0xe2bbb158 with:
                                 gas gas_remaining wei
                                args PID, arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not totalSupply:
                                if totalSupply + arg1 < totalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalSupply += arg1
                                if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(msg.sender)] += arg1
                                emit Transfer(arg1, 0, msg.sender);
                            else:
                                require totalSupply
                                if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                2 * Mask(247, 0, ext_call.return_data[0])
                                if not totalSupply * totalDeposits:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    if not arg1:
                                        if totalDeposits <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalDeposits
                                        if totalSupply + (0 / totalDeposits) < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += 0 / totalDeposits
                                        if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += 0 / totalDeposits
                                        emit Transfer((0 / totalDeposits), 0, msg.sender);
                                    else:
                                        require arg1
                                        if arg1 * totalSupply / arg1 != totalSupply:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        2 * Mask(247, 0, ext_call.return_data[0])
                                        if totalDeposits <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalDeposits
                                        if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1 * totalSupply / totalDeposits
                                        if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                        emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                        else:
                            mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[612] = uint255(ext_call.return_data[0])
                            mem[644] = 64
                            mem[676] = 2
                            mem[708 len 0] = None
                            require ext_code.size(routerAddress)
                            staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args 2 * ext_call.return_data[0], Array(len=2, data=mem[708 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 608
                            require return_data.size >= 32
                            _4975 = mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31
                            require mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 <= 4294967296
                            require mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 32 <= return_data.size
                            require mem[mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * mem[mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 608]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 608]
                            _5013 = mem[_4975 + 608]
                            mem[ceil32(return_data.size) + 640 len floor32(mem[_4975 + 608])] = mem[_4975 + 640 len floor32(mem[_4975 + 608])]
                            mem[64] = (32 * _5013) + ceil32(return_data.size) + 640
                            require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                            _8301 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                            mem[(32 * _5013) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(32 * _5013) + ceil32(return_data.size) + 644] = uint255(ext_call.return_data[0])
                            mem[(32 * _5013) + ceil32(return_data.size) + 676] = _8301
                            mem[(32 * _5013) + ceil32(return_data.size) + 740] = this.address
                            mem[(32 * _5013) + ceil32(return_data.size) + 772] = block.timestamp
                            mem[(32 * _5013) + ceil32(return_data.size) + 708] = 160
                            mem[(32 * _5013) + ceil32(return_data.size) + 804] = 2
                            mem[(32 * _5013) + ceil32(return_data.size) + 836 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args 2 * ext_call.return_data[0], _8301, Array(len=2, data=mem[(32 * _5013) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _5013) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _5013) + (2 * ceil32(return_data.size)) + 640
                            require return_data.size >= 32
                            require mem[(32 * _5013) + ceil32(return_data.size) + 640 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 <= 4294967296
                            require mem[(32 * _5013) + ceil32(return_data.size) + 640 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 32 <= return_data.size
                            require mem[mem[(32 * _5013) + ceil32(return_data.size) + 640 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _5013) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _5013) + ceil32(return_data.size) + 640 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * mem[mem[(32 * _5013) + ceil32(return_data.size) + 640 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _5013) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, 2 * ext_call.return_data[0], _8301, 0, 0, address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 96
                            if ext_call.return_data[64] <= 0:
                                revert with 0, 'amount too low'
                            require ext_code.size(stakingContractAddress)
                            call stakingContractAddress.0xe2bbb158 with:
                                 gas gas_remaining wei
                                args PID, ext_call.return_data[64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                revert with 0, 'SafeMath: addition overflow'
                            totalDeposits += ext_call.return_data[64]
                            emit Reinvest(totalDeposits, totalSupply);
                            require ext_code.size(depositTokenAddress)
                            call depositTokenAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                revert with 0, 'transferFrom failed'
                            if arg1 <= 0:
                                revert with 0, 'amount too low'
                            require ext_code.size(stakingContractAddress)
                            call stakingContractAddress.0xe2bbb158 with:
                                 gas gas_remaining wei
                                args PID, arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not totalSupply:
                                if totalSupply + arg1 < totalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalSupply += arg1
                                if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(msg.sender)] += arg1
                                emit Transfer(arg1, 0, msg.sender);
                            else:
                                require totalSupply
                                if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8301)
                                if not totalSupply * totalDeposits:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    if not arg1:
                                        if totalDeposits <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalDeposits
                                        if totalSupply + (0 / totalDeposits) < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += 0 / totalDeposits
                                        if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += 0 / totalDeposits
                                        emit Transfer((0 / totalDeposits), 0, msg.sender);
                                    else:
                                        require arg1
                                        if arg1 * totalSupply / arg1 != totalSupply:
                                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8301)
                                        if totalDeposits <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalDeposits
                                        if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1 * totalSupply / totalDeposits
                                        if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                        emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                    else:
                        mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                        mem[516] = uint255(ext_call.return_data[0])
                        mem[548] = 64
                        mem[580] = 2
                        mem[612 len 0] = None
                        require ext_code.size(routerAddress)
                        staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                gas gas_remaining wei
                               args 2 * ext_call.return_data[0], Array(len=2, data=mem[612 len 64])
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + 512
                        require return_data.size >= 32
                        _4977 = mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31
                        require mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 <= 4294967296
                        require mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 32 <= return_data.size
                        require mem[mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * mem[mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 512]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 512]
                        _5014 = mem[_4977 + 512]
                        mem[ceil32(return_data.size) + 544 len floor32(mem[_4977 + 512])] = mem[_4977 + 544 len floor32(mem[_4977 + 512])]
                        mem[64] = (32 * _5014) + ceil32(return_data.size) + 544
                        require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                        _8305 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                        mem[(32 * _5014) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[(32 * _5014) + ceil32(return_data.size) + 548] = uint255(ext_call.return_data[0])
                        mem[(32 * _5014) + ceil32(return_data.size) + 580] = _8305
                        mem[(32 * _5014) + ceil32(return_data.size) + 644] = this.address
                        mem[(32 * _5014) + ceil32(return_data.size) + 676] = block.timestamp
                        mem[(32 * _5014) + ceil32(return_data.size) + 612] = 160
                        mem[(32 * _5014) + ceil32(return_data.size) + 708] = 2
                        mem[(32 * _5014) + ceil32(return_data.size) + 740 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args 2 * ext_call.return_data[0], _8305, Array(len=2, data=mem[(32 * _5014) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[(32 * _5014) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = (32 * _5014) + (2 * ceil32(return_data.size)) + 544
                        require return_data.size >= 32
                        _11439 = mem[(32 * _5014) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31
                        require mem[(32 * _5014) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 <= 4294967296
                        require mem[(32 * _5014) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 32 <= return_data.size
                        require mem[mem[(32 * _5014) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _5014) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _5014) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * mem[mem[(32 * _5014) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _5014) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                        mem[(32 * _5014) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _5014) + ceil32(return_data.size) + 544 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _5014) + ceil32(return_data.size) + 544]
                        _11476 = mem[_11439 + (32 * _5014) + ceil32(return_data.size) + 544]
                        mem[(32 * _5014) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_11439 + (32 * _5014) + ceil32(return_data.size) + 544])] = mem[_11439 + (32 * _5014) + ceil32(return_data.size) + 576 len floor32(mem[_11439 + (32 * _5014) + ceil32(return_data.size) + 544])]
                        mem[(32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 576] = 2
                        mem[(32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                        mem[(32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 640] = stor11
                        if rewardTokenAddress == stor11:
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, _8305, 2 * ext_call.return_data[0], 0, 0, address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 96
                            if ext_call.return_data[64] <= 0:
                                revert with 0, 'amount too low'
                            require ext_code.size(stakingContractAddress)
                            call stakingContractAddress.0xe2bbb158 with:
                                 gas gas_remaining wei
                                args PID, ext_call.return_data[64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                revert with 0, 'SafeMath: addition overflow'
                            totalDeposits += ext_call.return_data[64]
                            emit Reinvest(totalDeposits, totalSupply);
                            require ext_code.size(depositTokenAddress)
                            call depositTokenAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                revert with 0, 'transferFrom failed'
                            if arg1 <= 0:
                                revert with 0, 'amount too low'
                            require ext_code.size(stakingContractAddress)
                            call stakingContractAddress.0xe2bbb158 with:
                                 gas gas_remaining wei
                                args PID, arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not totalSupply:
                                if totalSupply + arg1 < totalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalSupply += arg1
                                if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(msg.sender)] += arg1
                                emit Transfer(arg1, 0, msg.sender);
                            else:
                                require totalSupply
                                if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                2 * Mask(247, 0, ext_call.return_data[0])
                                if not totalSupply * totalDeposits:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    if not arg1:
                                        if totalDeposits <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalDeposits
                                        if totalSupply + (0 / totalDeposits) < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += 0 / totalDeposits
                                        if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += 0 / totalDeposits
                                        emit Transfer((0 / totalDeposits), 0, msg.sender);
                                    else:
                                        require arg1
                                        if arg1 * totalSupply / arg1 != totalSupply:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        2 * Mask(247, 0, ext_call.return_data[0])
                                        if totalDeposits <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalDeposits
                                        if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1 * totalSupply / totalDeposits
                                        if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                        emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                        else:
                            mem[(32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[(32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 676] = uint255(ext_call.return_data[0])
                            mem[(32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 708] = 64
                            mem[(32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 740] = 2
                            mem[(32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                            require ext_code.size(routerAddress)
                            staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args 2 * ext_call.return_data[0], Array(len=2, data=mem[(32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 772 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 672
                            require return_data.size >= 32
                            _17496 = mem[(32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31
                            require mem[(32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 <= 4294967296
                            require mem[(32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 32 <= return_data.size
                            require mem[mem[(32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * mem[mem[(32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                            mem[(32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 672]
                            _17515 = mem[_17496 + (32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 672]
                            mem[(32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_17496 + (32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 672])] = mem[_17496 + (32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_17496 + (32 * _11476) + (32 * _5014) + (2 * ceil32(return_data.size)) + 672])]
                            mem[64] = (32 * _17515) + (32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 704
                            require mem[(32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 672]
                            _18574 = mem[(32 * mem[(32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 704]
                            mem[(32 * _17515) + (32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(32 * _17515) + (32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 708] = uint255(ext_call.return_data[0])
                            mem[(32 * _17515) + (32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 740] = _18574
                            mem[(32 * _17515) + (32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 804] = this.address
                            mem[(32 * _17515) + (32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                            mem[(32 * _17515) + (32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 772] = 160
                            mem[(32 * _17515) + (32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 868] = 2
                            mem[(32 * _17515) + (32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args 2 * ext_call.return_data[0], _18574, Array(len=2, data=mem[(32 * _17515) + (32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _17515) + (32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _17515) + (32 * _11476) + (32 * _5014) + (6 * ceil32(return_data.size)) + 704
                            require return_data.size >= 32
                            require mem[(32 * _17515) + (32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 <= 4294967296
                            require mem[(32 * _17515) + (32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + 32 <= return_data.size
                            require mem[mem[(32 * _17515) + (32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _17515) + (32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _17515) + (32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * mem[mem[(32 * _17515) + (32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 31, ext_call.return_data[0]) >> 31 + (32 * _17515) + (32 * _11476) + (32 * _5014) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                            require ext_code.size(routerAddress)
                            call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                 gas gas_remaining wei
                                args stor10, stor11, _8305, _18574, 0, 0, address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 96
                            if ext_call.return_data[64] <= 0:
                                revert with 0, 'amount too low'
                            require ext_code.size(stakingContractAddress)
                            call stakingContractAddress.0xe2bbb158 with:
                                 gas gas_remaining wei
                                args PID, ext_call.return_data[64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                revert with 0, 'SafeMath: addition overflow'
                            totalDeposits += ext_call.return_data[64]
                            emit Reinvest(totalDeposits, totalSupply);
                            require ext_code.size(depositTokenAddress)
                            call depositTokenAddress.0x23b872dd with:
                                 gas gas_remaining wei
                                args msg.sender, address(this.address), arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                revert with 0, 'transferFrom failed'
                            if arg1 <= 0:
                                revert with 0, 'amount too low'
                            require ext_code.size(stakingContractAddress)
                            call stakingContractAddress.0xe2bbb158 with:
                                 gas gas_remaining wei
                                args PID, arg1
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not totalSupply:
                                if totalSupply + arg1 < totalSupply:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalSupply += arg1
                                if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                    revert with 0, 'SafeMath: addition overflow'
                                balanceOf[address(msg.sender)] += arg1
                                emit Transfer(arg1, 0, msg.sender);
                            else:
                                require totalSupply
                                if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18574)
                                if not totalSupply * totalDeposits:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    if not arg1:
                                        if totalDeposits <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalDeposits
                                        if totalSupply + (0 / totalDeposits) < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += 0 / totalDeposits
                                        if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += 0 / totalDeposits
                                        emit Transfer((0 / totalDeposits), 0, msg.sender);
                                    else:
                                        require arg1
                                        if arg1 * totalSupply / arg1 != totalSupply:
                                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18574)
                                        if totalDeposits <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalDeposits
                                        if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1 * totalSupply / totalDeposits
                                        if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                        emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                else:
                    require 2 * ext_call.return_data[0]
                    if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 2 * ext_call.return_data[0] != REINVEST_REWARD_BIPS:
                        revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, arg4)
                    mem[160] = 26
                    mem[192] = 'SafeMath: division by zero'
                    if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 <= 0:
                        mem[224] = 31
                        mem[256] = 'SafeMath: subtraction underflow'
                        if 0 > 2 * ext_call.return_data[0]:
                            revert with 0, 'SafeMath: subtraction underflow'
                        mem[288] = 31
                        mem[320] = 'SafeMath: subtraction underflow'
                        if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                            revert with 0, 'SafeMath: subtraction underflow'
                        mem[352] = 26
                        mem[384] = 'SafeMath: division by zero'
                        if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2 <= 0:
                            revert with 0, 'amount too low'
                        mem[416] = 2
                        mem[448] = rewardTokenAddress
                        mem[480] = stor10
                        if rewardTokenAddress == stor10:
                            mem[512] = 2
                            mem[544] = rewardTokenAddress
                            mem[576] = stor11
                            if rewardTokenAddress == stor11:
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[644] = 64
                                mem[676] = 2
                                mem[708 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 608
                                require return_data.size >= 32
                                _4967 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]
                                _5009 = mem[_4967 + 608]
                                mem[ceil32(return_data.size) + 640 len floor32(mem[_4967 + 608])] = mem[_4967 + 640 len floor32(mem[_4967 + 608])]
                                mem[64] = (32 * _5009) + ceil32(return_data.size) + 640
                                require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                                _8285 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                                mem[(32 * _5009) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _5009) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[(32 * _5009) + ceil32(return_data.size) + 676] = _8285
                                mem[(32 * _5009) + ceil32(return_data.size) + 740] = this.address
                                mem[(32 * _5009) + ceil32(return_data.size) + 772] = block.timestamp
                                mem[(32 * _5009) + ceil32(return_data.size) + 708] = 160
                                mem[(32 * _5009) + ceil32(return_data.size) + 804] = 2
                                mem[(32 * _5009) + ceil32(return_data.size) + 836 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8285, Array(len=2, data=mem[(32 * _5009) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _5009) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _5009) + (2 * ceil32(return_data.size)) + 640
                                require return_data.size >= 32
                                require mem[(32 * _5009) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _5009) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _5009) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5009) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _5009) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5009) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5009) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8285, 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8285)
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8285)
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                        else:
                            mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[548] = 64
                            mem[580] = 2
                            mem[612 len 0] = None
                            require ext_code.size(routerAddress)
                            staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 512
                            require return_data.size >= 32
                            _4969 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                            require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]
                            _5010 = mem[_4969 + 512]
                            mem[ceil32(return_data.size) + 544 len floor32(mem[_4969 + 512])] = mem[_4969 + 544 len floor32(mem[_4969 + 512])]
                            mem[64] = (32 * _5010) + ceil32(return_data.size) + 544
                            require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                            _8289 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                            mem[(32 * _5010) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(32 * _5010) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[(32 * _5010) + ceil32(return_data.size) + 580] = _8289
                            mem[(32 * _5010) + ceil32(return_data.size) + 644] = this.address
                            mem[(32 * _5010) + ceil32(return_data.size) + 676] = block.timestamp
                            mem[(32 * _5010) + ceil32(return_data.size) + 612] = 160
                            mem[(32 * _5010) + ceil32(return_data.size) + 708] = 2
                            mem[(32 * _5010) + ceil32(return_data.size) + 740 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8289, Array(len=2, data=mem[(32 * _5010) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _5010) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _5010) + (2 * ceil32(return_data.size)) + 544
                            require return_data.size >= 32
                            _11431 = mem[(32 * _5010) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                            require mem[(32 * _5010) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[(32 * _5010) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[(32 * _5010) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5010) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _5010) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5010) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5010) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                            mem[(32 * _5010) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _5010) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5010) + ceil32(return_data.size) + 544]
                            _11472 = mem[_11431 + (32 * _5010) + ceil32(return_data.size) + 544]
                            mem[(32 * _5010) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_11431 + (32 * _5010) + ceil32(return_data.size) + 544])] = mem[_11431 + (32 * _5010) + ceil32(return_data.size) + 576 len floor32(mem[_11431 + (32 * _5010) + ceil32(return_data.size) + 544])]
                            mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 576] = 2
                            mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                            mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 640] = stor11
                            if rewardTokenAddress == stor11:
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, _8289, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 708] = 64
                                mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 740] = 2
                                mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 772 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 672
                                require return_data.size >= 32
                                _17492 = mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                                mem[(32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672]
                                _17513 = mem[_17492 + (32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672]
                                mem[(32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_17492 + (32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672])] = mem[_17492 + (32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_17492 + (32 * _11472) + (32 * _5010) + (2 * ceil32(return_data.size)) + 672])]
                                mem[64] = (32 * _17513) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704
                                require mem[(32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 672]
                                _18566 = mem[(32 * mem[(32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704]
                                mem[(32 * _17513) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _17513) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[(32 * _17513) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 740] = _18566
                                mem[(32 * _17513) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 804] = this.address
                                mem[(32 * _17513) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                                mem[(32 * _17513) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 772] = 160
                                mem[(32 * _17513) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 868] = 2
                                mem[(32 * _17513) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _18566, Array(len=2, data=mem[(32 * _17513) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _17513) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _17513) + (32 * _11472) + (32 * _5010) + (6 * ceil32(return_data.size)) + 704
                                require return_data.size >= 32
                                require mem[(32 * _17513) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _17513) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _17513) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17513) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _17513) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _17513) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17513) + (32 * _11472) + (32 * _5010) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, _8289, _18566, 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18566)
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18566)
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                    else:
                        require ext_code.size(rewardTokenAddress)
                        call rewardTokenAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if not ext_call.return_data[0]:
                            revert with 0, 'reinvest fee transfer failed'
                        mem[224] = 31
                        mem[256] = 'SafeMath: subtraction underflow'
                        if 0 > 2 * ext_call.return_data[0]:
                            revert with 0, 'SafeMath: subtraction underflow'
                        mem[288] = 31
                        mem[320] = 'SafeMath: subtraction underflow'
                        if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                            revert with 0, 'SafeMath: subtraction underflow'
                        mem[352] = 26
                        mem[384] = 'SafeMath: division by zero'
                        if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2 <= 0:
                            revert with 0, 'amount too low'
                        mem[416] = 2
                        mem[448] = rewardTokenAddress
                        mem[480] = stor10
                        if rewardTokenAddress == stor10:
                            mem[512] = 2
                            mem[544] = rewardTokenAddress
                            mem[576] = stor11
                            if rewardTokenAddress == stor11:
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[644] = 64
                                mem[676] = 2
                                mem[708 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 608
                                require return_data.size >= 32
                                _4971 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]
                                _5011 = mem[_4971 + 608]
                                mem[ceil32(return_data.size) + 640 len floor32(mem[_4971 + 608])] = mem[_4971 + 640 len floor32(mem[_4971 + 608])]
                                mem[64] = (32 * _5011) + ceil32(return_data.size) + 640
                                require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                                _8293 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                                mem[(32 * _5011) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _5011) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[(32 * _5011) + ceil32(return_data.size) + 676] = _8293
                                mem[(32 * _5011) + ceil32(return_data.size) + 740] = this.address
                                mem[(32 * _5011) + ceil32(return_data.size) + 772] = block.timestamp
                                mem[(32 * _5011) + ceil32(return_data.size) + 708] = 160
                                mem[(32 * _5011) + ceil32(return_data.size) + 804] = 2
                                mem[(32 * _5011) + ceil32(return_data.size) + 836 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8293, Array(len=2, data=mem[(32 * _5011) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _5011) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _5011) + (2 * ceil32(return_data.size)) + 640
                                require return_data.size >= 32
                                require mem[(32 * _5011) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _5011) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _5011) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5011) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _5011) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5011) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5011) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8293, 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8293)
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8293)
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                        else:
                            mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[548] = 64
                            mem[580] = 2
                            mem[612 len 0] = None
                            require ext_code.size(routerAddress)
                            staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 512
                            require return_data.size >= 32
                            _4973 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                            require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]
                            _5012 = mem[_4973 + 512]
                            mem[ceil32(return_data.size) + 544 len floor32(mem[_4973 + 512])] = mem[_4973 + 544 len floor32(mem[_4973 + 512])]
                            mem[64] = (32 * _5012) + ceil32(return_data.size) + 544
                            require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                            _8297 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                            mem[(32 * _5012) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(32 * _5012) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                            mem[(32 * _5012) + ceil32(return_data.size) + 580] = _8297
                            mem[(32 * _5012) + ceil32(return_data.size) + 644] = this.address
                            mem[(32 * _5012) + ceil32(return_data.size) + 676] = block.timestamp
                            mem[(32 * _5012) + ceil32(return_data.size) + 612] = 160
                            mem[(32 * _5012) + ceil32(return_data.size) + 708] = 2
                            mem[(32 * _5012) + ceil32(return_data.size) + 740 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8297, Array(len=2, data=mem[(32 * _5012) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _5012) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _5012) + (2 * ceil32(return_data.size)) + 544
                            require return_data.size >= 32
                            _11435 = mem[(32 * _5012) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                            require mem[(32 * _5012) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[(32 * _5012) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[(32 * _5012) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5012) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _5012) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5012) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5012) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                            mem[(32 * _5012) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _5012) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5012) + ceil32(return_data.size) + 544]
                            _11474 = mem[_11435 + (32 * _5012) + ceil32(return_data.size) + 544]
                            mem[(32 * _5012) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_11435 + (32 * _5012) + ceil32(return_data.size) + 544])] = mem[_11435 + (32 * _5012) + ceil32(return_data.size) + 576 len floor32(mem[_11435 + (32 * _5012) + ceil32(return_data.size) + 544])]
                            mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 576] = 2
                            mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                            mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 640] = stor11
                            if rewardTokenAddress == stor11:
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, _8297, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 708] = 64
                                mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 740] = 2
                                mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 772 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 672
                                require return_data.size >= 32
                                _17494 = mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                                mem[(32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672]
                                _17514 = mem[_17494 + (32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672]
                                mem[(32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_17494 + (32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672])] = mem[_17494 + (32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_17494 + (32 * _11474) + (32 * _5012) + (2 * ceil32(return_data.size)) + 672])]
                                mem[64] = (32 * _17514) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704
                                require mem[(32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 672]
                                _18570 = mem[(32 * mem[(32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704]
                                mem[(32 * _17514) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _17514) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[(32 * _17514) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 740] = _18570
                                mem[(32 * _17514) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 804] = this.address
                                mem[(32 * _17514) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                                mem[(32 * _17514) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 772] = 160
                                mem[(32 * _17514) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 868] = 2
                                mem[(32 * _17514) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _18570, Array(len=2, data=mem[(32 * _17514) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _17514) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _17514) + (32 * _11474) + (32 * _5012) + (6 * ceil32(return_data.size)) + 704
                                require return_data.size >= 32
                                require mem[(32 * _17514) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _17514) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _17514) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17514) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _17514) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _17514) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17514) + (32 * _11474) + (32 * _5012) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, _8297, _18570, 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18570)
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18570)
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
            else:
                require 2 * ext_call.return_data[0]
                if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 2 * ext_call.return_data[0] != ADMIN_FEE_BIPS:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                Mask(248, 0, arg2)
                mem[96] = 26
                mem[128] = 'SafeMath: division by zero'
                if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 <= 0:
                    if not uint255(ext_call.return_data[0]):
                        mem[160] = 26
                        mem[192] = 'SafeMath: division by zero'
                        mem[224] = 31
                        mem[256] = 'SafeMath: subtraction underflow'
                        if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                            revert with 0, 'SafeMath: subtraction underflow'
                        mem[288] = 31
                        mem[320] = 'SafeMath: subtraction underflow'
                        if 0 > (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000):
                            revert with 0, 'SafeMath: subtraction underflow'
                        mem[352] = 26
                        mem[384] = 'SafeMath: division by zero'
                        if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2 <= 0:
                            revert with 0, 'amount too low'
                        mem[416] = 2
                        mem[448] = rewardTokenAddress
                        mem[480] = stor10
                        if rewardTokenAddress == stor10:
                            mem[512] = 2
                            mem[544] = rewardTokenAddress
                            mem[576] = stor11
                            if rewardTokenAddress == stor11:
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000))
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000))
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                                mem[644] = 64
                                mem[676] = 2
                                mem[708 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 608
                                require return_data.size >= 32
                                _4951 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                                require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 608]
                                _5001 = mem[_4951 + 608]
                                mem[ceil32(return_data.size) + 640 len floor32(mem[_4951 + 608])] = mem[_4951 + 640 len floor32(mem[_4951 + 608])]
                                mem[64] = (32 * _5001) + ceil32(return_data.size) + 640
                                require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                                _8253 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                                mem[(32 * _5001) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _5001) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                                mem[(32 * _5001) + ceil32(return_data.size) + 676] = _8253
                                mem[(32 * _5001) + ceil32(return_data.size) + 740] = this.address
                                mem[(32 * _5001) + ceil32(return_data.size) + 772] = block.timestamp
                                mem[(32 * _5001) + ceil32(return_data.size) + 708] = 160
                                mem[(32 * _5001) + ceil32(return_data.size) + 804] = 2
                                mem[(32 * _5001) + ceil32(return_data.size) + 836 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _8253, Array(len=2, data=mem[(32 * _5001) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _5001) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _5001) + (2 * ceil32(return_data.size)) + 640
                                require return_data.size >= 32
                                require mem[(32 * _5001) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _5001) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _5001) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5001) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _5001) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5001) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5001) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _8253, 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8253)
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8253)
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                        else:
                            mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                            mem[548] = 64
                            mem[580] = 2
                            mem[612 len 0] = None
                            require ext_code.size(routerAddress)
                            staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 512
                            require return_data.size >= 32
                            _4953 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                            require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 512]
                            _5002 = mem[_4953 + 512]
                            mem[ceil32(return_data.size) + 544 len floor32(mem[_4953 + 512])] = mem[_4953 + 544 len floor32(mem[_4953 + 512])]
                            mem[64] = (32 * _5002) + ceil32(return_data.size) + 544
                            require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                            _8257 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                            mem[(32 * _5002) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(32 * _5002) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                            mem[(32 * _5002) + ceil32(return_data.size) + 580] = _8257
                            mem[(32 * _5002) + ceil32(return_data.size) + 644] = this.address
                            mem[(32 * _5002) + ceil32(return_data.size) + 676] = block.timestamp
                            mem[(32 * _5002) + ceil32(return_data.size) + 612] = 160
                            mem[(32 * _5002) + ceil32(return_data.size) + 708] = 2
                            mem[(32 * _5002) + ceil32(return_data.size) + 740 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _8257, Array(len=2, data=mem[(32 * _5002) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _5002) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _5002) + (2 * ceil32(return_data.size)) + 544
                            require return_data.size >= 32
                            _11415 = mem[(32 * _5002) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                            require mem[(32 * _5002) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[(32 * _5002) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[(32 * _5002) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5002) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _5002) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5002) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5002) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                            mem[(32 * _5002) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _5002) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5002) + ceil32(return_data.size) + 544]
                            _11464 = mem[_11415 + (32 * _5002) + ceil32(return_data.size) + 544]
                            mem[(32 * _5002) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_11415 + (32 * _5002) + ceil32(return_data.size) + 544])] = mem[_11415 + (32 * _5002) + ceil32(return_data.size) + 576 len floor32(mem[_11415 + (32 * _5002) + ceil32(return_data.size) + 544])]
                            mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 576] = 2
                            mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                            mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 640] = stor11
                            if rewardTokenAddress == stor11:
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, _8257, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000))
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000))
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                                mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 708] = 64
                                mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 740] = 2
                                mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Array(len=2, data=mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 772 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 672
                                require return_data.size >= 32
                                _17484 = mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                                require mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                                mem[(32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672]
                                _17509 = mem[_17484 + (32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672]
                                mem[(32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_17484 + (32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672])] = mem[_17484 + (32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_17484 + (32 * _11464) + (32 * _5002) + (2 * ceil32(return_data.size)) + 672])]
                                mem[64] = (32 * _17509) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704
                                require mem[(32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 672]
                                _18550 = mem[(32 * mem[(32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704]
                                mem[(32 * _17509) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _17509) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                                mem[(32 * _17509) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 740] = _18550
                                mem[(32 * _17509) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 804] = this.address
                                mem[(32 * _17509) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                                mem[(32 * _17509) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 772] = 160
                                mem[(32 * _17509) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 868] = 2
                                mem[(32 * _17509) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _18550, Array(len=2, data=mem[(32 * _17509) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _17509) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _17509) + (32 * _11464) + (32 * _5002) + (6 * ceil32(return_data.size)) + 704
                                require return_data.size >= 32
                                require mem[(32 * _17509) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _17509) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _17509) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _17509) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _17509) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _17509) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _17509) + (32 * _11464) + (32 * _5002) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, _8257, _18550, 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18550)
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18550)
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                    else:
                        require 2 * ext_call.return_data[0]
                        if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 2 * ext_call.return_data[0] != REINVEST_REWARD_BIPS:
                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, arg4)
                        mem[160] = 26
                        mem[192] = 'SafeMath: division by zero'
                        if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 <= 0:
                            mem[224] = 31
                            mem[256] = 'SafeMath: subtraction underflow'
                            if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                                revert with 0, 'SafeMath: subtraction underflow'
                            mem[288] = 31
                            mem[320] = 'SafeMath: subtraction underflow'
                            if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 > (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000):
                                revert with 0, 'SafeMath: subtraction underflow'
                            mem[352] = 26
                            mem[384] = 'SafeMath: division by zero'
                            if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2 <= 0:
                                revert with 0, 'amount too low'
                            mem[416] = 2
                            mem[448] = rewardTokenAddress
                            mem[480] = stor10
                            if rewardTokenAddress == stor10:
                                mem[512] = 2
                                mem[544] = rewardTokenAddress
                                mem[576] = stor11
                                if rewardTokenAddress == stor11:
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                                else:
                                    mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[644] = 64
                                    mem[676] = 2
                                    mem[708 len 0] = None
                                    require ext_code.size(routerAddress)
                                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(return_data.size) + 608
                                    require return_data.size >= 32
                                    _4943 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                    require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                                    mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]
                                    _4997 = mem[_4943 + 608]
                                    mem[ceil32(return_data.size) + 640 len floor32(mem[_4943 + 608])] = mem[_4943 + 640 len floor32(mem[_4943 + 608])]
                                    mem[64] = (32 * _4997) + ceil32(return_data.size) + 640
                                    require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                                    _8237 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                                    mem[(32 * _4997) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _4997) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _4997) + ceil32(return_data.size) + 676] = _8237
                                    mem[(32 * _4997) + ceil32(return_data.size) + 740] = this.address
                                    mem[(32 * _4997) + ceil32(return_data.size) + 772] = block.timestamp
                                    mem[(32 * _4997) + ceil32(return_data.size) + 708] = 160
                                    mem[(32 * _4997) + ceil32(return_data.size) + 804] = 2
                                    mem[(32 * _4997) + ceil32(return_data.size) + 836 len 0] = None
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8237, Array(len=2, data=mem[(32 * _4997) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _4997) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _4997) + (2 * ceil32(return_data.size)) + 640
                                    require return_data.size >= 32
                                    require mem[(32 * _4997) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _4997) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _4997) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4997) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _4997) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _4997) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4997) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8237, 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8237)
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8237)
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[548] = 64
                                mem[580] = 2
                                mem[612 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 512
                                require return_data.size >= 32
                                _4945 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]
                                _4998 = mem[_4945 + 512]
                                mem[ceil32(return_data.size) + 544 len floor32(mem[_4945 + 512])] = mem[_4945 + 544 len floor32(mem[_4945 + 512])]
                                mem[64] = (32 * _4998) + ceil32(return_data.size) + 544
                                require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                                _8241 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                                mem[(32 * _4998) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _4998) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[(32 * _4998) + ceil32(return_data.size) + 580] = _8241
                                mem[(32 * _4998) + ceil32(return_data.size) + 644] = this.address
                                mem[(32 * _4998) + ceil32(return_data.size) + 676] = block.timestamp
                                mem[(32 * _4998) + ceil32(return_data.size) + 612] = 160
                                mem[(32 * _4998) + ceil32(return_data.size) + 708] = 2
                                mem[(32 * _4998) + ceil32(return_data.size) + 740 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8241, Array(len=2, data=mem[(32 * _4998) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _4998) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _4998) + (2 * ceil32(return_data.size)) + 544
                                require return_data.size >= 32
                                _11407 = mem[(32 * _4998) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[(32 * _4998) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _4998) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _4998) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4998) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _4998) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _4998) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4998) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                                mem[(32 * _4998) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _4998) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4998) + ceil32(return_data.size) + 544]
                                _11460 = mem[_11407 + (32 * _4998) + ceil32(return_data.size) + 544]
                                mem[(32 * _4998) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_11407 + (32 * _4998) + ceil32(return_data.size) + 544])] = mem[_11407 + (32 * _4998) + ceil32(return_data.size) + 576 len floor32(mem[_11407 + (32 * _4998) + ceil32(return_data.size) + 544])]
                                mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 576] = 2
                                mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                                mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 640] = stor11
                                if rewardTokenAddress == stor11:
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, _8241, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                                else:
                                    mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 708] = 64
                                    mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 740] = 2
                                    mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                                    require ext_code.size(routerAddress)
                                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 772 len 64])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 672
                                    require return_data.size >= 32
                                    _17480 = mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                    require mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                                    mem[(32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672]
                                    _17507 = mem[_17480 + (32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672]
                                    mem[(32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_17480 + (32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672])] = mem[_17480 + (32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_17480 + (32 * _11460) + (32 * _4998) + (2 * ceil32(return_data.size)) + 672])]
                                    mem[64] = (32 * _17507) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704
                                    require mem[(32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 672]
                                    _18542 = mem[(32 * mem[(32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704]
                                    mem[(32 * _17507) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _17507) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _17507) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 740] = _18542
                                    mem[(32 * _17507) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 804] = this.address
                                    mem[(32 * _17507) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                                    mem[(32 * _17507) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 772] = 160
                                    mem[(32 * _17507) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 868] = 2
                                    mem[(32 * _17507) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _18542, Array(len=2, data=mem[(32 * _17507) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _17507) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _17507) + (32 * _11460) + (32 * _4998) + (6 * ceil32(return_data.size)) + 704
                                    require return_data.size >= 32
                                    require mem[(32 * _17507) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _17507) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _17507) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17507) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _17507) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _17507) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17507) + (32 * _11460) + (32 * _4998) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, _8241, _18542, 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18542)
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18542)
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                        else:
                            require ext_code.size(rewardTokenAddress)
                            call rewardTokenAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                revert with 0, 'reinvest fee transfer failed'
                            mem[224] = 31
                            mem[256] = 'SafeMath: subtraction underflow'
                            if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                                revert with 0, 'SafeMath: subtraction underflow'
                            mem[288] = 31
                            mem[320] = 'SafeMath: subtraction underflow'
                            if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 > (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000):
                                revert with 0, 'SafeMath: subtraction underflow'
                            mem[352] = 26
                            mem[384] = 'SafeMath: division by zero'
                            if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2 <= 0:
                                revert with 0, 'amount too low'
                            mem[416] = 2
                            mem[448] = rewardTokenAddress
                            mem[480] = stor10
                            if rewardTokenAddress == stor10:
                                mem[512] = 2
                                mem[544] = rewardTokenAddress
                                mem[576] = stor11
                                if rewardTokenAddress == stor11:
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                                else:
                                    mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[644] = 64
                                    mem[676] = 2
                                    mem[708 len 0] = None
                                    require ext_code.size(routerAddress)
                                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(return_data.size) + 608
                                    require return_data.size >= 32
                                    _4947 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                    require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                                    mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]
                                    _4999 = mem[_4947 + 608]
                                    mem[ceil32(return_data.size) + 640 len floor32(mem[_4947 + 608])] = mem[_4947 + 640 len floor32(mem[_4947 + 608])]
                                    mem[64] = (32 * _4999) + ceil32(return_data.size) + 640
                                    require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                                    _8245 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                                    mem[(32 * _4999) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _4999) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _4999) + ceil32(return_data.size) + 676] = _8245
                                    mem[(32 * _4999) + ceil32(return_data.size) + 740] = this.address
                                    mem[(32 * _4999) + ceil32(return_data.size) + 772] = block.timestamp
                                    mem[(32 * _4999) + ceil32(return_data.size) + 708] = 160
                                    mem[(32 * _4999) + ceil32(return_data.size) + 804] = 2
                                    mem[(32 * _4999) + ceil32(return_data.size) + 836 len 0] = None
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8245, Array(len=2, data=mem[(32 * _4999) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _4999) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _4999) + (2 * ceil32(return_data.size)) + 640
                                    require return_data.size >= 32
                                    require mem[(32 * _4999) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _4999) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _4999) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4999) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _4999) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _4999) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _4999) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8245, 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8245)
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8245)
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[548] = 64
                                mem[580] = 2
                                mem[612 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 512
                                require return_data.size >= 32
                                _4949 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]
                                _5000 = mem[_4949 + 512]
                                mem[ceil32(return_data.size) + 544 len floor32(mem[_4949 + 512])] = mem[_4949 + 544 len floor32(mem[_4949 + 512])]
                                mem[64] = (32 * _5000) + ceil32(return_data.size) + 544
                                require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                                _8249 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                                mem[(32 * _5000) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _5000) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[(32 * _5000) + ceil32(return_data.size) + 580] = _8249
                                mem[(32 * _5000) + ceil32(return_data.size) + 644] = this.address
                                mem[(32 * _5000) + ceil32(return_data.size) + 676] = block.timestamp
                                mem[(32 * _5000) + ceil32(return_data.size) + 612] = 160
                                mem[(32 * _5000) + ceil32(return_data.size) + 708] = 2
                                mem[(32 * _5000) + ceil32(return_data.size) + 740 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8249, Array(len=2, data=mem[(32 * _5000) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _5000) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _5000) + (2 * ceil32(return_data.size)) + 544
                                require return_data.size >= 32
                                _11411 = mem[(32 * _5000) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[(32 * _5000) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _5000) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _5000) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5000) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _5000) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5000) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5000) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                                mem[(32 * _5000) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _5000) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5000) + ceil32(return_data.size) + 544]
                                _11462 = mem[_11411 + (32 * _5000) + ceil32(return_data.size) + 544]
                                mem[(32 * _5000) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_11411 + (32 * _5000) + ceil32(return_data.size) + 544])] = mem[_11411 + (32 * _5000) + ceil32(return_data.size) + 576 len floor32(mem[_11411 + (32 * _5000) + ceil32(return_data.size) + 544])]
                                mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 576] = 2
                                mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                                mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 640] = stor11
                                if rewardTokenAddress == stor11:
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, _8249, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                                else:
                                    mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 708] = 64
                                    mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 740] = 2
                                    mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                                    require ext_code.size(routerAddress)
                                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 772 len 64])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 672
                                    require return_data.size >= 32
                                    _17482 = mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                    require mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                                    mem[(32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672]
                                    _17508 = mem[_17482 + (32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672]
                                    mem[(32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_17482 + (32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672])] = mem[_17482 + (32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_17482 + (32 * _11462) + (32 * _5000) + (2 * ceil32(return_data.size)) + 672])]
                                    mem[64] = (32 * _17508) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704
                                    require mem[(32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 672]
                                    _18546 = mem[(32 * mem[(32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704]
                                    mem[(32 * _17508) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _17508) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _17508) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 740] = _18546
                                    mem[(32 * _17508) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 804] = this.address
                                    mem[(32 * _17508) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                                    mem[(32 * _17508) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 772] = 160
                                    mem[(32 * _17508) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 868] = 2
                                    mem[(32 * _17508) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _18546, Array(len=2, data=mem[(32 * _17508) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _17508) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _17508) + (32 * _11462) + (32 * _5000) + (6 * ceil32(return_data.size)) + 704
                                    require return_data.size >= 32
                                    require mem[(32 * _17508) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _17508) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _17508) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17508) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _17508) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _17508) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17508) + (32 * _11462) + (32 * _5000) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, _8249, _18546, 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18546)
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18546)
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                else:
                    require ext_code.size(rewardTokenAddress)
                    call rewardTokenAddress.0xa9059cbb with:
                         gas gas_remaining wei
                        args owner, (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if not ext_call.return_data[0]:
                        revert with 0, 'admin fee transfer failed'
                    if not uint255(ext_call.return_data[0]):
                        mem[160] = 26
                        mem[192] = 'SafeMath: division by zero'
                        mem[224] = 31
                        mem[256] = 'SafeMath: subtraction underflow'
                        if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                            revert with 0, 'SafeMath: subtraction underflow'
                        mem[288] = 31
                        mem[320] = 'SafeMath: subtraction underflow'
                        if 0 > (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000):
                            revert with 0, 'SafeMath: subtraction underflow'
                        mem[352] = 26
                        mem[384] = 'SafeMath: division by zero'
                        if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2 <= 0:
                            revert with 0, 'amount too low'
                        mem[416] = 2
                        mem[448] = rewardTokenAddress
                        mem[480] = stor10
                        if rewardTokenAddress == stor10:
                            mem[512] = 2
                            mem[544] = rewardTokenAddress
                            mem[576] = stor11
                            if rewardTokenAddress == stor11:
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000))
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000))
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                                mem[644] = 64
                                mem[676] = 2
                                mem[708 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 608
                                require return_data.size >= 32
                                _4963 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                                require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 608]
                                _5007 = mem[_4963 + 608]
                                mem[ceil32(return_data.size) + 640 len floor32(mem[_4963 + 608])] = mem[_4963 + 640 len floor32(mem[_4963 + 608])]
                                mem[64] = (32 * _5007) + ceil32(return_data.size) + 640
                                require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                                _8277 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                                mem[(32 * _5007) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _5007) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                                mem[(32 * _5007) + ceil32(return_data.size) + 676] = _8277
                                mem[(32 * _5007) + ceil32(return_data.size) + 740] = this.address
                                mem[(32 * _5007) + ceil32(return_data.size) + 772] = block.timestamp
                                mem[(32 * _5007) + ceil32(return_data.size) + 708] = 160
                                mem[(32 * _5007) + ceil32(return_data.size) + 804] = 2
                                mem[(32 * _5007) + ceil32(return_data.size) + 836 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _8277, Array(len=2, data=mem[(32 * _5007) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _5007) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _5007) + (2 * ceil32(return_data.size)) + 640
                                require return_data.size >= 32
                                require mem[(32 * _5007) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _5007) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _5007) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5007) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _5007) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5007) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5007) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _8277, 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8277)
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8277)
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                        else:
                            mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                            mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                            mem[548] = 64
                            mem[580] = 2
                            mem[612 len 0] = None
                            require ext_code.size(routerAddress)
                            staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                    gas gas_remaining wei
                                   args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 512
                            require return_data.size >= 32
                            _4965 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                            require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 512]
                            _5008 = mem[_4965 + 512]
                            mem[ceil32(return_data.size) + 544 len floor32(mem[_4965 + 512])] = mem[_4965 + 544 len floor32(mem[_4965 + 512])]
                            mem[64] = (32 * _5008) + ceil32(return_data.size) + 544
                            require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                            _8281 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                            mem[(32 * _5008) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[(32 * _5008) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                            mem[(32 * _5008) + ceil32(return_data.size) + 580] = _8281
                            mem[(32 * _5008) + ceil32(return_data.size) + 644] = this.address
                            mem[(32 * _5008) + ceil32(return_data.size) + 676] = block.timestamp
                            mem[(32 * _5008) + ceil32(return_data.size) + 612] = 160
                            mem[(32 * _5008) + ceil32(return_data.size) + 708] = 2
                            mem[(32 * _5008) + ceil32(return_data.size) + 740 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _8281, Array(len=2, data=mem[(32 * _5008) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[(32 * _5008) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = (32 * _5008) + (2 * ceil32(return_data.size)) + 544
                            require return_data.size >= 32
                            _11427 = mem[(32 * _5008) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                            require mem[(32 * _5008) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                            require mem[(32 * _5008) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                            require mem[mem[(32 * _5008) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5008) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _5008) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5008) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5008) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                            mem[(32 * _5008) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _5008) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _5008) + ceil32(return_data.size) + 544]
                            _11470 = mem[_11427 + (32 * _5008) + ceil32(return_data.size) + 544]
                            mem[(32 * _5008) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_11427 + (32 * _5008) + ceil32(return_data.size) + 544])] = mem[_11427 + (32 * _5008) + ceil32(return_data.size) + 576 len floor32(mem[_11427 + (32 * _5008) + ceil32(return_data.size) + 544])]
                            mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 576] = 2
                            mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                            mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 640] = stor11
                            if rewardTokenAddress == stor11:
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, _8281, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000))
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000))
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                                mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 708] = 64
                                mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 740] = 2
                                mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), Array(len=2, data=mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 772 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 672
                                require return_data.size >= 32
                                _17490 = mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32
                                require mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                                mem[(32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672]
                                _17512 = mem[_17490 + (32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672]
                                mem[(32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_17490 + (32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672])] = mem[_17490 + (32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_17490 + (32 * _11470) + (32 * _5008) + (2 * ceil32(return_data.size)) + 672])]
                                mem[64] = (32 * _17512) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704
                                require mem[(32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 672]
                                _18562 = mem[(32 * mem[(32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704]
                                mem[(32 * _17512) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _17512) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) / 2
                                mem[(32 * _17512) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 740] = _18562
                                mem[(32 * _17512) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 804] = this.address
                                mem[(32 * _17512) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                                mem[(32 * _17512) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 772] = 160
                                mem[(32 * _17512) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 868] = 2
                                mem[(32 * _17512) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)), _18562, Array(len=2, data=mem[(32 * _17512) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _17512) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _17512) + (32 * _11470) + (32 * _5008) + (6 * ceil32(return_data.size)) + 704
                                require return_data.size >= 32
                                require mem[(32 * _17512) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _17512) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _17512) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _17512) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _17512) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _17512) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000)) >> 32 + (32 * _17512) + (32 * _11470) + (32 * _5008) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                                require ext_code.size(routerAddress)
                                call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                     gas gas_remaining wei
                                    args stor10, stor11, _8281, _18562, 0, 0, address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 96
                                if ext_call.return_data[64] <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, ext_call.return_data[64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                    revert with 0, 'SafeMath: addition overflow'
                                totalDeposits += ext_call.return_data[64]
                                emit Reinvest(totalDeposits, totalSupply);
                                require ext_code.size(depositTokenAddress)
                                call depositTokenAddress.0x23b872dd with:
                                     gas gas_remaining wei
                                    args msg.sender, address(this.address), arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if not ext_call.return_data[0]:
                                    revert with 0, 'transferFrom failed'
                                if arg1 <= 0:
                                    revert with 0, 'amount too low'
                                require ext_code.size(stakingContractAddress)
                                call stakingContractAddress.0xe2bbb158 with:
                                     gas gas_remaining wei
                                    args PID, arg1
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not totalSupply:
                                    if totalSupply + arg1 < totalSupply:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalSupply += arg1
                                    if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    balanceOf[address(msg.sender)] += arg1
                                    emit Transfer(arg1, 0, msg.sender);
                                else:
                                    require totalSupply
                                    if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                        revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18562)
                                    if not totalSupply * totalDeposits:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        if not arg1:
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (0 / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += 0 / totalDeposits
                                            if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += 0 / totalDeposits
                                            emit Transfer((0 / totalDeposits), 0, msg.sender);
                                        else:
                                            require arg1
                                            if arg1 * totalSupply / arg1 != totalSupply:
                                                revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18562)
                                            if totalDeposits <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require totalDeposits
                                            if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1 * totalSupply / totalDeposits
                                            if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                            emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                    else:
                        require 2 * ext_call.return_data[0]
                        if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 2 * ext_call.return_data[0] != REINVEST_REWARD_BIPS:
                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, arg4)
                        mem[160] = 26
                        mem[192] = 'SafeMath: division by zero'
                        if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 <= 0:
                            mem[224] = 31
                            mem[256] = 'SafeMath: subtraction underflow'
                            if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                                revert with 0, 'SafeMath: subtraction underflow'
                            mem[288] = 31
                            mem[320] = 'SafeMath: subtraction underflow'
                            if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 > (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000):
                                revert with 0, 'SafeMath: subtraction underflow'
                            mem[352] = 26
                            mem[384] = 'SafeMath: division by zero'
                            if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2 <= 0:
                                revert with 0, 'amount too low'
                            mem[416] = 2
                            mem[448] = rewardTokenAddress
                            mem[480] = stor10
                            if rewardTokenAddress == stor10:
                                mem[512] = 2
                                mem[544] = rewardTokenAddress
                                mem[576] = stor11
                                if rewardTokenAddress == stor11:
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                                else:
                                    mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[644] = 64
                                    mem[676] = 2
                                    mem[708 len 0] = None
                                    require ext_code.size(routerAddress)
                                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(return_data.size) + 608
                                    require return_data.size >= 32
                                    _4955 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                    require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                                    mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]
                                    _5003 = mem[_4955 + 608]
                                    mem[ceil32(return_data.size) + 640 len floor32(mem[_4955 + 608])] = mem[_4955 + 640 len floor32(mem[_4955 + 608])]
                                    mem[64] = (32 * _5003) + ceil32(return_data.size) + 640
                                    require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                                    _8261 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                                    mem[(32 * _5003) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _5003) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _5003) + ceil32(return_data.size) + 676] = _8261
                                    mem[(32 * _5003) + ceil32(return_data.size) + 740] = this.address
                                    mem[(32 * _5003) + ceil32(return_data.size) + 772] = block.timestamp
                                    mem[(32 * _5003) + ceil32(return_data.size) + 708] = 160
                                    mem[(32 * _5003) + ceil32(return_data.size) + 804] = 2
                                    mem[(32 * _5003) + ceil32(return_data.size) + 836 len 0] = None
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8261, Array(len=2, data=mem[(32 * _5003) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _5003) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _5003) + (2 * ceil32(return_data.size)) + 640
                                    require return_data.size >= 32
                                    require mem[(32 * _5003) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _5003) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _5003) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5003) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _5003) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5003) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5003) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8261, 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8261)
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8261)
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[548] = 64
                                mem[580] = 2
                                mem[612 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 512
                                require return_data.size >= 32
                                _4957 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]
                                _5004 = mem[_4957 + 512]
                                mem[ceil32(return_data.size) + 544 len floor32(mem[_4957 + 512])] = mem[_4957 + 544 len floor32(mem[_4957 + 512])]
                                mem[64] = (32 * _5004) + ceil32(return_data.size) + 544
                                require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                                _8265 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                                mem[(32 * _5004) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _5004) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[(32 * _5004) + ceil32(return_data.size) + 580] = _8265
                                mem[(32 * _5004) + ceil32(return_data.size) + 644] = this.address
                                mem[(32 * _5004) + ceil32(return_data.size) + 676] = block.timestamp
                                mem[(32 * _5004) + ceil32(return_data.size) + 612] = 160
                                mem[(32 * _5004) + ceil32(return_data.size) + 708] = 2
                                mem[(32 * _5004) + ceil32(return_data.size) + 740 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8265, Array(len=2, data=mem[(32 * _5004) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _5004) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _5004) + (2 * ceil32(return_data.size)) + 544
                                require return_data.size >= 32
                                _11419 = mem[(32 * _5004) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[(32 * _5004) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _5004) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _5004) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5004) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _5004) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5004) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5004) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                                mem[(32 * _5004) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _5004) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5004) + ceil32(return_data.size) + 544]
                                _11466 = mem[_11419 + (32 * _5004) + ceil32(return_data.size) + 544]
                                mem[(32 * _5004) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_11419 + (32 * _5004) + ceil32(return_data.size) + 544])] = mem[_11419 + (32 * _5004) + ceil32(return_data.size) + 576 len floor32(mem[_11419 + (32 * _5004) + ceil32(return_data.size) + 544])]
                                mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 576] = 2
                                mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                                mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 640] = stor11
                                if rewardTokenAddress == stor11:
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, _8265, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                                else:
                                    mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 708] = 64
                                    mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 740] = 2
                                    mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                                    require ext_code.size(routerAddress)
                                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 772 len 64])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 672
                                    require return_data.size >= 32
                                    _17486 = mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                    require mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                                    mem[(32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672]
                                    _17510 = mem[_17486 + (32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672]
                                    mem[(32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_17486 + (32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672])] = mem[_17486 + (32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_17486 + (32 * _11466) + (32 * _5004) + (2 * ceil32(return_data.size)) + 672])]
                                    mem[64] = (32 * _17510) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704
                                    require mem[(32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 672]
                                    _18554 = mem[(32 * mem[(32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704]
                                    mem[(32 * _17510) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _17510) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _17510) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 740] = _18554
                                    mem[(32 * _17510) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 804] = this.address
                                    mem[(32 * _17510) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                                    mem[(32 * _17510) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 772] = 160
                                    mem[(32 * _17510) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 868] = 2
                                    mem[(32 * _17510) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _18554, Array(len=2, data=mem[(32 * _17510) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _17510) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _17510) + (32 * _11466) + (32 * _5004) + (6 * ceil32(return_data.size)) + 704
                                    require return_data.size >= 32
                                    require mem[(32 * _17510) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _17510) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _17510) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17510) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _17510) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _17510) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17510) + (32 * _11466) + (32 * _5004) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, _8265, _18554, 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18554)
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18554)
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                        else:
                            require ext_code.size(rewardTokenAddress)
                            call rewardTokenAddress.0xa9059cbb with:
                                 gas gas_remaining wei
                                args msg.sender, (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if not ext_call.return_data[0]:
                                revert with 0, 'reinvest fee transfer failed'
                            mem[224] = 31
                            mem[256] = 'SafeMath: subtraction underflow'
                            if (ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000 > 2 * ext_call.return_data[0]:
                                revert with 0, 'SafeMath: subtraction underflow'
                            mem[288] = 31
                            mem[320] = 'SafeMath: subtraction underflow'
                            if (ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000 > (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000):
                                revert with 0, 'SafeMath: subtraction underflow'
                            mem[352] = 26
                            mem[384] = 'SafeMath: division by zero'
                            if (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2 <= 0:
                                revert with 0, 'amount too low'
                            mem[416] = 2
                            mem[448] = rewardTokenAddress
                            mem[480] = stor10
                            if rewardTokenAddress == stor10:
                                mem[512] = 2
                                mem[544] = rewardTokenAddress
                                mem[576] = stor11
                                if rewardTokenAddress == stor11:
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                                else:
                                    mem[608] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[612] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[644] = 64
                                    mem[676] = 2
                                    mem[708 len 0] = None
                                    require ext_code.size(routerAddress)
                                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[708 len 64])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[608 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(return_data.size) + 608
                                    require return_data.size >= 32
                                    _4959 = mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                    require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608] <= 4294967296 and mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]) + 32 <= return_data.size
                                    mem[ceil32(return_data.size) + 608] = mem[mem[608 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 608]
                                    _5005 = mem[_4959 + 608]
                                    mem[ceil32(return_data.size) + 640 len floor32(mem[_4959 + 608])] = mem[_4959 + 640 len floor32(mem[_4959 + 608])]
                                    mem[64] = (32 * _5005) + ceil32(return_data.size) + 640
                                    require mem[ceil32(return_data.size) + 608] - 1 < mem[ceil32(return_data.size) + 608]
                                    _8269 = mem[(32 * mem[ceil32(return_data.size) + 608] - 1) + ceil32(return_data.size) + 640]
                                    mem[(32 * _5005) + ceil32(return_data.size) + 640] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _5005) + ceil32(return_data.size) + 644] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _5005) + ceil32(return_data.size) + 676] = _8269
                                    mem[(32 * _5005) + ceil32(return_data.size) + 740] = this.address
                                    mem[(32 * _5005) + ceil32(return_data.size) + 772] = block.timestamp
                                    mem[(32 * _5005) + ceil32(return_data.size) + 708] = 160
                                    mem[(32 * _5005) + ceil32(return_data.size) + 804] = 2
                                    mem[(32 * _5005) + ceil32(return_data.size) + 836 len 0] = None
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8269, Array(len=2, data=mem[(32 * _5005) + ceil32(return_data.size) + 836 len 64]), address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _5005) + ceil32(return_data.size) + 640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _5005) + (2 * ceil32(return_data.size)) + 640
                                    require return_data.size >= 32
                                    require mem[(32 * _5005) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _5005) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _5005) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5005) + ceil32(return_data.size) + 640] <= 4294967296 and mem[(32 * _5005) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5005) + ceil32(return_data.size) + 640 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5005) + ceil32(return_data.size) + 640]) + 32 <= return_data.size
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8269, 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8269)
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _8269)
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                            else:
                                mem[512] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                mem[516] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[548] = 64
                                mem[580] = 2
                                mem[612 len 0] = None
                                require ext_code.size(routerAddress)
                                staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                        gas gas_remaining wei
                                       args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[612 len 64])
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[512 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 512
                                require return_data.size >= 32
                                _4961 = mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512] <= 4294967296 and mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 512] = mem[mem[512 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 512]
                                _5006 = mem[_4961 + 512]
                                mem[ceil32(return_data.size) + 544 len floor32(mem[_4961 + 512])] = mem[_4961 + 544 len floor32(mem[_4961 + 512])]
                                mem[64] = (32 * _5006) + ceil32(return_data.size) + 544
                                require mem[ceil32(return_data.size) + 512] - 1 < mem[ceil32(return_data.size) + 512]
                                _8273 = mem[(32 * mem[ceil32(return_data.size) + 512] - 1) + ceil32(return_data.size) + 544]
                                mem[(32 * _5006) + ceil32(return_data.size) + 544] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                mem[(32 * _5006) + ceil32(return_data.size) + 548] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                mem[(32 * _5006) + ceil32(return_data.size) + 580] = _8273
                                mem[(32 * _5006) + ceil32(return_data.size) + 644] = this.address
                                mem[(32 * _5006) + ceil32(return_data.size) + 676] = block.timestamp
                                mem[(32 * _5006) + ceil32(return_data.size) + 612] = 160
                                mem[(32 * _5006) + ceil32(return_data.size) + 708] = 2
                                mem[(32 * _5006) + ceil32(return_data.size) + 740 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _8273, Array(len=2, data=mem[(32 * _5006) + ceil32(return_data.size) + 740 len 64]), address(this.address), block.timestamp
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[(32 * _5006) + ceil32(return_data.size) + 544 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = (32 * _5006) + (2 * ceil32(return_data.size)) + 544
                                require return_data.size >= 32
                                _11423 = mem[(32 * _5006) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                require mem[(32 * _5006) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                require mem[(32 * _5006) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                require mem[mem[(32 * _5006) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5006) + ceil32(return_data.size) + 544] <= 4294967296 and mem[(32 * _5006) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _5006) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5006) + ceil32(return_data.size) + 544]) + 32 <= return_data.size
                                mem[(32 * _5006) + (2 * ceil32(return_data.size)) + 544] = mem[mem[(32 * _5006) + ceil32(return_data.size) + 544 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _5006) + ceil32(return_data.size) + 544]
                                _11468 = mem[_11423 + (32 * _5006) + ceil32(return_data.size) + 544]
                                mem[(32 * _5006) + (2 * ceil32(return_data.size)) + 576 len floor32(mem[_11423 + (32 * _5006) + ceil32(return_data.size) + 544])] = mem[_11423 + (32 * _5006) + ceil32(return_data.size) + 576 len floor32(mem[_11423 + (32 * _5006) + ceil32(return_data.size) + 544])]
                                mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 576] = 2
                                mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 608] = rewardTokenAddress
                                mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 640] = stor11
                                if rewardTokenAddress == stor11:
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, _8273, Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                Mask(247, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000))
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
                                else:
                                    mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672] = 0xd06ca61f00000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 676] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 708] = 64
                                    mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 740] = 2
                                    mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 772 len 0] = None
                                    require ext_code.size(routerAddress)
                                    staticcall routerAddress.getAmountsOut(uint256 rg1, address[] rg2) with:
                                            gas gas_remaining wei
                                           args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), Array(len=2, data=mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 772 len 64])
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 672
                                    require return_data.size >= 32
                                    _17488 = mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32
                                    require mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672] <= 4294967296 and mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672]) + 32 <= return_data.size
                                    mem[(32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 672] = mem[mem[(32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672]
                                    _17511 = mem[_17488 + (32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672]
                                    mem[(32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704 len floor32(mem[_17488 + (32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672])] = mem[_17488 + (32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 704 len floor32(mem[_17488 + (32 * _11468) + (32 * _5006) + (2 * ceil32(return_data.size)) + 672])]
                                    mem[64] = (32 * _17511) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704
                                    require mem[(32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 672] - 1 < mem[(32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 672]
                                    _18558 = mem[(32 * mem[(32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 672] - 1) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704]
                                    mem[(32 * _17511) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _17511) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 708] = (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000) / 2
                                    mem[(32 * _17511) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 740] = _18558
                                    mem[(32 * _17511) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 804] = this.address
                                    mem[(32 * _17511) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 836] = block.timestamp
                                    mem[(32 * _17511) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 772] = 160
                                    mem[(32 * _17511) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 868] = 2
                                    mem[(32 * _17511) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 900 len 0] = None
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args Mask(255, 1, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)), _18558, Array(len=2, data=mem[(32 * _17511) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 900 len 64]), address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[(32 * _17511) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = (32 * _17511) + (32 * _11468) + (32 * _5006) + (6 * ceil32(return_data.size)) + 704
                                    require return_data.size >= 32
                                    require mem[(32 * _17511) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 <= 4294967296
                                    require mem[(32 * _17511) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + 32 <= return_data.size
                                    require mem[mem[(32 * _17511) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17511) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704] <= 4294967296 and mem[(32 * _17511) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * mem[mem[(32 * _17511) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704 len 4], Mask(224, 32, (2 * ext_call.return_data[0]) - ((ext_call.return_data[0] * ADMIN_FEE_BIPS) + (ext_call.return_data[0] * ADMIN_FEE_BIPS) / 10000) - ((ext_call.return_data[0] * REINVEST_REWARD_BIPS) + (ext_call.return_data[0] * REINVEST_REWARD_BIPS) / 10000)) >> 32 + (32 * _17511) + (32 * _11468) + (32 * _5006) + (4 * ceil32(return_data.size)) + 704]) + 32 <= return_data.size
                                    require ext_code.size(routerAddress)
                                    call routerAddress.addLiquidity(address rg1, address rg2, uint256 rg3, uint256 rg4, uint256 rg5, uint256 rg6, address rg7, uint256 rg8) with:
                                         gas gas_remaining wei
                                        args stor10, stor11, _8273, _18558, 0, 0, address(this.address), block.timestamp
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 96
                                    if ext_call.return_data[64] <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, ext_call.return_data[64]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if totalDeposits + ext_call.return_data[64] < totalDeposits:
                                        revert with 0, 'SafeMath: addition overflow'
                                    totalDeposits += ext_call.return_data[64]
                                    emit Reinvest(totalDeposits, totalSupply);
                                    require ext_code.size(depositTokenAddress)
                                    call depositTokenAddress.0x23b872dd with:
                                         gas gas_remaining wei
                                        args msg.sender, address(this.address), arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'transferFrom failed'
                                    if arg1 <= 0:
                                        revert with 0, 'amount too low'
                                    require ext_code.size(stakingContractAddress)
                                    call stakingContractAddress.0xe2bbb158 with:
                                         gas gas_remaining wei
                                        args PID, arg1
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not totalSupply:
                                        if totalSupply + arg1 < totalSupply:
                                            revert with 0, 'SafeMath: addition overflow'
                                        totalSupply += arg1
                                        if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        balanceOf[address(msg.sender)] += arg1
                                        emit Transfer(arg1, 0, msg.sender);
                                    else:
                                        require totalSupply
                                        if totalSupply * totalDeposits / totalSupply != totalDeposits:
                                            revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18558)
                                        if not totalSupply * totalDeposits:
                                            if totalSupply + arg1 < totalSupply:
                                                revert with 0, 'SafeMath: addition overflow'
                                            totalSupply += arg1
                                            if balanceOf[address(msg.sender)] + arg1 < balanceOf[address(msg.sender)]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            balanceOf[address(msg.sender)] += arg1
                                            emit Transfer(arg1, 0, msg.sender);
                                        else:
                                            if not arg1:
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (0 / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += 0 / totalDeposits
                                                if balanceOf[address(msg.sender)] + (0 / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += 0 / totalDeposits
                                                emit Transfer((0 / totalDeposits), 0, msg.sender);
                                            else:
                                                require arg1
                                                if arg1 * totalSupply / arg1 != totalSupply:
                                                    revert with 0, 32, 33, 0x79536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, Mask(248, 0, _18558)
                                                if totalDeposits <= 0:
                                                    revert with 0, 'SafeMath: division by zero'
                                                require totalDeposits
                                                if totalSupply + (arg1 * totalSupply / totalDeposits) < totalSupply:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                totalSupply += arg1 * totalSupply / totalDeposits
                                                if balanceOf[address(msg.sender)] + (arg1 * totalSupply / totalDeposits) < balanceOf[address(msg.sender)]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                balanceOf[address(msg.sender)] += arg1 * totalSupply / totalDeposits
                                                emit Transfer((arg1 * totalSupply / totalDeposits), 0, msg.sender);
    if totalDeposits + arg1 < totalDeposits:
        revert with 0, 'SafeMath: addition overflow'
    totalDeposits += arg1
    emit Deposit(arg1, msg.sender);
}



}

contract main {




// =====================  Runtime code  =====================


#
#  - sub_1878969f(?)
#  - sub_2ba7f407(?)
#  - _getNodesRewardAvailable(address arg1)
#  - sub_4d265b69(?)
#  - _getNodeRewardAmountOf(address arg1, uint256 arg2)
#  - _cashoutNodeReward(address arg1, uint256 arg2)
#  - _getRewardAmountOf(address arg1, uint256 arg2)
#  - sub_ad752006(?)
#  - sub_dfe5ae55(?)
#  - sub_f482212c(?)
#
uint8 stor0; offset 160
address stor0;
uint256 stor0;
mapping of uint8 stor1;
uint256 stor2;
uint256 stor3;
address zeusAddress;
address sub_85c2d7b2Address;
array of struct sub_2c534595;
mapping of address _referrals;
mapping of uint256 sub_e27e434a;
mapping of uint256 sub_666755bb;
array of struct sub_139fae2c;
uint256 totalNodes;
uint256 nodePrice;
uint256 rewardPerNode;
uint256 claimTime;
uint256 sub_20e8ce9b;
address gateKeeperAddress;
address tokenAddress;
uint256 totalNodesCreated;
uint256 totalRewardStaked;
uint256 referralBonusPercent;
uint256 sub_b137b854;
uint256 sub_af89f87c;
uint256 claimDuration;
uint32 sub_55f65c2d;

function sub_139fae2c(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_139fae2c[address(arg1)].field_0
}

function sub_20e8ce9b(?) payable {
    return sub_20e8ce9b
}

function claimTime() payable {
    return claimTime
}

function sub_2c534595(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_2c534595[address(arg1)].field_0
}

function gateKeeper() payable {
    return gateKeeperAddress
}

function sub_55f65c2d(?) payable {
    return sub_55f65c2d
}

function rewardPerNode() payable {
    return rewardPerNode
}

function sub_666755bb(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_666755bb[arg1]
}

function Zeus() payable {
    return zeusAddress
}

function sub_85c2d7b2(?) payable {
    return sub_85c2d7b2Address
}

function _referrals(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return _referrals[arg1]
}

function totalRewardStaked() payable {
    return totalRewardStaked
}

function totalNodes() payable {
    return totalNodes
}

function sub_989baf69(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 < sub_139fae2c[arg1].field_0
    return sub_139fae2c[arg1][arg2].field_0
}

function claimDuration() payable {
    return claimDuration
}

function sub_af89f87c(?) payable {
    return sub_af89f87c
}

function sub_b137b854(?) payable {
    return sub_b137b854
}

function totalNodesCreated() payable {
    return totalNodesCreated
}

function sub_ba370651(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    return bool(uint8(stor1[arg1][arg2]))
}

function sub_e27e434a(?) payable {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    return sub_e27e434a[arg1][arg2]
}

function referralBonusPercent() payable {
    return referralBonusPercent
}

function nodePrice() payable {
    return nodePrice
}

function token() payable {
    return tokenAddress
}

function _fallback() payable {
    revert
}

function sub_14b80630(?) payable {
    if uint8(stor0.field_160):
        revert with 0, 'ALREADY INITIALIZED'
    uint256(stor0.field_0) = msg.sender or Mask(96, 160, uint256(stor0.field_0))
}

function sub_da5f051c(?) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    nodePrice = arg1
}

function sub_0df5c9d2(?) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    sub_af89f87c = arg1
}

function sub_491951f6(?) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    sub_20e8ce9b = arg1
}

function sub_d9b3d6db(?) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    sub_b137b854 = arg1
}

function sub_288aeb95(?) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    rewardPerNode = arg1
}

function sub_87fe57b9(?) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    claimDuration = arg1
}

function _changeNodePrice(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    nodePrice = arg1
}

function _changeClaimTime(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    claimTime = arg1
}

function _changeRewardPerNode(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    rewardPerNode = arg1
}

function setReferralBonus(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    referralBonusPercent = arg1
}

function sub_0e8f548c(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == uint32(arg1)
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    sub_55f65c2d = uint32(arg1)
}

function sub_f4887f15(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    gateKeeperAddress = address(arg1)
}

function sub_b8c7a1a2(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    return sub_666755bb[address(arg1)]
}

function sub_f3a769e3(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    sub_85c2d7b2Address = address(arg1)
}

function setToken(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    zeusAddress = arg1
    tokenAddress = arg1
}

function sub_d2b6fc4c(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    sub_666755bb[address(arg1)] = 0
    return sub_666755bb[address(arg1)]
}

function _getNodeNumberOf(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    delegate 0x62a28b6b72bb5660963b927e7af15b30f88aabf2.0x732a2ccf with:
         gas gas_remaining wei
        args 6, arg1
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return delegate.return_data[0]
}

function _isNodeOwner(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    delegate 0x62a28b6b72bb5660963b927e7af15b30f88aabf2.0x732a2ccf with:
         gas gas_remaining wei
        args 6, arg1
    if not delegate.return_code:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return (delegate.return_data[0] > 0)
}

function sub_58045442(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    require ext_code.size(zeusAddress)
    call zeusAddress.0xf2fde38b with:
         gas gas_remaining wei
        args address(arg1)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function init() payable {
    if uint8(stor0.field_160):
        revert with 0, 'ALREADY INITIALIZED'
    uint256(stor0.field_0) = msg.sender or Mask(96, 160, uint256(stor0.field_0))
    uint8(stor0.field_160) = 1
    nodePrice = 3 * 10^18
    rewardPerNode = 347222222222
    claimTime = 1
    gateKeeperAddress = 0xb223d4e661ecf6ced8bb6c99edb87b3331cbd7e3
    tokenAddress = 0x6ea3188a7dddae3ab79937a974390c4ae1c06a1
    zeusAddress = 0x6ea3188a7dddae3ab79937a974390c4ae1c06a1
    totalNodesCreated = 1000
    totalRewardStaked = 1000
}

function getReferrals(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    mem[64] = (32 * sub_139fae2c[address(arg1)].field_0) + 128
    mem[96] = sub_139fae2c[address(arg1)].field_0
    if not sub_139fae2c[address(arg1)].field_0:
        mem[(32 * sub_139fae2c[address(arg1)].field_0) + 128] = 32
        mem[(32 * sub_139fae2c[address(arg1)].field_0) + 160] = sub_139fae2c[address(arg1)].field_0
        idx = 0
        s = (32 * sub_139fae2c[address(arg1)].field_0) + 192
        t = 128
        while idx < sub_139fae2c[address(arg1)].field_0:
            mem[s] = mem[t + 12 len 20]
            idx = idx + 1
            s = s + 32
            t = t + 32
            continue 
        return memory
          from (32 * sub_139fae2c[address(arg1)].field_0) + 128
           len (96 * sub_139fae2c[address(arg1)].field_0) + 64
    mem[128] = sub_139fae2c[address(arg1)].field_0
    idx = 128
    s = 0
    while (32 * sub_139fae2c[address(arg1)].field_0) + 96 > idx:
        mem[idx + 32] = sub_139fae2c[address(arg1)][s].field_256
        idx = idx + 32
        s = s + 1
        continue 
    mem[(32 * sub_139fae2c[address(arg1)].field_0) + 128] = 32
    mem[(32 * sub_139fae2c[address(arg1)].field_0) + 160] = sub_139fae2c[address(arg1)].field_0
    idx = 0
    s = mem[64] + 64
    t = 128
    while idx < sub_139fae2c[address(arg1)].field_0:
        mem[s] = mem[t + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    return memory
      from mem[64]
       len (64 * sub_139fae2c[address(arg1)].field_0) + -mem[64] + 192
}

function finalizeMigration() payable {
    if tokenAddress != msg.sender:
        if gateKeeperAddress != msg.sender:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
    require ext_code.size(zeusAddress)
    call zeusAddress.changeNodePrice(uint256 arg1) with:
         gas gas_remaining wei
        args -1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require ext_code.size(zeusAddress)
    call zeusAddress.changeRewardPerNode(uint256 arg1) with:
         gas gas_remaining wei
        args 0
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require ext_code.size(zeusAddress)
    call zeusAddress.changeClaimTime(uint256 arg1) with:
         gas gas_remaining wei
        args -1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    call zeusAddress.getTotalCreatedNodes() with:
         gas gas_remaining wei
    require return_data.size >= 32
    totalNodesCreated = ext_call.return_data[0]
    call zeusAddress.getTotalStakedReward() with:
         gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    totalRewardStaked = ext_call.return_data[0]
    require ext_code.size(zeusAddress)
    call zeusAddress.0xfb0a7494 with:
         gas gas_remaining wei
        args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    staticcall zeusAddress.nodeRewardManager() with:
            gas gas_remaining wei
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if ext_call.return_data[12 len 20] != this.address:
        revert with 0, 'UPDATING NODE MANAGER FAILED!'
    require ext_code.size(zeusAddress)
    call zeusAddress.0xf2fde38b with:
         gas gas_remaining wei
        args gateKeeperAddress
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    staticcall zeusAddress.0x8da5cb5b with:
            gas gas_remaining wei
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    if ext_call.return_data[12 len 20] != 0xb223d4e661ecf6ced8bb6c99edb87b3331cbd7e3:
        revert with 0, 'UPDATING OWNER FAILED!'
    stor2 = block.timestamp
    stor3 = block.number
}

function _nodesOfUser(address arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 < sub_2c534595[arg1].field_0
    if sub_2c534595[arg1][arg2].field_0:
        if not sub_2c534595[arg1][arg2].field_0 - (uint255(sub_2c534595[arg1][arg2].field_0) * 0.5 < 32):
            revert with 0, 34
        if sub_2c534595[arg1][arg2].field_0:
            if not sub_2c534595[arg1][arg2].field_0 - (uint255(sub_2c534595[arg1][arg2].field_0) * 0.5 < 32):
                revert with 0, 34
            if Mask(256, -1, sub_2c534595[arg1][arg2].field_0):
                if 31 >= uint255(sub_2c534595[arg1][arg2].field_0) * 0.5:
                    mem[128] = 256 * sub_2c534595[arg1][arg2].field_8
                else:
                    mem[128] = sub_2c534595[arg1][arg2].field_0
                    idx = 128
                    s = 0
                    while (uint255(sub_2c534595[arg1][arg2].field_0) * 0.5) + 96 > idx:
                        mem[idx + 32] = sub_2c534595[arg1][(5 * arg2) + s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
        else:
            if not sub_2c534595[arg1][arg2].field_0 - (sub_2c534595[arg1][arg2].field_1 < 32):
                revert with 0, 34
            if sub_2c534595[arg1][arg2].field_1:
                if 31 >= sub_2c534595[arg1][arg2].field_1:
                    mem[128] = 256 * sub_2c534595[arg1][arg2].field_8
                else:
                    mem[128] = sub_2c534595[arg1][arg2].field_0
                    idx = 128
                    s = 0
                    while sub_2c534595[arg1][arg2].field_1 + 96 > idx:
                        mem[idx + 32] = sub_2c534595[arg1][(5 * arg2) + s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
        return Array(len=2 * Mask(256, -1, sub_2c534595[arg1][arg2].field_0), data=mem[128 len ceil32(uint255(sub_2c534595[arg1][arg2].field_0) * 0.5)]), 
               sub_2c534595[arg1][arg2].field_256,
               sub_2c534595[arg1][arg2].field_512,
               sub_2c534595[arg1][arg2].field_768,
               sub_2c534595[arg1][arg2].field_1024
    if not sub_2c534595[arg1][arg2].field_0 - (sub_2c534595[arg1][arg2].field_1 < 32):
        revert with 0, 34
    if sub_2c534595[arg1][arg2].field_0:
        if not sub_2c534595[arg1][arg2].field_0 - (uint255(sub_2c534595[arg1][arg2].field_0) * 0.5 < 32):
            revert with 0, 34
        if Mask(256, -1, sub_2c534595[arg1][arg2].field_0):
            if 31 >= uint255(sub_2c534595[arg1][arg2].field_0) * 0.5:
                mem[128] = 256 * sub_2c534595[arg1][arg2].field_8
            else:
                mem[128] = sub_2c534595[arg1][arg2].field_0
                idx = 128
                s = 0
                while (uint255(sub_2c534595[arg1][arg2].field_0) * 0.5) + 96 > idx:
                    mem[idx + 32] = sub_2c534595[arg1][(5 * arg2) + s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
    else:
        if not sub_2c534595[arg1][arg2].field_0 - (sub_2c534595[arg1][arg2].field_1 < 32):
            revert with 0, 34
        if sub_2c534595[arg1][arg2].field_1:
            if 31 >= sub_2c534595[arg1][arg2].field_1:
                mem[128] = 256 * sub_2c534595[arg1][arg2].field_8
            else:
                mem[128] = sub_2c534595[arg1][arg2].field_0
                idx = 128
                s = 0
                while sub_2c534595[arg1][arg2].field_1 + 96 > idx:
                    mem[idx + 32] = sub_2c534595[arg1][(5 * arg2) + s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
    return Array(len=sub_2c534595[arg1][arg2].field_0, data=mem[128 len ceil32(sub_2c534595[arg1][arg2].field_1)]), 
           sub_2c534595[arg1][arg2].field_256,
           sub_2c534595[arg1][arg2].field_512,
           sub_2c534595[arg1][arg2].field_768,
           sub_2c534595[arg1][arg2].field_1024
}

function _getNodesNames(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[0] = arg1
    mem[32] = 10
    mem[64] = (32 * sub_2c534595[address(arg1)].field_0) + 128
    mem[96] = sub_2c534595[address(arg1)].field_0
    s = 128
    idx = 0
    while idx < sub_2c534595[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 10)
        _50 = mem[64]
        mem[64] = mem[64] + 160
        if sub_2c534595[address(arg1)][idx].field_0:
            if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                revert with 0, 34
            _56 = mem[64]
            mem[64] = mem[64] + ceil32(uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) + 32
            mem[_56] = uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5
            if sub_2c534595[address(arg1)][idx].field_0:
                if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                    revert with 0, 34
                if Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                    if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                        mem[_56 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                    else:
                        mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                        mem[_56 + 32] = sub_2c534595[address(arg1)][idx].field_0
                        t = _56 + 32
                        u = sha3(mem[0])
                        while _56 + (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                mem[_50] = _56
                mem[_50 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_50 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_50 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_50 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _50
                s = s + 32
                idx = idx + 1
                continue 
            if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                revert with 0, 34
            if not sub_2c534595[address(arg1)][idx].field_1:
                mem[_50] = _56
                mem[_50 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_50 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_50 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_50 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _50
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                mem[_56 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                mem[_50] = _56
                mem[_50 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_50 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_50 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_50 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _50
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
            mem[_56 + 32] = sub_2c534595[address(arg1)][idx].field_0
            t = _56 + 32
            u = sha3(mem[0])
            while _56 + sub_2c534595[address(arg1)][u].field_1 > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_50] = _56
            mem[_50 + 32] = sub_2c534595[address(arg1)][u].field_256
            mem[_50 + 64] = sub_2c534595[address(arg1)][u].field_512
            mem[_50 + 96] = sub_2c534595[address(arg1)][u].field_768
            mem[_50 + 128] = sub_2c534595[address(arg1)][u].field_1024
            mem[t] = _50
            t = t + 32
            u = u + 1
            continue 
        if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
            revert with 0, 34
        _58 = mem[64]
        mem[64] = mem[64] + ceil32(sub_2c534595[address(arg1)][idx].field_1) + 32
        mem[_58] = sub_2c534595[address(arg1)][idx].field_1
        if sub_2c534595[address(arg1)][idx].field_0:
            if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                revert with 0, 34
            if not Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                mem[_50] = _58
                mem[_50 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_50 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_50 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_50 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _50
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                mem[_58 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                mem[_50] = _58
                mem[_50 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_50 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_50 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_50 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _50
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
            mem[_58 + 32] = sub_2c534595[address(arg1)][idx].field_0
            t = _58 + 32
            u = sha3(mem[0])
            while _58 + (uint255(sub_2c534595[address(arg1)][u].field_0) * 0.5) > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_50] = _58
            mem[_50 + 32] = sub_2c534595[address(arg1)][u].field_256
            mem[_50 + 64] = sub_2c534595[address(arg1)][u].field_512
            mem[_50 + 96] = sub_2c534595[address(arg1)][u].field_768
            mem[_50 + 128] = sub_2c534595[address(arg1)][u].field_1024
            mem[t] = _50
            t = t + 32
            u = u + 1
            continue 
        if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
            revert with 0, 34
        if sub_2c534595[address(arg1)][idx].field_1:
            if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                mem[_58 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
            else:
                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                mem[_58 + 32] = sub_2c534595[address(arg1)][idx].field_0
                t = _58 + 32
                u = sha3(mem[0])
                while _58 + sub_2c534595[address(arg1)][idx].field_1 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
        mem[_50] = _58
        mem[_50 + 32] = sub_2c534595[address(arg1)][idx].field_256
        mem[_50 + 64] = sub_2c534595[address(arg1)][idx].field_512
        mem[_50 + 96] = sub_2c534595[address(arg1)][idx].field_768
        mem[_50 + 128] = sub_2c534595[address(arg1)][idx].field_1024
        mem[s] = _50
        s = s + 32
        idx = idx + 1
        continue 
    _48 = mem[96]
    _51 = mem[64]
    mem[64] = mem[64] + 160
    mem[_51] = 96
    mem[_51 + 32] = 0
    mem[_51 + 64] = 0
    mem[_51 + 96] = 0
    mem[_51 + 128] = 0
    if 0 >= mem[96]:
        revert with 0, 50
    _54 = mem[mem[128]]
    _55 = mem[64]
    mem[64] = mem[64] + 64
    mem[_55] = 1
    mem[_55 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
    idx = 1
    s = _54
    t = _51
    while idx < _48:
        if idx >= mem[96]:
            revert with 0, 50
        _95 = mem[(32 * idx) + 128]
        _96 = mem[mem[(32 * idx) + 128]]
        _97 = mem[64]
        _98 = mem[s]
        t = 0
        while t < _98:
            mem[t + _97 + 32] = mem[t + s + 32]
            t = t + 32
            continue 
        if ceil32(_98) <= _98:
            _126 = mem[_55]
            s = 0
            while s < _126:
                mem[s + _97 + _98 + 32] = mem[s + _55 + 32]
                s = s + 32
                continue 
            if ceil32(_126) <= _126:
                _150 = mem[_96]
                s = 0
                while s < _150:
                    mem[s + _97 + _98 + _126 + 32] = mem[s + _96 + 32]
                    s = s + 32
                    continue 
                if ceil32(_150) <= _150:
                    _170 = mem[64]
                    mem[mem[64]] = _150 + _97 + _98 + _126 - mem[64]
                    mem[64] = _150 + _97 + _98 + _126 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _170
                    t = _95
                    continue 
                mem[_150 + _97 + _98 + _126 + 32] = 0
                _171 = mem[64]
                mem[mem[64]] = _150 + _97 + _98 + _126 - mem[64]
                mem[64] = _150 + _97 + _98 + _126 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _171
                t = _95
                continue 
            mem[_126 + _97 + _98 + 32] = 0
            _151 = mem[_96]
            s = 0
            while s < _151:
                mem[s + _97 + _98 + _126 + 32] = mem[s + _96 + 32]
                s = s + 32
                continue 
            if ceil32(_151) <= _151:
                _172 = mem[64]
                mem[mem[64]] = _151 + _97 + _98 + _126 - mem[64]
                mem[64] = _151 + _97 + _98 + _126 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _172
                t = _95
                continue 
            mem[_151 + _97 + _98 + _126 + 32] = 0
            _173 = mem[64]
            mem[mem[64]] = _151 + _97 + _98 + _126 - mem[64]
            mem[64] = _151 + _97 + _98 + _126 + 32
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            s = _173
            t = _95
            continue 
        mem[_98 + _97 + 32] = 0
        _127 = mem[_55]
        s = 0
        while s < _127:
            mem[s + _97 + _98 + 32] = mem[s + _55 + 32]
            s = s + 32
            continue 
        if ceil32(_127) <= _127:
            _152 = mem[_96]
            s = 0
            while s < _152:
                mem[s + _97 + _98 + _127 + 32] = mem[s + _96 + 32]
                s = s + 32
                continue 
            if ceil32(_152) <= _152:
                _174 = mem[64]
                mem[mem[64]] = _152 + _97 + _98 + _127 - mem[64]
                mem[64] = _152 + _97 + _98 + _127 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _174
                t = _95
                continue 
            mem[_152 + _97 + _98 + _127 + 32] = 0
            _175 = mem[64]
            mem[mem[64]] = _152 + _97 + _98 + _127 - mem[64]
            mem[64] = _152 + _97 + _98 + _127 + 32
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            s = _175
            t = _95
            continue 
        mem[_127 + _97 + _98 + 32] = 0
        _153 = mem[_96]
        s = 0
        while s < _153:
            mem[s + _97 + _98 + _127 + 32] = mem[s + _96 + 32]
            s = s + 32
            continue 
        if ceil32(_153) <= _153:
            _176 = mem[64]
            mem[mem[64]] = _153 + _97 + _98 + _127 - mem[64]
            mem[64] = _153 + _97 + _98 + _127 + 32
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            s = _176
            t = _95
            continue 
        mem[_153 + _97 + _98 + _127 + 32] = 0
        _177 = mem[64]
        mem[mem[64]] = _153 + _97 + _98 + _127 - mem[64]
        mem[64] = _153 + _97 + _98 + _127 + 32
        if not idx + 1:
            revert with 0, 17
        idx = idx + 1
        s = _177
        t = _95
        continue 
    _94 = mem[64]
    mem[mem[64]] = 32
    _99 = mem[s]
    mem[mem[64] + 32] = mem[s]
    mem[mem[64] + 64 len ceil32(_99)] = mem[s + 32 len ceil32(_99)]
    if ceil32(_99) <= _99:
        return 32, mem[mem[64] + 32 len ceil32(_99) + 32]
    mem[_99 + mem[64] + 64] = 0
    return memory
      from mem[64]
       len ceil32(_99) + _94 + -mem[64] + 64
}

function _getNodesCreationTime(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[0] = arg1
    mem[32] = 10
    mem[64] = (32 * sub_2c534595[address(arg1)].field_0) + 128
    mem[96] = sub_2c534595[address(arg1)].field_0
    s = 128
    idx = 0
    while idx < sub_2c534595[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 10)
        _134 = mem[64]
        mem[64] = mem[64] + 160
        if sub_2c534595[address(arg1)][idx].field_0:
            if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                revert with 0, 34
            _139 = mem[64]
            mem[64] = mem[64] + ceil32(uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) + 32
            mem[_139] = uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5
            if sub_2c534595[address(arg1)][idx].field_0:
                if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                    revert with 0, 34
                if Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                    if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                        mem[_139 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                    else:
                        mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                        mem[_139 + 32] = sub_2c534595[address(arg1)][idx].field_0
                        t = _139 + 32
                        u = sha3(mem[0])
                        while _139 + (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                mem[_134] = _139
                mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _134
                s = s + 32
                idx = idx + 1
                continue 
            if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                revert with 0, 34
            if not sub_2c534595[address(arg1)][idx].field_1:
                mem[_134] = _139
                mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _134
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                mem[_139 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                mem[_134] = _139
                mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _134
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
            mem[_139 + 32] = sub_2c534595[address(arg1)][idx].field_0
            t = _139 + 32
            u = sha3(mem[0])
            while _139 + sub_2c534595[address(arg1)][u].field_1 > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_134] = _139
            mem[_134 + 32] = sub_2c534595[address(arg1)][u].field_256
            mem[_134 + 64] = sub_2c534595[address(arg1)][u].field_512
            mem[_134 + 96] = sub_2c534595[address(arg1)][u].field_768
            mem[_134 + 128] = sub_2c534595[address(arg1)][u].field_1024
            mem[t] = _134
            t = t + 32
            u = u + 1
            continue 
        if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
            revert with 0, 34
        _141 = mem[64]
        mem[64] = mem[64] + ceil32(sub_2c534595[address(arg1)][idx].field_1) + 32
        mem[_141] = sub_2c534595[address(arg1)][idx].field_1
        if sub_2c534595[address(arg1)][idx].field_0:
            if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                revert with 0, 34
            if not Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                mem[_134] = _141
                mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _134
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                mem[_141 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                mem[_134] = _141
                mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _134
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
            mem[_141 + 32] = sub_2c534595[address(arg1)][idx].field_0
            t = _141 + 32
            u = sha3(mem[0])
            while _141 + (uint255(sub_2c534595[address(arg1)][u].field_0) * 0.5) > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_134] = _141
            mem[_134 + 32] = sub_2c534595[address(arg1)][u].field_256
            mem[_134 + 64] = sub_2c534595[address(arg1)][u].field_512
            mem[_134 + 96] = sub_2c534595[address(arg1)][u].field_768
            mem[_134 + 128] = sub_2c534595[address(arg1)][u].field_1024
            mem[t] = _134
            t = t + 32
            u = u + 1
            continue 
        if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
            revert with 0, 34
        if sub_2c534595[address(arg1)][idx].field_1:
            if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                mem[_141 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
            else:
                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                mem[_141 + 32] = sub_2c534595[address(arg1)][idx].field_0
                t = _141 + 32
                u = sha3(mem[0])
                while _141 + sub_2c534595[address(arg1)][idx].field_1 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
        mem[_134] = _141
        mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
        mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
        mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
        mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
        mem[s] = _134
        s = s + 32
        idx = idx + 1
        continue 
    _132 = mem[96]
    _135 = mem[64]
    mem[64] = mem[64] + 160
    mem[_135] = 96
    mem[_135 + 32] = 0
    mem[_135 + 64] = 0
    mem[_135 + 96] = 0
    mem[_135 + 128] = 0
    if 0 >= mem[96]:
        revert with 0, 50
    _138 = mem[mem[128] + 32]
    if not -mem[mem[128] + 32]:
        _140 = mem[64]
        mem[64] = mem[64] + 64
        mem[_140] = 1
        mem[_140 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
        _142 = mem[64]
        mem[64] = mem[64] + 64
        mem[_142] = 1
        mem[_142 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _140
        t = _135
        while idx < _132:
            if idx >= mem[96]:
                revert with 0, 50
            _264 = mem[(32 * idx) + 128]
            _265 = mem[mem[(32 * idx) + 128] + 32]
            if not -mem[mem[(32 * idx) + 128] + 32]:
                _267 = mem[64]
                mem[64] = mem[64] + 64
                mem[_267] = 1
                mem[_267 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _268 = mem[64]
                _270 = mem[s]
                t = 0
                while t < _270:
                    mem[t + _268 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_270) <= _270:
                    _439 = mem[_142]
                    s = 0
                    while s < _439:
                        mem[s + _268 + _270 + 32] = mem[s + _142 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_439) <= _439:
                        _637 = mem[_267]
                        s = 0
                        while s < _637:
                            mem[s + _268 + _270 + _439 + 32] = mem[s + _267 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_637) <= _637:
                            _821 = mem[64]
                            mem[mem[64]] = _637 + _268 + _270 + _439 - mem[64]
                            mem[64] = _637 + _268 + _270 + _439 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _821
                            t = _264
                            continue 
                        mem[_637 + _268 + _270 + _439 + 32] = 0
                        _822 = mem[64]
                        mem[mem[64]] = _637 + _268 + _270 + _439 - mem[64]
                        mem[64] = _637 + _268 + _270 + _439 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _822
                        t = _264
                        continue 
                    mem[_439 + _268 + _270 + 32] = 0
                    _638 = mem[_267]
                    s = 0
                    while s < _638:
                        mem[s + _268 + _270 + _439 + 32] = mem[s + _267 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_638) <= _638:
                        _823 = mem[64]
                        mem[mem[64]] = _638 + _268 + _270 + _439 - mem[64]
                        mem[64] = _638 + _268 + _270 + _439 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _823
                        t = _264
                        continue 
                    mem[_638 + _268 + _270 + _439 + 32] = 0
                    _824 = mem[64]
                    mem[mem[64]] = _638 + _268 + _270 + _439 - mem[64]
                    mem[64] = _638 + _268 + _270 + _439 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _824
                    t = _264
                    continue 
                mem[_270 + _268 + 32] = 0
                _440 = mem[_142]
                s = 0
                while s < _440:
                    mem[s + _268 + _270 + 32] = mem[s + _142 + 32]
                    s = s + 32
                    continue 
                if ceil32(_440) <= _440:
                    _639 = mem[_267]
                    s = 0
                    while s < _639:
                        mem[s + _268 + _270 + _440 + 32] = mem[s + _267 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_639) <= _639:
                        _825 = mem[64]
                        mem[mem[64]] = _639 + _268 + _270 + _440 - mem[64]
                        mem[64] = _639 + _268 + _270 + _440 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _825
                        t = _264
                        continue 
                    mem[_639 + _268 + _270 + _440 + 32] = 0
                    _826 = mem[64]
                    mem[mem[64]] = _639 + _268 + _270 + _440 - mem[64]
                    mem[64] = _639 + _268 + _270 + _440 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _826
                    t = _264
                    continue 
                mem[_440 + _268 + _270 + 32] = 0
                _640 = mem[_267]
                s = 0
                while s < _640:
                    mem[s + _268 + _270 + _440 + 32] = mem[s + _267 + 32]
                    s = s + 32
                    continue 
                if ceil32(_640) <= _640:
                    _827 = mem[64]
                    mem[mem[64]] = _640 + _268 + _270 + _440 - mem[64]
                    mem[64] = _640 + _268 + _270 + _440 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _827
                    t = _264
                    continue 
                mem[_640 + _268 + _270 + _440 + 32] = 0
                _828 = mem[64]
                mem[mem[64]] = _640 + _268 + _270 + _440 - mem[64]
                mem[64] = _640 + _268 + _270 + _440 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _828
                t = _264
                continue 
            u = 0
            t = mem[mem[(32 * idx) + 128] + 32]
            while t:
                if not u + 1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _438 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = _265
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_438]:
                        revert with 0, 50
                    mem[v + _438 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _633 = mem[64]
                _635 = mem[s]
                t = 0
                while t < _635:
                    mem[t + _633 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_635) <= _635:
                    _817 = mem[_142]
                    s = 0
                    while s < _817:
                        mem[s + _633 + _635 + 32] = mem[s + _142 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_817) <= _817:
                        _1025 = mem[_438]
                        s = 0
                        while s < _1025:
                            mem[s + _633 + _635 + _817 + 32] = mem[s + _438 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_1025) <= _1025:
                            _1213 = mem[64]
                            mem[mem[64]] = _1025 + _633 + _635 + _817 - mem[64]
                            mem[64] = _1025 + _633 + _635 + _817 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _1213
                            t = _264
                            continue 
                        mem[_1025 + _633 + _635 + _817 + 32] = 0
                        _1214 = mem[64]
                        mem[mem[64]] = _1025 + _633 + _635 + _817 - mem[64]
                        mem[64] = _1025 + _633 + _635 + _817 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1214
                        t = _264
                        continue 
                    mem[_817 + _633 + _635 + 32] = 0
                    _1026 = mem[_438]
                    s = 0
                    while s < _1026:
                        mem[s + _633 + _635 + _817 + 32] = mem[s + _438 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1026) <= _1026:
                        _1215 = mem[64]
                        mem[mem[64]] = _1026 + _633 + _635 + _817 - mem[64]
                        mem[64] = _1026 + _633 + _635 + _817 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1215
                        t = _264
                        continue 
                    mem[_1026 + _633 + _635 + _817 + 32] = 0
                    _1216 = mem[64]
                    mem[mem[64]] = _1026 + _633 + _635 + _817 - mem[64]
                    mem[64] = _1026 + _633 + _635 + _817 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1216
                    t = _264
                    continue 
                mem[_635 + _633 + 32] = 0
                _818 = mem[_142]
                s = 0
                while s < _818:
                    mem[s + _633 + _635 + 32] = mem[s + _142 + 32]
                    s = s + 32
                    continue 
                if ceil32(_818) <= _818:
                    _1027 = mem[_438]
                    s = 0
                    while s < _1027:
                        mem[s + _633 + _635 + _818 + 32] = mem[s + _438 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1027) <= _1027:
                        _1217 = mem[64]
                        mem[mem[64]] = _1027 + _633 + _635 + _818 - mem[64]
                        mem[64] = _1027 + _633 + _635 + _818 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1217
                        t = _264
                        continue 
                    mem[_1027 + _633 + _635 + _818 + 32] = 0
                    _1218 = mem[64]
                    mem[mem[64]] = _1027 + _633 + _635 + _818 - mem[64]
                    mem[64] = _1027 + _633 + _635 + _818 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1218
                    t = _264
                    continue 
                mem[_818 + _633 + _635 + 32] = 0
                _1028 = mem[_438]
                s = 0
                while s < _1028:
                    mem[s + _633 + _635 + _818 + 32] = mem[s + _438 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1028) <= _1028:
                    _1219 = mem[64]
                    mem[mem[64]] = _1028 + _633 + _635 + _818 - mem[64]
                    mem[64] = _1028 + _633 + _635 + _818 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1219
                    t = _264
                    continue 
                mem[_1028 + _633 + _635 + _818 + 32] = 0
                _1220 = mem[64]
                mem[mem[64]] = _1028 + _633 + _635 + _818 - mem[64]
                mem[64] = _1028 + _633 + _635 + _818 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1220
                t = _264
                continue 
            mem[_438 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = _265
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_438]:
                    revert with 0, 50
                mem[v + _438 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _634 = mem[64]
            _636 = mem[s]
            t = 0
            while t < _636:
                mem[t + _634 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_636) <= _636:
                _819 = mem[_142]
                s = 0
                while s < _819:
                    mem[s + _634 + _636 + 32] = mem[s + _142 + 32]
                    s = s + 32
                    continue 
                if ceil32(_819) <= _819:
                    _1029 = mem[_438]
                    idx = 0
                    while idx < _1029:
                        mem[idx + _634 + _636 + _819 + 32] = mem[idx + _438 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_1029) <= _1029:
                        _1221 = mem[64]
                        mem[mem[64]] = _1029 + _634 + _636 + _819 - mem[64]
                        mem[64] = _1029 + _634 + _636 + _819 + 32
                        if not ceil32(_819) + 1:
                            revert with 0, 17
                        s = ceil32(_819) + 1
                        s = _1221
                        t = _264
                        continue 
                    mem[_1029 + _634 + _636 + _819 + 32] = 0
                    _1222 = mem[64]
                    mem[mem[64]] = _1029 + _634 + _636 + _819 - mem[64]
                    mem[64] = _1029 + _634 + _636 + _819 + 32
                    if not ceil32(_819) + 1:
                        revert with 0, 17
                    s = ceil32(_819) + 1
                    s = _1222
                    t = _264
                    continue 
                mem[_819 + _634 + _636 + 32] = 0
                _1030 = mem[_438]
                idx = 0
                while idx < _1030:
                    mem[idx + _634 + _636 + _819 + 32] = mem[idx + _438 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1030) <= _1030:
                    _1223 = mem[64]
                    mem[mem[64]] = _1030 + _634 + _636 + _819 - mem[64]
                    mem[64] = _1030 + _634 + _636 + _819 + 32
                    if not ceil32(_819) + 1:
                        revert with 0, 17
                    s = ceil32(_819) + 1
                    s = _1223
                    t = _264
                    continue 
                mem[_1030 + _634 + _636 + _819 + 32] = 0
                _1224 = mem[64]
                mem[mem[64]] = _1030 + _634 + _636 + _819 - mem[64]
                mem[64] = _1030 + _634 + _636 + _819 + 32
                if not ceil32(_819) + 1:
                    revert with 0, 17
                s = ceil32(_819) + 1
                s = _1224
                t = _264
                continue 
            mem[_636 + _634 + 32] = 0
            _820 = mem[_142]
            s = 0
            while s < _820:
                mem[s + _634 + _636 + 32] = mem[s + _142 + 32]
                s = s + 32
                continue 
            if ceil32(_820) <= _820:
                _1031 = mem[_438]
                idx = 0
                while idx < _1031:
                    mem[idx + _634 + _636 + _820 + 32] = mem[idx + _438 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1031) <= _1031:
                    _1225 = mem[64]
                    mem[mem[64]] = _1031 + _634 + _636 + _820 - mem[64]
                    mem[64] = _1031 + _634 + _636 + _820 + 32
                    if not ceil32(_820) + 1:
                        revert with 0, 17
                    s = ceil32(_820) + 1
                    s = _1225
                    t = _264
                    continue 
                mem[_1031 + _634 + _636 + _820 + 32] = 0
                _1226 = mem[64]
                mem[mem[64]] = _1031 + _634 + _636 + _820 - mem[64]
                mem[64] = _1031 + _634 + _636 + _820 + 32
                if not ceil32(_820) + 1:
                    revert with 0, 17
                s = ceil32(_820) + 1
                s = _1226
                t = _264
                continue 
            mem[_820 + _634 + _636 + 32] = 0
            _1032 = mem[_438]
            idx = 0
            while idx < _1032:
                mem[idx + _634 + _636 + _820 + 32] = mem[idx + _438 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1032) <= _1032:
                _1227 = mem[64]
                mem[mem[64]] = _1032 + _634 + _636 + _820 - mem[64]
                mem[64] = _1032 + _634 + _636 + _820 + 32
                if not ceil32(_820) + 1:
                    revert with 0, 17
                s = ceil32(_820) + 1
                s = _1227
                t = _264
                continue 
            mem[_1032 + _634 + _636 + _820 + 32] = 0
            _1228 = mem[64]
            mem[mem[64]] = _1032 + _634 + _636 + _820 - mem[64]
            mem[64] = _1032 + _634 + _636 + _820 + 32
            if not ceil32(_820) + 1:
                revert with 0, 17
            s = ceil32(_820) + 1
            s = _1228
            t = _264
            continue 
        _263 = mem[64]
        mem[mem[64]] = 32
        _266 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_266)] = mem[s + 32 len ceil32(_266)]
        if ceil32(_266) <= _266:
            return 32, mem[mem[64] + 32 len ceil32(_266) + 32]
        mem[_266 + mem[64] + 64] = 0
        return memory
          from mem[64]
           len ceil32(_266) + _263 + -mem[64] + 64
    s = 0
    idx = mem[mem[128] + 32]
    while idx:
        if not s + 1:
            revert with 0, 17
        s = s + 1
        idx = idx / 10
        continue 
    if s > test266151307():
        revert with 0, 65
    _262 = mem[64]
    mem[mem[64]] = s
    mem[64] = mem[64] + ceil32(s) + 32
    if not s:
        t = s
        idx = _138
        while idx:
            if t < 1:
                revert with 0, 17
            if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if idx < 10 * idx / 10:
                revert with 0, 17
            if 48 > -uint8(idx - (10 * idx / 10)) + 255:
                revert with 0, 17
            if t - 1 >= mem[_262]:
                revert with 0, 50
            mem[t + _262 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        _436 = mem[64]
        mem[64] = mem[64] + 64
        mem[_436] = 1
        mem[_436 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _262
        u = _135
        while idx < _132:
            if idx >= mem[96]:
                revert with 0, 50
            _628 = mem[(32 * idx) + 128]
            _629 = mem[mem[(32 * idx) + 128] + 32]
            if not -mem[mem[(32 * idx) + 128] + 32]:
                _642 = mem[64]
                mem[64] = mem[64] + 64
                mem[_642] = 1
                mem[_642 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _645 = mem[64]
                _647 = mem[s]
                u = 0
                while u < _647:
                    mem[u + _645 + 32] = mem[u + s + 32]
                    u = u + 32
                    continue 
                if ceil32(_647) <= _647:
                    _813 = mem[_436]
                    s = 0
                    while s < _813:
                        mem[s + _645 + _647 + 32] = mem[s + _436 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_813) <= _813:
                        _1015 = mem[_642]
                        s = 0
                        while s < _1015:
                            mem[s + _645 + _647 + _813 + 32] = mem[s + _642 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_1015) <= _1015:
                            _1197 = mem[64]
                            mem[mem[64]] = _1015 + _645 + _647 + _813 - mem[64]
                            mem[64] = _1015 + _645 + _647 + _813 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _1197
                            u = _628
                            continue 
                        mem[_1015 + _645 + _647 + _813 + 32] = 0
                        _1198 = mem[64]
                        mem[mem[64]] = _1015 + _645 + _647 + _813 - mem[64]
                        mem[64] = _1015 + _645 + _647 + _813 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1198
                        u = _628
                        continue 
                    mem[_813 + _645 + _647 + 32] = 0
                    _1016 = mem[_642]
                    s = 0
                    while s < _1016:
                        mem[s + _645 + _647 + _813 + 32] = mem[s + _642 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1016) <= _1016:
                        _1199 = mem[64]
                        mem[mem[64]] = _1016 + _645 + _647 + _813 - mem[64]
                        mem[64] = _1016 + _645 + _647 + _813 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1199
                        u = _628
                        continue 
                    mem[_1016 + _645 + _647 + _813 + 32] = 0
                    _1200 = mem[64]
                    mem[mem[64]] = _1016 + _645 + _647 + _813 - mem[64]
                    mem[64] = _1016 + _645 + _647 + _813 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1200
                    u = _628
                    continue 
                mem[_647 + _645 + 32] = 0
                _814 = mem[_436]
                s = 0
                while s < _814:
                    mem[s + _645 + _647 + 32] = mem[s + _436 + 32]
                    s = s + 32
                    continue 
                if ceil32(_814) <= _814:
                    _1017 = mem[_642]
                    s = 0
                    while s < _1017:
                        mem[s + _645 + _647 + _814 + 32] = mem[s + _642 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1017) <= _1017:
                        _1201 = mem[64]
                        mem[mem[64]] = _1017 + _645 + _647 + _814 - mem[64]
                        mem[64] = _1017 + _645 + _647 + _814 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1201
                        u = _628
                        continue 
                    mem[_1017 + _645 + _647 + _814 + 32] = 0
                    _1202 = mem[64]
                    mem[mem[64]] = _1017 + _645 + _647 + _814 - mem[64]
                    mem[64] = _1017 + _645 + _647 + _814 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1202
                    u = _628
                    continue 
                mem[_814 + _645 + _647 + 32] = 0
                _1018 = mem[_642]
                s = 0
                while s < _1018:
                    mem[s + _645 + _647 + _814 + 32] = mem[s + _642 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1018) <= _1018:
                    _1203 = mem[64]
                    mem[mem[64]] = _1018 + _645 + _647 + _814 - mem[64]
                    mem[64] = _1018 + _645 + _647 + _814 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1203
                    u = _628
                    continue 
                mem[_1018 + _645 + _647 + _814 + 32] = 0
                _1204 = mem[64]
                mem[mem[64]] = _1018 + _645 + _647 + _814 - mem[64]
                mem[64] = _1018 + _645 + _647 + _814 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1204
                u = _628
                continue 
            u = 0
            t = mem[mem[(32 * idx) + 128] + 32]
            while t:
                if not u + 1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _811 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = _629
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_811]:
                        revert with 0, 50
                    mem[v + _811 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _1009 = mem[64]
                _1013 = mem[s]
                t = 0
                while t < _1013:
                    mem[t + _1009 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_1013) <= _1013:
                    _1189 = mem[_436]
                    s = 0
                    while s < _1189:
                        mem[s + _1009 + _1013 + 32] = mem[s + _436 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1189) <= _1189:
                        _1309 = mem[_811]
                        s = 0
                        while s < _1309:
                            mem[s + _1009 + _1013 + _1189 + 32] = mem[s + _811 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_1309) <= _1309:
                            _1389 = mem[64]
                            mem[mem[64]] = _1309 + _1009 + _1013 + _1189 - mem[64]
                            mem[64] = _1309 + _1009 + _1013 + _1189 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _1389
                            u = _628
                            continue 
                        mem[_1309 + _1009 + _1013 + _1189 + 32] = 0
                        _1390 = mem[64]
                        mem[mem[64]] = _1309 + _1009 + _1013 + _1189 - mem[64]
                        mem[64] = _1309 + _1009 + _1013 + _1189 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1390
                        u = _628
                        continue 
                    mem[_1189 + _1009 + _1013 + 32] = 0
                    _1310 = mem[_811]
                    s = 0
                    while s < _1310:
                        mem[s + _1009 + _1013 + _1189 + 32] = mem[s + _811 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1310) <= _1310:
                        _1391 = mem[64]
                        mem[mem[64]] = _1310 + _1009 + _1013 + _1189 - mem[64]
                        mem[64] = _1310 + _1009 + _1013 + _1189 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1391
                        u = _628
                        continue 
                    mem[_1310 + _1009 + _1013 + _1189 + 32] = 0
                    _1392 = mem[64]
                    mem[mem[64]] = _1310 + _1009 + _1013 + _1189 - mem[64]
                    mem[64] = _1310 + _1009 + _1013 + _1189 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1392
                    u = _628
                    continue 
                mem[_1013 + _1009 + 32] = 0
                _1190 = mem[_436]
                s = 0
                while s < _1190:
                    mem[s + _1009 + _1013 + 32] = mem[s + _436 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1190) <= _1190:
                    _1311 = mem[_811]
                    s = 0
                    while s < _1311:
                        mem[s + _1009 + _1013 + _1190 + 32] = mem[s + _811 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1311) <= _1311:
                        _1393 = mem[64]
                        mem[mem[64]] = _1311 + _1009 + _1013 + _1190 - mem[64]
                        mem[64] = _1311 + _1009 + _1013 + _1190 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1393
                        u = _628
                        continue 
                    mem[_1311 + _1009 + _1013 + _1190 + 32] = 0
                    _1394 = mem[64]
                    mem[mem[64]] = _1311 + _1009 + _1013 + _1190 - mem[64]
                    mem[64] = _1311 + _1009 + _1013 + _1190 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1394
                    u = _628
                    continue 
                mem[_1190 + _1009 + _1013 + 32] = 0
                _1312 = mem[_811]
                s = 0
                while s < _1312:
                    mem[s + _1009 + _1013 + _1190 + 32] = mem[s + _811 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1312) <= _1312:
                    _1395 = mem[64]
                    mem[mem[64]] = _1312 + _1009 + _1013 + _1190 - mem[64]
                    mem[64] = _1312 + _1009 + _1013 + _1190 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1395
                    u = _628
                    continue 
                mem[_1312 + _1009 + _1013 + _1190 + 32] = 0
                _1396 = mem[64]
                mem[mem[64]] = _1312 + _1009 + _1013 + _1190 - mem[64]
                mem[64] = _1312 + _1009 + _1013 + _1190 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1396
                u = _628
                continue 
            mem[_811 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = _629
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_811]:
                    revert with 0, 50
                mem[v + _811 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _1010 = mem[64]
            _1014 = mem[s]
            t = 0
            while t < _1014:
                mem[t + _1010 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_1014) <= _1014:
                _1191 = mem[_436]
                s = 0
                while s < _1191:
                    mem[s + _1010 + _1014 + 32] = mem[s + _436 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1191) <= _1191:
                    _1313 = mem[_811]
                    idx = 0
                    while idx < _1313:
                        mem[idx + _1010 + _1014 + _1191 + 32] = mem[idx + _811 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_1313) <= _1313:
                        _1397 = mem[64]
                        mem[mem[64]] = _1313 + _1010 + _1014 + _1191 - mem[64]
                        mem[64] = _1313 + _1010 + _1014 + _1191 + 32
                        if not ceil32(_1191) + 1:
                            revert with 0, 17
                        s = ceil32(_1191) + 1
                        s = _1397
                        u = _628
                        continue 
                    mem[_1313 + _1010 + _1014 + _1191 + 32] = 0
                    _1398 = mem[64]
                    mem[mem[64]] = _1313 + _1010 + _1014 + _1191 - mem[64]
                    mem[64] = _1313 + _1010 + _1014 + _1191 + 32
                    if not ceil32(_1191) + 1:
                        revert with 0, 17
                    s = ceil32(_1191) + 1
                    s = _1398
                    u = _628
                    continue 
                mem[_1191 + _1010 + _1014 + 32] = 0
                _1314 = mem[_811]
                idx = 0
                while idx < _1314:
                    mem[idx + _1010 + _1014 + _1191 + 32] = mem[idx + _811 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1314) <= _1314:
                    _1399 = mem[64]
                    mem[mem[64]] = _1314 + _1010 + _1014 + _1191 - mem[64]
                    mem[64] = _1314 + _1010 + _1014 + _1191 + 32
                    if not ceil32(_1191) + 1:
                        revert with 0, 17
                    s = ceil32(_1191) + 1
                    s = _1399
                    u = _628
                    continue 
                mem[_1314 + _1010 + _1014 + _1191 + 32] = 0
                _1400 = mem[64]
                mem[mem[64]] = _1314 + _1010 + _1014 + _1191 - mem[64]
                mem[64] = _1314 + _1010 + _1014 + _1191 + 32
                if not ceil32(_1191) + 1:
                    revert with 0, 17
                s = ceil32(_1191) + 1
                s = _1400
                u = _628
                continue 
            mem[_1014 + _1010 + 32] = 0
            _1192 = mem[_436]
            s = 0
            while s < _1192:
                mem[s + _1010 + _1014 + 32] = mem[s + _436 + 32]
                s = s + 32
                continue 
            if ceil32(_1192) <= _1192:
                _1315 = mem[_811]
                idx = 0
                while idx < _1315:
                    mem[idx + _1010 + _1014 + _1192 + 32] = mem[idx + _811 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1315) <= _1315:
                    _1401 = mem[64]
                    mem[mem[64]] = _1315 + _1010 + _1014 + _1192 - mem[64]
                    mem[64] = _1315 + _1010 + _1014 + _1192 + 32
                    if not ceil32(_1192) + 1:
                        revert with 0, 17
                    s = ceil32(_1192) + 1
                    s = _1401
                    u = _628
                    continue 
                mem[_1315 + _1010 + _1014 + _1192 + 32] = 0
                _1402 = mem[64]
                mem[mem[64]] = _1315 + _1010 + _1014 + _1192 - mem[64]
                mem[64] = _1315 + _1010 + _1014 + _1192 + 32
                if not ceil32(_1192) + 1:
                    revert with 0, 17
                s = ceil32(_1192) + 1
                s = _1402
                u = _628
                continue 
            mem[_1192 + _1010 + _1014 + 32] = 0
            _1316 = mem[_811]
            idx = 0
            while idx < _1316:
                mem[idx + _1010 + _1014 + _1192 + 32] = mem[idx + _811 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1316) <= _1316:
                _1403 = mem[64]
                mem[mem[64]] = _1316 + _1010 + _1014 + _1192 - mem[64]
                mem[64] = _1316 + _1010 + _1014 + _1192 + 32
                if not ceil32(_1192) + 1:
                    revert with 0, 17
                s = ceil32(_1192) + 1
                s = _1403
                u = _628
                continue 
            mem[_1316 + _1010 + _1014 + _1192 + 32] = 0
            _1404 = mem[64]
            mem[mem[64]] = _1316 + _1010 + _1014 + _1192 - mem[64]
            mem[64] = _1316 + _1010 + _1014 + _1192 + 32
            if not ceil32(_1192) + 1:
                revert with 0, 17
            s = ceil32(_1192) + 1
            s = _1404
            u = _628
            continue 
        _627 = mem[64]
        mem[mem[64]] = 32
        _641 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_641)] = mem[s + 32 len ceil32(_641)]
        if ceil32(_641) <= _641:
            return 32, mem[mem[64] + 32 len ceil32(_641) + 32]
        mem[_641 + mem[64] + 64] = 0
        return memory
          from mem[64]
           len ceil32(_641) + _627 + -mem[64] + 64
    mem[_262 + 32 len s] = call.data[calldata.size len s]
    t = s
    idx = _138
    while idx:
        if t < 1:
            revert with 0, 17
        if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
            revert with 0, 17
        if idx < 10 * idx / 10:
            revert with 0, 17
        if 48 > -uint8(idx - (10 * idx / 10)) + 255:
            revert with 0, 17
        if t - 1 >= mem[_262]:
            revert with 0, 50
        mem[t + _262 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
        t = t - 1
        idx = idx / 10
        continue 
    _437 = mem[64]
    mem[64] = mem[64] + 64
    mem[_437] = 1
    mem[_437 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
    idx = 1
    s = _262
    u = _135
    while idx < _132:
        if idx >= mem[96]:
            revert with 0, 50
        _631 = mem[(32 * idx) + 128]
        _632 = mem[mem[(32 * idx) + 128] + 32]
        if not -mem[mem[(32 * idx) + 128] + 32]:
            _644 = mem[64]
            mem[64] = mem[64] + 64
            mem[_644] = 1
            mem[_644 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
            _646 = mem[64]
            _648 = mem[s]
            u = 0
            while u < _648:
                mem[u + _646 + 32] = mem[u + s + 32]
                u = u + 32
                continue 
            if ceil32(_648) <= _648:
                _815 = mem[_437]
                s = 0
                while s < _815:
                    mem[s + _646 + _648 + 32] = mem[s + _437 + 32]
                    s = s + 32
                    continue 
                if ceil32(_815) <= _815:
                    _1021 = mem[_644]
                    s = 0
                    while s < _1021:
                        mem[s + _646 + _648 + _815 + 32] = mem[s + _644 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1021) <= _1021:
                        _1205 = mem[64]
                        mem[mem[64]] = _1021 + _646 + _648 + _815 - mem[64]
                        mem[64] = _1021 + _646 + _648 + _815 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1205
                        u = _631
                        continue 
                    mem[_1021 + _646 + _648 + _815 + 32] = 0
                    _1206 = mem[64]
                    mem[mem[64]] = _1021 + _646 + _648 + _815 - mem[64]
                    mem[64] = _1021 + _646 + _648 + _815 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1206
                    u = _631
                    continue 
                mem[_815 + _646 + _648 + 32] = 0
                _1022 = mem[_644]
                s = 0
                while s < _1022:
                    mem[s + _646 + _648 + _815 + 32] = mem[s + _644 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1022) <= _1022:
                    _1207 = mem[64]
                    mem[mem[64]] = _1022 + _646 + _648 + _815 - mem[64]
                    mem[64] = _1022 + _646 + _648 + _815 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1207
                    u = _631
                    continue 
                mem[_1022 + _646 + _648 + _815 + 32] = 0
                _1208 = mem[64]
                mem[mem[64]] = _1022 + _646 + _648 + _815 - mem[64]
                mem[64] = _1022 + _646 + _648 + _815 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1208
                u = _631
                continue 
            mem[_648 + _646 + 32] = 0
            _816 = mem[_437]
            s = 0
            while s < _816:
                mem[s + _646 + _648 + 32] = mem[s + _437 + 32]
                s = s + 32
                continue 
            if ceil32(_816) <= _816:
                _1023 = mem[_644]
                s = 0
                while s < _1023:
                    mem[s + _646 + _648 + _816 + 32] = mem[s + _644 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1023) <= _1023:
                    _1209 = mem[64]
                    mem[mem[64]] = _1023 + _646 + _648 + _816 - mem[64]
                    mem[64] = _1023 + _646 + _648 + _816 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1209
                    u = _631
                    continue 
                mem[_1023 + _646 + _648 + _816 + 32] = 0
                _1210 = mem[64]
                mem[mem[64]] = _1023 + _646 + _648 + _816 - mem[64]
                mem[64] = _1023 + _646 + _648 + _816 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1210
                u = _631
                continue 
            mem[_816 + _646 + _648 + 32] = 0
            _1024 = mem[_644]
            s = 0
            while s < _1024:
                mem[s + _646 + _648 + _816 + 32] = mem[s + _644 + 32]
                s = s + 32
                continue 
            if ceil32(_1024) <= _1024:
                _1211 = mem[64]
                mem[mem[64]] = _1024 + _646 + _648 + _816 - mem[64]
                mem[64] = _1024 + _646 + _648 + _816 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1211
                u = _631
                continue 
            mem[_1024 + _646 + _648 + _816 + 32] = 0
            _1212 = mem[64]
            mem[mem[64]] = _1024 + _646 + _648 + _816 - mem[64]
            mem[64] = _1024 + _646 + _648 + _816 + 32
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            s = _1212
            u = _631
            continue 
        u = 0
        t = mem[mem[(32 * idx) + 128] + 32]
        while t:
            if not u + 1:
                revert with 0, 17
            u = u + 1
            t = t / 10
            continue 
        if u > test266151307():
            revert with 0, 65
        _812 = mem[64]
        mem[mem[64]] = u
        mem[64] = mem[64] + ceil32(u) + 32
        if not u:
            v = u
            t = _632
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_812]:
                    revert with 0, 50
                mem[v + _812 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _1011 = mem[64]
            _1019 = mem[s]
            t = 0
            while t < _1019:
                mem[t + _1011 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_1019) <= _1019:
                _1193 = mem[_437]
                s = 0
                while s < _1193:
                    mem[s + _1011 + _1019 + 32] = mem[s + _437 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1193) <= _1193:
                    _1317 = mem[_812]
                    s = 0
                    while s < _1317:
                        mem[s + _1011 + _1019 + _1193 + 32] = mem[s + _812 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1317) <= _1317:
                        _1405 = mem[64]
                        mem[mem[64]] = _1317 + _1011 + _1019 + _1193 - mem[64]
                        mem[64] = _1317 + _1011 + _1019 + _1193 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1405
                        u = _631
                        continue 
                    mem[_1317 + _1011 + _1019 + _1193 + 32] = 0
                    _1406 = mem[64]
                    mem[mem[64]] = _1317 + _1011 + _1019 + _1193 - mem[64]
                    mem[64] = _1317 + _1011 + _1019 + _1193 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1406
                    u = _631
                    continue 
                mem[_1193 + _1011 + _1019 + 32] = 0
                _1318 = mem[_812]
                s = 0
                while s < _1318:
                    mem[s + _1011 + _1019 + _1193 + 32] = mem[s + _812 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1318) <= _1318:
                    _1407 = mem[64]
                    mem[mem[64]] = _1318 + _1011 + _1019 + _1193 - mem[64]
                    mem[64] = _1318 + _1011 + _1019 + _1193 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1407
                    u = _631
                    continue 
                mem[_1318 + _1011 + _1019 + _1193 + 32] = 0
                _1408 = mem[64]
                mem[mem[64]] = _1318 + _1011 + _1019 + _1193 - mem[64]
                mem[64] = _1318 + _1011 + _1019 + _1193 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1408
                u = _631
                continue 
            mem[_1019 + _1011 + 32] = 0
            _1194 = mem[_437]
            s = 0
            while s < _1194:
                mem[s + _1011 + _1019 + 32] = mem[s + _437 + 32]
                s = s + 32
                continue 
            if ceil32(_1194) <= _1194:
                _1319 = mem[_812]
                s = 0
                while s < _1319:
                    mem[s + _1011 + _1019 + _1194 + 32] = mem[s + _812 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1319) <= _1319:
                    _1409 = mem[64]
                    mem[mem[64]] = _1319 + _1011 + _1019 + _1194 - mem[64]
                    mem[64] = _1319 + _1011 + _1019 + _1194 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1409
                    u = _631
                    continue 
                mem[_1319 + _1011 + _1019 + _1194 + 32] = 0
                _1410 = mem[64]
                mem[mem[64]] = _1319 + _1011 + _1019 + _1194 - mem[64]
                mem[64] = _1319 + _1011 + _1019 + _1194 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1410
                u = _631
                continue 
            mem[_1194 + _1011 + _1019 + 32] = 0
            _1320 = mem[_812]
            s = 0
            while s < _1320:
                mem[s + _1011 + _1019 + _1194 + 32] = mem[s + _812 + 32]
                s = s + 32
                continue 
            if ceil32(_1320) <= _1320:
                _1411 = mem[64]
                mem[mem[64]] = _1320 + _1011 + _1019 + _1194 - mem[64]
                mem[64] = _1320 + _1011 + _1019 + _1194 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1411
                u = _631
                continue 
            mem[_1320 + _1011 + _1019 + _1194 + 32] = 0
            _1412 = mem[64]
            mem[mem[64]] = _1320 + _1011 + _1019 + _1194 - mem[64]
            mem[64] = _1320 + _1011 + _1019 + _1194 + 32
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            s = _1412
            u = _631
            continue 
        mem[_812 + 32 len u] = call.data[calldata.size len u]
        v = u
        t = _632
        while t:
            if v < 1:
                revert with 0, 17
            if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if t < 10 * t / 10:
                revert with 0, 17
            if 48 > -uint8(t - (10 * t / 10)) + 255:
                revert with 0, 17
            if v - 1 >= mem[_812]:
                revert with 0, 50
            mem[v + _812 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
            v = v - 1
            t = t / 10
            continue 
        _1012 = mem[64]
        _1020 = mem[s]
        t = 0
        while t < _1020:
            mem[t + _1012 + 32] = mem[t + s + 32]
            t = t + 32
            continue 
        if ceil32(_1020) <= _1020:
            _1195 = mem[_437]
            s = 0
            while s < _1195:
                mem[s + _1012 + _1020 + 32] = mem[s + _437 + 32]
                s = s + 32
                continue 
            if ceil32(_1195) <= _1195:
                _1321 = mem[_812]
                idx = 0
                while idx < _1321:
                    mem[idx + _1012 + _1020 + _1195 + 32] = mem[idx + _812 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1321) <= _1321:
                    _1413 = mem[64]
                    mem[mem[64]] = _1321 + _1012 + _1020 + _1195 - mem[64]
                    mem[64] = _1321 + _1012 + _1020 + _1195 + 32
                    if not ceil32(_1195) + 1:
                        revert with 0, 17
                    s = ceil32(_1195) + 1
                    s = _1413
                    u = _631
                    continue 
                mem[_1321 + _1012 + _1020 + _1195 + 32] = 0
                _1414 = mem[64]
                mem[mem[64]] = _1321 + _1012 + _1020 + _1195 - mem[64]
                mem[64] = _1321 + _1012 + _1020 + _1195 + 32
                if not ceil32(_1195) + 1:
                    revert with 0, 17
                s = ceil32(_1195) + 1
                s = _1414
                u = _631
                continue 
            mem[_1195 + _1012 + _1020 + 32] = 0
            _1322 = mem[_812]
            idx = 0
            while idx < _1322:
                mem[idx + _1012 + _1020 + _1195 + 32] = mem[idx + _812 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1322) <= _1322:
                _1415 = mem[64]
                mem[mem[64]] = _1322 + _1012 + _1020 + _1195 - mem[64]
                mem[64] = _1322 + _1012 + _1020 + _1195 + 32
                if not ceil32(_1195) + 1:
                    revert with 0, 17
                s = ceil32(_1195) + 1
                s = _1415
                u = _631
                continue 
            mem[_1322 + _1012 + _1020 + _1195 + 32] = 0
            _1416 = mem[64]
            mem[mem[64]] = _1322 + _1012 + _1020 + _1195 - mem[64]
            mem[64] = _1322 + _1012 + _1020 + _1195 + 32
            if not ceil32(_1195) + 1:
                revert with 0, 17
            s = ceil32(_1195) + 1
            s = _1416
            u = _631
            continue 
        mem[_1020 + _1012 + 32] = 0
        _1196 = mem[_437]
        s = 0
        while s < _1196:
            mem[s + _1012 + _1020 + 32] = mem[s + _437 + 32]
            s = s + 32
            continue 
        if ceil32(_1196) <= _1196:
            _1323 = mem[_812]
            idx = 0
            while idx < _1323:
                mem[idx + _1012 + _1020 + _1196 + 32] = mem[idx + _812 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1323) <= _1323:
                _1417 = mem[64]
                mem[mem[64]] = _1323 + _1012 + _1020 + _1196 - mem[64]
                mem[64] = _1323 + _1012 + _1020 + _1196 + 32
                if not ceil32(_1196) + 1:
                    revert with 0, 17
                s = ceil32(_1196) + 1
                s = _1417
                u = _631
                continue 
            mem[_1323 + _1012 + _1020 + _1196 + 32] = 0
            _1418 = mem[64]
            mem[mem[64]] = _1323 + _1012 + _1020 + _1196 - mem[64]
            mem[64] = _1323 + _1012 + _1020 + _1196 + 32
            if not ceil32(_1196) + 1:
                revert with 0, 17
            s = ceil32(_1196) + 1
            s = _1418
            u = _631
            continue 
        mem[_1196 + _1012 + _1020 + 32] = 0
        _1324 = mem[_812]
        idx = 0
        while idx < _1324:
            mem[idx + _1012 + _1020 + _1196 + 32] = mem[idx + _812 + 32]
            idx = idx + 32
            continue 
        if ceil32(_1324) <= _1324:
            _1419 = mem[64]
            mem[mem[64]] = _1324 + _1012 + _1020 + _1196 - mem[64]
            mem[64] = _1324 + _1012 + _1020 + _1196 + 32
            if not ceil32(_1196) + 1:
                revert with 0, 17
            s = ceil32(_1196) + 1
            s = _1419
            u = _631
            continue 
        mem[_1324 + _1012 + _1020 + _1196 + 32] = 0
        _1420 = mem[64]
        mem[mem[64]] = _1324 + _1012 + _1020 + _1196 - mem[64]
        mem[64] = _1324 + _1012 + _1020 + _1196 + 32
        if not ceil32(_1196) + 1:
            revert with 0, 17
        s = ceil32(_1196) + 1
        s = _1420
        u = _631
        continue 
    _630 = mem[64]
    mem[mem[64]] = 32
    _643 = mem[s]
    mem[mem[64] + 32] = mem[s]
    mem[mem[64] + 64 len ceil32(_643)] = mem[s + 32 len ceil32(_643)]
    if ceil32(_643) <= _643:
        return 32, mem[mem[64] + 32 len ceil32(_643) + 32]
    mem[_643 + mem[64] + 64] = 0
    return memory
      from mem[64]
       len ceil32(_643) + _630 + -mem[64] + 64
}

function _getNodesLastClaimTime(address arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[0] = arg1
    mem[32] = 10
    mem[64] = (32 * sub_2c534595[address(arg1)].field_0) + 128
    mem[96] = sub_2c534595[address(arg1)].field_0
    s = 128
    idx = 0
    while idx < sub_2c534595[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 10)
        _134 = mem[64]
        mem[64] = mem[64] + 160
        if sub_2c534595[address(arg1)][idx].field_0:
            if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                revert with 0, 34
            _139 = mem[64]
            mem[64] = mem[64] + ceil32(uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) + 32
            mem[_139] = uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5
            if sub_2c534595[address(arg1)][idx].field_0:
                if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                    revert with 0, 34
                if Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                    if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                        mem[_139 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                    else:
                        mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                        mem[_139 + 32] = sub_2c534595[address(arg1)][idx].field_0
                        t = _139 + 32
                        u = sha3(mem[0])
                        while _139 + (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                mem[_134] = _139
                mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _134
                s = s + 32
                idx = idx + 1
                continue 
            if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                revert with 0, 34
            if not sub_2c534595[address(arg1)][idx].field_1:
                mem[_134] = _139
                mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _134
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                mem[_139 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                mem[_134] = _139
                mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _134
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
            mem[_139 + 32] = sub_2c534595[address(arg1)][idx].field_0
            t = _139 + 32
            u = sha3(mem[0])
            while _139 + sub_2c534595[address(arg1)][u].field_1 > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_134] = _139
            mem[_134 + 32] = sub_2c534595[address(arg1)][u].field_256
            mem[_134 + 64] = sub_2c534595[address(arg1)][u].field_512
            mem[_134 + 96] = sub_2c534595[address(arg1)][u].field_768
            mem[_134 + 128] = sub_2c534595[address(arg1)][u].field_1024
            mem[t] = _134
            t = t + 32
            u = u + 1
            continue 
        if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
            revert with 0, 34
        _141 = mem[64]
        mem[64] = mem[64] + ceil32(sub_2c534595[address(arg1)][idx].field_1) + 32
        mem[_141] = sub_2c534595[address(arg1)][idx].field_1
        if sub_2c534595[address(arg1)][idx].field_0:
            if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                revert with 0, 34
            if not Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                mem[_134] = _141
                mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _134
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                mem[_141 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                mem[_134] = _141
                mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _134
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
            mem[_141 + 32] = sub_2c534595[address(arg1)][idx].field_0
            t = _141 + 32
            u = sha3(mem[0])
            while _141 + (uint255(sub_2c534595[address(arg1)][u].field_0) * 0.5) > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_134] = _141
            mem[_134 + 32] = sub_2c534595[address(arg1)][u].field_256
            mem[_134 + 64] = sub_2c534595[address(arg1)][u].field_512
            mem[_134 + 96] = sub_2c534595[address(arg1)][u].field_768
            mem[_134 + 128] = sub_2c534595[address(arg1)][u].field_1024
            mem[t] = _134
            t = t + 32
            u = u + 1
            continue 
        if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
            revert with 0, 34
        if sub_2c534595[address(arg1)][idx].field_1:
            if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                mem[_141 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
            else:
                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                mem[_141 + 32] = sub_2c534595[address(arg1)][idx].field_0
                t = _141 + 32
                u = sha3(mem[0])
                while _141 + sub_2c534595[address(arg1)][idx].field_1 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
        mem[_134] = _141
        mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
        mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
        mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
        mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
        mem[s] = _134
        s = s + 32
        idx = idx + 1
        continue 
    _132 = mem[96]
    _135 = mem[64]
    mem[64] = mem[64] + 160
    mem[_135] = 96
    mem[_135 + 32] = 0
    mem[_135 + 64] = 0
    mem[_135 + 96] = 0
    mem[_135 + 128] = 0
    if 0 >= mem[96]:
        revert with 0, 50
    _138 = mem[mem[128] + 64]
    if not -mem[mem[128] + 64]:
        _140 = mem[64]
        mem[64] = mem[64] + 64
        mem[_140] = 1
        mem[_140 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
        _142 = mem[64]
        mem[64] = mem[64] + 64
        mem[_142] = 1
        mem[_142 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _140
        t = _135
        while idx < _132:
            if idx >= mem[96]:
                revert with 0, 50
            _264 = mem[(32 * idx) + 128]
            _265 = mem[mem[(32 * idx) + 128] + 64]
            if not -mem[mem[(32 * idx) + 128] + 64]:
                _267 = mem[64]
                mem[64] = mem[64] + 64
                mem[_267] = 1
                mem[_267 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _268 = mem[64]
                _270 = mem[s]
                t = 0
                while t < _270:
                    mem[t + _268 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_270) <= _270:
                    _439 = mem[_142]
                    s = 0
                    while s < _439:
                        mem[s + _268 + _270 + 32] = mem[s + _142 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_439) <= _439:
                        _637 = mem[_267]
                        s = 0
                        while s < _637:
                            mem[s + _268 + _270 + _439 + 32] = mem[s + _267 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_637) <= _637:
                            _821 = mem[64]
                            mem[mem[64]] = _637 + _268 + _270 + _439 - mem[64]
                            mem[64] = _637 + _268 + _270 + _439 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _821
                            t = _264
                            continue 
                        mem[_637 + _268 + _270 + _439 + 32] = 0
                        _822 = mem[64]
                        mem[mem[64]] = _637 + _268 + _270 + _439 - mem[64]
                        mem[64] = _637 + _268 + _270 + _439 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _822
                        t = _264
                        continue 
                    mem[_439 + _268 + _270 + 32] = 0
                    _638 = mem[_267]
                    s = 0
                    while s < _638:
                        mem[s + _268 + _270 + _439 + 32] = mem[s + _267 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_638) <= _638:
                        _823 = mem[64]
                        mem[mem[64]] = _638 + _268 + _270 + _439 - mem[64]
                        mem[64] = _638 + _268 + _270 + _439 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _823
                        t = _264
                        continue 
                    mem[_638 + _268 + _270 + _439 + 32] = 0
                    _824 = mem[64]
                    mem[mem[64]] = _638 + _268 + _270 + _439 - mem[64]
                    mem[64] = _638 + _268 + _270 + _439 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _824
                    t = _264
                    continue 
                mem[_270 + _268 + 32] = 0
                _440 = mem[_142]
                s = 0
                while s < _440:
                    mem[s + _268 + _270 + 32] = mem[s + _142 + 32]
                    s = s + 32
                    continue 
                if ceil32(_440) <= _440:
                    _639 = mem[_267]
                    s = 0
                    while s < _639:
                        mem[s + _268 + _270 + _440 + 32] = mem[s + _267 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_639) <= _639:
                        _825 = mem[64]
                        mem[mem[64]] = _639 + _268 + _270 + _440 - mem[64]
                        mem[64] = _639 + _268 + _270 + _440 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _825
                        t = _264
                        continue 
                    mem[_639 + _268 + _270 + _440 + 32] = 0
                    _826 = mem[64]
                    mem[mem[64]] = _639 + _268 + _270 + _440 - mem[64]
                    mem[64] = _639 + _268 + _270 + _440 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _826
                    t = _264
                    continue 
                mem[_440 + _268 + _270 + 32] = 0
                _640 = mem[_267]
                s = 0
                while s < _640:
                    mem[s + _268 + _270 + _440 + 32] = mem[s + _267 + 32]
                    s = s + 32
                    continue 
                if ceil32(_640) <= _640:
                    _827 = mem[64]
                    mem[mem[64]] = _640 + _268 + _270 + _440 - mem[64]
                    mem[64] = _640 + _268 + _270 + _440 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _827
                    t = _264
                    continue 
                mem[_640 + _268 + _270 + _440 + 32] = 0
                _828 = mem[64]
                mem[mem[64]] = _640 + _268 + _270 + _440 - mem[64]
                mem[64] = _640 + _268 + _270 + _440 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _828
                t = _264
                continue 
            u = 0
            t = mem[mem[(32 * idx) + 128] + 64]
            while t:
                if not u + 1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _438 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = _265
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_438]:
                        revert with 0, 50
                    mem[v + _438 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _633 = mem[64]
                _635 = mem[s]
                t = 0
                while t < _635:
                    mem[t + _633 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_635) <= _635:
                    _817 = mem[_142]
                    s = 0
                    while s < _817:
                        mem[s + _633 + _635 + 32] = mem[s + _142 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_817) <= _817:
                        _1025 = mem[_438]
                        s = 0
                        while s < _1025:
                            mem[s + _633 + _635 + _817 + 32] = mem[s + _438 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_1025) <= _1025:
                            _1213 = mem[64]
                            mem[mem[64]] = _1025 + _633 + _635 + _817 - mem[64]
                            mem[64] = _1025 + _633 + _635 + _817 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _1213
                            t = _264
                            continue 
                        mem[_1025 + _633 + _635 + _817 + 32] = 0
                        _1214 = mem[64]
                        mem[mem[64]] = _1025 + _633 + _635 + _817 - mem[64]
                        mem[64] = _1025 + _633 + _635 + _817 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1214
                        t = _264
                        continue 
                    mem[_817 + _633 + _635 + 32] = 0
                    _1026 = mem[_438]
                    s = 0
                    while s < _1026:
                        mem[s + _633 + _635 + _817 + 32] = mem[s + _438 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1026) <= _1026:
                        _1215 = mem[64]
                        mem[mem[64]] = _1026 + _633 + _635 + _817 - mem[64]
                        mem[64] = _1026 + _633 + _635 + _817 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1215
                        t = _264
                        continue 
                    mem[_1026 + _633 + _635 + _817 + 32] = 0
                    _1216 = mem[64]
                    mem[mem[64]] = _1026 + _633 + _635 + _817 - mem[64]
                    mem[64] = _1026 + _633 + _635 + _817 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1216
                    t = _264
                    continue 
                mem[_635 + _633 + 32] = 0
                _818 = mem[_142]
                s = 0
                while s < _818:
                    mem[s + _633 + _635 + 32] = mem[s + _142 + 32]
                    s = s + 32
                    continue 
                if ceil32(_818) <= _818:
                    _1027 = mem[_438]
                    s = 0
                    while s < _1027:
                        mem[s + _633 + _635 + _818 + 32] = mem[s + _438 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1027) <= _1027:
                        _1217 = mem[64]
                        mem[mem[64]] = _1027 + _633 + _635 + _818 - mem[64]
                        mem[64] = _1027 + _633 + _635 + _818 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1217
                        t = _264
                        continue 
                    mem[_1027 + _633 + _635 + _818 + 32] = 0
                    _1218 = mem[64]
                    mem[mem[64]] = _1027 + _633 + _635 + _818 - mem[64]
                    mem[64] = _1027 + _633 + _635 + _818 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1218
                    t = _264
                    continue 
                mem[_818 + _633 + _635 + 32] = 0
                _1028 = mem[_438]
                s = 0
                while s < _1028:
                    mem[s + _633 + _635 + _818 + 32] = mem[s + _438 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1028) <= _1028:
                    _1219 = mem[64]
                    mem[mem[64]] = _1028 + _633 + _635 + _818 - mem[64]
                    mem[64] = _1028 + _633 + _635 + _818 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1219
                    t = _264
                    continue 
                mem[_1028 + _633 + _635 + _818 + 32] = 0
                _1220 = mem[64]
                mem[mem[64]] = _1028 + _633 + _635 + _818 - mem[64]
                mem[64] = _1028 + _633 + _635 + _818 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1220
                t = _264
                continue 
            mem[_438 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = _265
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_438]:
                    revert with 0, 50
                mem[v + _438 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _634 = mem[64]
            _636 = mem[s]
            t = 0
            while t < _636:
                mem[t + _634 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_636) <= _636:
                _819 = mem[_142]
                s = 0
                while s < _819:
                    mem[s + _634 + _636 + 32] = mem[s + _142 + 32]
                    s = s + 32
                    continue 
                if ceil32(_819) <= _819:
                    _1029 = mem[_438]
                    idx = 0
                    while idx < _1029:
                        mem[idx + _634 + _636 + _819 + 32] = mem[idx + _438 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_1029) <= _1029:
                        _1221 = mem[64]
                        mem[mem[64]] = _1029 + _634 + _636 + _819 - mem[64]
                        mem[64] = _1029 + _634 + _636 + _819 + 32
                        if not ceil32(_819) + 1:
                            revert with 0, 17
                        s = ceil32(_819) + 1
                        s = _1221
                        t = _264
                        continue 
                    mem[_1029 + _634 + _636 + _819 + 32] = 0
                    _1222 = mem[64]
                    mem[mem[64]] = _1029 + _634 + _636 + _819 - mem[64]
                    mem[64] = _1029 + _634 + _636 + _819 + 32
                    if not ceil32(_819) + 1:
                        revert with 0, 17
                    s = ceil32(_819) + 1
                    s = _1222
                    t = _264
                    continue 
                mem[_819 + _634 + _636 + 32] = 0
                _1030 = mem[_438]
                idx = 0
                while idx < _1030:
                    mem[idx + _634 + _636 + _819 + 32] = mem[idx + _438 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1030) <= _1030:
                    _1223 = mem[64]
                    mem[mem[64]] = _1030 + _634 + _636 + _819 - mem[64]
                    mem[64] = _1030 + _634 + _636 + _819 + 32
                    if not ceil32(_819) + 1:
                        revert with 0, 17
                    s = ceil32(_819) + 1
                    s = _1223
                    t = _264
                    continue 
                mem[_1030 + _634 + _636 + _819 + 32] = 0
                _1224 = mem[64]
                mem[mem[64]] = _1030 + _634 + _636 + _819 - mem[64]
                mem[64] = _1030 + _634 + _636 + _819 + 32
                if not ceil32(_819) + 1:
                    revert with 0, 17
                s = ceil32(_819) + 1
                s = _1224
                t = _264
                continue 
            mem[_636 + _634 + 32] = 0
            _820 = mem[_142]
            s = 0
            while s < _820:
                mem[s + _634 + _636 + 32] = mem[s + _142 + 32]
                s = s + 32
                continue 
            if ceil32(_820) <= _820:
                _1031 = mem[_438]
                idx = 0
                while idx < _1031:
                    mem[idx + _634 + _636 + _820 + 32] = mem[idx + _438 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1031) <= _1031:
                    _1225 = mem[64]
                    mem[mem[64]] = _1031 + _634 + _636 + _820 - mem[64]
                    mem[64] = _1031 + _634 + _636 + _820 + 32
                    if not ceil32(_820) + 1:
                        revert with 0, 17
                    s = ceil32(_820) + 1
                    s = _1225
                    t = _264
                    continue 
                mem[_1031 + _634 + _636 + _820 + 32] = 0
                _1226 = mem[64]
                mem[mem[64]] = _1031 + _634 + _636 + _820 - mem[64]
                mem[64] = _1031 + _634 + _636 + _820 + 32
                if not ceil32(_820) + 1:
                    revert with 0, 17
                s = ceil32(_820) + 1
                s = _1226
                t = _264
                continue 
            mem[_820 + _634 + _636 + 32] = 0
            _1032 = mem[_438]
            idx = 0
            while idx < _1032:
                mem[idx + _634 + _636 + _820 + 32] = mem[idx + _438 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1032) <= _1032:
                _1227 = mem[64]
                mem[mem[64]] = _1032 + _634 + _636 + _820 - mem[64]
                mem[64] = _1032 + _634 + _636 + _820 + 32
                if not ceil32(_820) + 1:
                    revert with 0, 17
                s = ceil32(_820) + 1
                s = _1227
                t = _264
                continue 
            mem[_1032 + _634 + _636 + _820 + 32] = 0
            _1228 = mem[64]
            mem[mem[64]] = _1032 + _634 + _636 + _820 - mem[64]
            mem[64] = _1032 + _634 + _636 + _820 + 32
            if not ceil32(_820) + 1:
                revert with 0, 17
            s = ceil32(_820) + 1
            s = _1228
            t = _264
            continue 
        _263 = mem[64]
        mem[mem[64]] = 32
        _266 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_266)] = mem[s + 32 len ceil32(_266)]
        if ceil32(_266) <= _266:
            return 32, mem[mem[64] + 32 len ceil32(_266) + 32]
        mem[_266 + mem[64] + 64] = 0
        return memory
          from mem[64]
           len ceil32(_266) + _263 + -mem[64] + 64
    s = 0
    idx = mem[mem[128] + 64]
    while idx:
        if not s + 1:
            revert with 0, 17
        s = s + 1
        idx = idx / 10
        continue 
    if s > test266151307():
        revert with 0, 65
    _262 = mem[64]
    mem[mem[64]] = s
    mem[64] = mem[64] + ceil32(s) + 32
    if not s:
        t = s
        idx = _138
        while idx:
            if t < 1:
                revert with 0, 17
            if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if idx < 10 * idx / 10:
                revert with 0, 17
            if 48 > -uint8(idx - (10 * idx / 10)) + 255:
                revert with 0, 17
            if t - 1 >= mem[_262]:
                revert with 0, 50
            mem[t + _262 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        _436 = mem[64]
        mem[64] = mem[64] + 64
        mem[_436] = 1
        mem[_436 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _262
        u = _135
        while idx < _132:
            if idx >= mem[96]:
                revert with 0, 50
            _628 = mem[(32 * idx) + 128]
            _629 = mem[mem[(32 * idx) + 128] + 64]
            if not -mem[mem[(32 * idx) + 128] + 64]:
                _642 = mem[64]
                mem[64] = mem[64] + 64
                mem[_642] = 1
                mem[_642 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _645 = mem[64]
                _647 = mem[s]
                u = 0
                while u < _647:
                    mem[u + _645 + 32] = mem[u + s + 32]
                    u = u + 32
                    continue 
                if ceil32(_647) <= _647:
                    _813 = mem[_436]
                    s = 0
                    while s < _813:
                        mem[s + _645 + _647 + 32] = mem[s + _436 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_813) <= _813:
                        _1015 = mem[_642]
                        s = 0
                        while s < _1015:
                            mem[s + _645 + _647 + _813 + 32] = mem[s + _642 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_1015) <= _1015:
                            _1197 = mem[64]
                            mem[mem[64]] = _1015 + _645 + _647 + _813 - mem[64]
                            mem[64] = _1015 + _645 + _647 + _813 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _1197
                            u = _628
                            continue 
                        mem[_1015 + _645 + _647 + _813 + 32] = 0
                        _1198 = mem[64]
                        mem[mem[64]] = _1015 + _645 + _647 + _813 - mem[64]
                        mem[64] = _1015 + _645 + _647 + _813 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1198
                        u = _628
                        continue 
                    mem[_813 + _645 + _647 + 32] = 0
                    _1016 = mem[_642]
                    s = 0
                    while s < _1016:
                        mem[s + _645 + _647 + _813 + 32] = mem[s + _642 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1016) <= _1016:
                        _1199 = mem[64]
                        mem[mem[64]] = _1016 + _645 + _647 + _813 - mem[64]
                        mem[64] = _1016 + _645 + _647 + _813 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1199
                        u = _628
                        continue 
                    mem[_1016 + _645 + _647 + _813 + 32] = 0
                    _1200 = mem[64]
                    mem[mem[64]] = _1016 + _645 + _647 + _813 - mem[64]
                    mem[64] = _1016 + _645 + _647 + _813 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1200
                    u = _628
                    continue 
                mem[_647 + _645 + 32] = 0
                _814 = mem[_436]
                s = 0
                while s < _814:
                    mem[s + _645 + _647 + 32] = mem[s + _436 + 32]
                    s = s + 32
                    continue 
                if ceil32(_814) <= _814:
                    _1017 = mem[_642]
                    s = 0
                    while s < _1017:
                        mem[s + _645 + _647 + _814 + 32] = mem[s + _642 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1017) <= _1017:
                        _1201 = mem[64]
                        mem[mem[64]] = _1017 + _645 + _647 + _814 - mem[64]
                        mem[64] = _1017 + _645 + _647 + _814 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1201
                        u = _628
                        continue 
                    mem[_1017 + _645 + _647 + _814 + 32] = 0
                    _1202 = mem[64]
                    mem[mem[64]] = _1017 + _645 + _647 + _814 - mem[64]
                    mem[64] = _1017 + _645 + _647 + _814 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1202
                    u = _628
                    continue 
                mem[_814 + _645 + _647 + 32] = 0
                _1018 = mem[_642]
                s = 0
                while s < _1018:
                    mem[s + _645 + _647 + _814 + 32] = mem[s + _642 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1018) <= _1018:
                    _1203 = mem[64]
                    mem[mem[64]] = _1018 + _645 + _647 + _814 - mem[64]
                    mem[64] = _1018 + _645 + _647 + _814 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1203
                    u = _628
                    continue 
                mem[_1018 + _645 + _647 + _814 + 32] = 0
                _1204 = mem[64]
                mem[mem[64]] = _1018 + _645 + _647 + _814 - mem[64]
                mem[64] = _1018 + _645 + _647 + _814 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1204
                u = _628
                continue 
            u = 0
            t = mem[mem[(32 * idx) + 128] + 64]
            while t:
                if not u + 1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _811 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = _629
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_811]:
                        revert with 0, 50
                    mem[v + _811 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _1009 = mem[64]
                _1013 = mem[s]
                t = 0
                while t < _1013:
                    mem[t + _1009 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_1013) <= _1013:
                    _1189 = mem[_436]
                    s = 0
                    while s < _1189:
                        mem[s + _1009 + _1013 + 32] = mem[s + _436 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1189) <= _1189:
                        _1309 = mem[_811]
                        s = 0
                        while s < _1309:
                            mem[s + _1009 + _1013 + _1189 + 32] = mem[s + _811 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_1309) <= _1309:
                            _1389 = mem[64]
                            mem[mem[64]] = _1309 + _1009 + _1013 + _1189 - mem[64]
                            mem[64] = _1309 + _1009 + _1013 + _1189 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _1389
                            u = _628
                            continue 
                        mem[_1309 + _1009 + _1013 + _1189 + 32] = 0
                        _1390 = mem[64]
                        mem[mem[64]] = _1309 + _1009 + _1013 + _1189 - mem[64]
                        mem[64] = _1309 + _1009 + _1013 + _1189 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1390
                        u = _628
                        continue 
                    mem[_1189 + _1009 + _1013 + 32] = 0
                    _1310 = mem[_811]
                    s = 0
                    while s < _1310:
                        mem[s + _1009 + _1013 + _1189 + 32] = mem[s + _811 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1310) <= _1310:
                        _1391 = mem[64]
                        mem[mem[64]] = _1310 + _1009 + _1013 + _1189 - mem[64]
                        mem[64] = _1310 + _1009 + _1013 + _1189 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1391
                        u = _628
                        continue 
                    mem[_1310 + _1009 + _1013 + _1189 + 32] = 0
                    _1392 = mem[64]
                    mem[mem[64]] = _1310 + _1009 + _1013 + _1189 - mem[64]
                    mem[64] = _1310 + _1009 + _1013 + _1189 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1392
                    u = _628
                    continue 
                mem[_1013 + _1009 + 32] = 0
                _1190 = mem[_436]
                s = 0
                while s < _1190:
                    mem[s + _1009 + _1013 + 32] = mem[s + _436 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1190) <= _1190:
                    _1311 = mem[_811]
                    s = 0
                    while s < _1311:
                        mem[s + _1009 + _1013 + _1190 + 32] = mem[s + _811 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1311) <= _1311:
                        _1393 = mem[64]
                        mem[mem[64]] = _1311 + _1009 + _1013 + _1190 - mem[64]
                        mem[64] = _1311 + _1009 + _1013 + _1190 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1393
                        u = _628
                        continue 
                    mem[_1311 + _1009 + _1013 + _1190 + 32] = 0
                    _1394 = mem[64]
                    mem[mem[64]] = _1311 + _1009 + _1013 + _1190 - mem[64]
                    mem[64] = _1311 + _1009 + _1013 + _1190 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1394
                    u = _628
                    continue 
                mem[_1190 + _1009 + _1013 + 32] = 0
                _1312 = mem[_811]
                s = 0
                while s < _1312:
                    mem[s + _1009 + _1013 + _1190 + 32] = mem[s + _811 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1312) <= _1312:
                    _1395 = mem[64]
                    mem[mem[64]] = _1312 + _1009 + _1013 + _1190 - mem[64]
                    mem[64] = _1312 + _1009 + _1013 + _1190 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1395
                    u = _628
                    continue 
                mem[_1312 + _1009 + _1013 + _1190 + 32] = 0
                _1396 = mem[64]
                mem[mem[64]] = _1312 + _1009 + _1013 + _1190 - mem[64]
                mem[64] = _1312 + _1009 + _1013 + _1190 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1396
                u = _628
                continue 
            mem[_811 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = _629
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_811]:
                    revert with 0, 50
                mem[v + _811 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _1010 = mem[64]
            _1014 = mem[s]
            t = 0
            while t < _1014:
                mem[t + _1010 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_1014) <= _1014:
                _1191 = mem[_436]
                s = 0
                while s < _1191:
                    mem[s + _1010 + _1014 + 32] = mem[s + _436 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1191) <= _1191:
                    _1313 = mem[_811]
                    idx = 0
                    while idx < _1313:
                        mem[idx + _1010 + _1014 + _1191 + 32] = mem[idx + _811 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_1313) <= _1313:
                        _1397 = mem[64]
                        mem[mem[64]] = _1313 + _1010 + _1014 + _1191 - mem[64]
                        mem[64] = _1313 + _1010 + _1014 + _1191 + 32
                        if not ceil32(_1191) + 1:
                            revert with 0, 17
                        s = ceil32(_1191) + 1
                        s = _1397
                        u = _628
                        continue 
                    mem[_1313 + _1010 + _1014 + _1191 + 32] = 0
                    _1398 = mem[64]
                    mem[mem[64]] = _1313 + _1010 + _1014 + _1191 - mem[64]
                    mem[64] = _1313 + _1010 + _1014 + _1191 + 32
                    if not ceil32(_1191) + 1:
                        revert with 0, 17
                    s = ceil32(_1191) + 1
                    s = _1398
                    u = _628
                    continue 
                mem[_1191 + _1010 + _1014 + 32] = 0
                _1314 = mem[_811]
                idx = 0
                while idx < _1314:
                    mem[idx + _1010 + _1014 + _1191 + 32] = mem[idx + _811 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1314) <= _1314:
                    _1399 = mem[64]
                    mem[mem[64]] = _1314 + _1010 + _1014 + _1191 - mem[64]
                    mem[64] = _1314 + _1010 + _1014 + _1191 + 32
                    if not ceil32(_1191) + 1:
                        revert with 0, 17
                    s = ceil32(_1191) + 1
                    s = _1399
                    u = _628
                    continue 
                mem[_1314 + _1010 + _1014 + _1191 + 32] = 0
                _1400 = mem[64]
                mem[mem[64]] = _1314 + _1010 + _1014 + _1191 - mem[64]
                mem[64] = _1314 + _1010 + _1014 + _1191 + 32
                if not ceil32(_1191) + 1:
                    revert with 0, 17
                s = ceil32(_1191) + 1
                s = _1400
                u = _628
                continue 
            mem[_1014 + _1010 + 32] = 0
            _1192 = mem[_436]
            s = 0
            while s < _1192:
                mem[s + _1010 + _1014 + 32] = mem[s + _436 + 32]
                s = s + 32
                continue 
            if ceil32(_1192) <= _1192:
                _1315 = mem[_811]
                idx = 0
                while idx < _1315:
                    mem[idx + _1010 + _1014 + _1192 + 32] = mem[idx + _811 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1315) <= _1315:
                    _1401 = mem[64]
                    mem[mem[64]] = _1315 + _1010 + _1014 + _1192 - mem[64]
                    mem[64] = _1315 + _1010 + _1014 + _1192 + 32
                    if not ceil32(_1192) + 1:
                        revert with 0, 17
                    s = ceil32(_1192) + 1
                    s = _1401
                    u = _628
                    continue 
                mem[_1315 + _1010 + _1014 + _1192 + 32] = 0
                _1402 = mem[64]
                mem[mem[64]] = _1315 + _1010 + _1014 + _1192 - mem[64]
                mem[64] = _1315 + _1010 + _1014 + _1192 + 32
                if not ceil32(_1192) + 1:
                    revert with 0, 17
                s = ceil32(_1192) + 1
                s = _1402
                u = _628
                continue 
            mem[_1192 + _1010 + _1014 + 32] = 0
            _1316 = mem[_811]
            idx = 0
            while idx < _1316:
                mem[idx + _1010 + _1014 + _1192 + 32] = mem[idx + _811 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1316) <= _1316:
                _1403 = mem[64]
                mem[mem[64]] = _1316 + _1010 + _1014 + _1192 - mem[64]
                mem[64] = _1316 + _1010 + _1014 + _1192 + 32
                if not ceil32(_1192) + 1:
                    revert with 0, 17
                s = ceil32(_1192) + 1
                s = _1403
                u = _628
                continue 
            mem[_1316 + _1010 + _1014 + _1192 + 32] = 0
            _1404 = mem[64]
            mem[mem[64]] = _1316 + _1010 + _1014 + _1192 - mem[64]
            mem[64] = _1316 + _1010 + _1014 + _1192 + 32
            if not ceil32(_1192) + 1:
                revert with 0, 17
            s = ceil32(_1192) + 1
            s = _1404
            u = _628
            continue 
        _627 = mem[64]
        mem[mem[64]] = 32
        _641 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_641)] = mem[s + 32 len ceil32(_641)]
        if ceil32(_641) <= _641:
            return 32, mem[mem[64] + 32 len ceil32(_641) + 32]
        mem[_641 + mem[64] + 64] = 0
        return memory
          from mem[64]
           len ceil32(_641) + _627 + -mem[64] + 64
    mem[_262 + 32 len s] = call.data[calldata.size len s]
    t = s
    idx = _138
    while idx:
        if t < 1:
            revert with 0, 17
        if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
            revert with 0, 17
        if idx < 10 * idx / 10:
            revert with 0, 17
        if 48 > -uint8(idx - (10 * idx / 10)) + 255:
            revert with 0, 17
        if t - 1 >= mem[_262]:
            revert with 0, 50
        mem[t + _262 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
        t = t - 1
        idx = idx / 10
        continue 
    _437 = mem[64]
    mem[64] = mem[64] + 64
    mem[_437] = 1
    mem[_437 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
    idx = 1
    s = _262
    u = _135
    while idx < _132:
        if idx >= mem[96]:
            revert with 0, 50
        _631 = mem[(32 * idx) + 128]
        _632 = mem[mem[(32 * idx) + 128] + 64]
        if not -mem[mem[(32 * idx) + 128] + 64]:
            _644 = mem[64]
            mem[64] = mem[64] + 64
            mem[_644] = 1
            mem[_644 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
            _646 = mem[64]
            _648 = mem[s]
            u = 0
            while u < _648:
                mem[u + _646 + 32] = mem[u + s + 32]
                u = u + 32
                continue 
            if ceil32(_648) <= _648:
                _815 = mem[_437]
                s = 0
                while s < _815:
                    mem[s + _646 + _648 + 32] = mem[s + _437 + 32]
                    s = s + 32
                    continue 
                if ceil32(_815) <= _815:
                    _1021 = mem[_644]
                    s = 0
                    while s < _1021:
                        mem[s + _646 + _648 + _815 + 32] = mem[s + _644 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1021) <= _1021:
                        _1205 = mem[64]
                        mem[mem[64]] = _1021 + _646 + _648 + _815 - mem[64]
                        mem[64] = _1021 + _646 + _648 + _815 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1205
                        u = _631
                        continue 
                    mem[_1021 + _646 + _648 + _815 + 32] = 0
                    _1206 = mem[64]
                    mem[mem[64]] = _1021 + _646 + _648 + _815 - mem[64]
                    mem[64] = _1021 + _646 + _648 + _815 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1206
                    u = _631
                    continue 
                mem[_815 + _646 + _648 + 32] = 0
                _1022 = mem[_644]
                s = 0
                while s < _1022:
                    mem[s + _646 + _648 + _815 + 32] = mem[s + _644 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1022) <= _1022:
                    _1207 = mem[64]
                    mem[mem[64]] = _1022 + _646 + _648 + _815 - mem[64]
                    mem[64] = _1022 + _646 + _648 + _815 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1207
                    u = _631
                    continue 
                mem[_1022 + _646 + _648 + _815 + 32] = 0
                _1208 = mem[64]
                mem[mem[64]] = _1022 + _646 + _648 + _815 - mem[64]
                mem[64] = _1022 + _646 + _648 + _815 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1208
                u = _631
                continue 
            mem[_648 + _646 + 32] = 0
            _816 = mem[_437]
            s = 0
            while s < _816:
                mem[s + _646 + _648 + 32] = mem[s + _437 + 32]
                s = s + 32
                continue 
            if ceil32(_816) <= _816:
                _1023 = mem[_644]
                s = 0
                while s < _1023:
                    mem[s + _646 + _648 + _816 + 32] = mem[s + _644 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1023) <= _1023:
                    _1209 = mem[64]
                    mem[mem[64]] = _1023 + _646 + _648 + _816 - mem[64]
                    mem[64] = _1023 + _646 + _648 + _816 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1209
                    u = _631
                    continue 
                mem[_1023 + _646 + _648 + _816 + 32] = 0
                _1210 = mem[64]
                mem[mem[64]] = _1023 + _646 + _648 + _816 - mem[64]
                mem[64] = _1023 + _646 + _648 + _816 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1210
                u = _631
                continue 
            mem[_816 + _646 + _648 + 32] = 0
            _1024 = mem[_644]
            s = 0
            while s < _1024:
                mem[s + _646 + _648 + _816 + 32] = mem[s + _644 + 32]
                s = s + 32
                continue 
            if ceil32(_1024) <= _1024:
                _1211 = mem[64]
                mem[mem[64]] = _1024 + _646 + _648 + _816 - mem[64]
                mem[64] = _1024 + _646 + _648 + _816 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1211
                u = _631
                continue 
            mem[_1024 + _646 + _648 + _816 + 32] = 0
            _1212 = mem[64]
            mem[mem[64]] = _1024 + _646 + _648 + _816 - mem[64]
            mem[64] = _1024 + _646 + _648 + _816 + 32
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            s = _1212
            u = _631
            continue 
        u = 0
        t = mem[mem[(32 * idx) + 128] + 64]
        while t:
            if not u + 1:
                revert with 0, 17
            u = u + 1
            t = t / 10
            continue 
        if u > test266151307():
            revert with 0, 65
        _812 = mem[64]
        mem[mem[64]] = u
        mem[64] = mem[64] + ceil32(u) + 32
        if not u:
            v = u
            t = _632
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_812]:
                    revert with 0, 50
                mem[v + _812 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _1011 = mem[64]
            _1019 = mem[s]
            t = 0
            while t < _1019:
                mem[t + _1011 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_1019) <= _1019:
                _1193 = mem[_437]
                s = 0
                while s < _1193:
                    mem[s + _1011 + _1019 + 32] = mem[s + _437 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1193) <= _1193:
                    _1317 = mem[_812]
                    s = 0
                    while s < _1317:
                        mem[s + _1011 + _1019 + _1193 + 32] = mem[s + _812 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1317) <= _1317:
                        _1405 = mem[64]
                        mem[mem[64]] = _1317 + _1011 + _1019 + _1193 - mem[64]
                        mem[64] = _1317 + _1011 + _1019 + _1193 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1405
                        u = _631
                        continue 
                    mem[_1317 + _1011 + _1019 + _1193 + 32] = 0
                    _1406 = mem[64]
                    mem[mem[64]] = _1317 + _1011 + _1019 + _1193 - mem[64]
                    mem[64] = _1317 + _1011 + _1019 + _1193 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1406
                    u = _631
                    continue 
                mem[_1193 + _1011 + _1019 + 32] = 0
                _1318 = mem[_812]
                s = 0
                while s < _1318:
                    mem[s + _1011 + _1019 + _1193 + 32] = mem[s + _812 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1318) <= _1318:
                    _1407 = mem[64]
                    mem[mem[64]] = _1318 + _1011 + _1019 + _1193 - mem[64]
                    mem[64] = _1318 + _1011 + _1019 + _1193 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1407
                    u = _631
                    continue 
                mem[_1318 + _1011 + _1019 + _1193 + 32] = 0
                _1408 = mem[64]
                mem[mem[64]] = _1318 + _1011 + _1019 + _1193 - mem[64]
                mem[64] = _1318 + _1011 + _1019 + _1193 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1408
                u = _631
                continue 
            mem[_1019 + _1011 + 32] = 0
            _1194 = mem[_437]
            s = 0
            while s < _1194:
                mem[s + _1011 + _1019 + 32] = mem[s + _437 + 32]
                s = s + 32
                continue 
            if ceil32(_1194) <= _1194:
                _1319 = mem[_812]
                s = 0
                while s < _1319:
                    mem[s + _1011 + _1019 + _1194 + 32] = mem[s + _812 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1319) <= _1319:
                    _1409 = mem[64]
                    mem[mem[64]] = _1319 + _1011 + _1019 + _1194 - mem[64]
                    mem[64] = _1319 + _1011 + _1019 + _1194 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1409
                    u = _631
                    continue 
                mem[_1319 + _1011 + _1019 + _1194 + 32] = 0
                _1410 = mem[64]
                mem[mem[64]] = _1319 + _1011 + _1019 + _1194 - mem[64]
                mem[64] = _1319 + _1011 + _1019 + _1194 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1410
                u = _631
                continue 
            mem[_1194 + _1011 + _1019 + 32] = 0
            _1320 = mem[_812]
            s = 0
            while s < _1320:
                mem[s + _1011 + _1019 + _1194 + 32] = mem[s + _812 + 32]
                s = s + 32
                continue 
            if ceil32(_1320) <= _1320:
                _1411 = mem[64]
                mem[mem[64]] = _1320 + _1011 + _1019 + _1194 - mem[64]
                mem[64] = _1320 + _1011 + _1019 + _1194 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1411
                u = _631
                continue 
            mem[_1320 + _1011 + _1019 + _1194 + 32] = 0
            _1412 = mem[64]
            mem[mem[64]] = _1320 + _1011 + _1019 + _1194 - mem[64]
            mem[64] = _1320 + _1011 + _1019 + _1194 + 32
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            s = _1412
            u = _631
            continue 
        mem[_812 + 32 len u] = call.data[calldata.size len u]
        v = u
        t = _632
        while t:
            if v < 1:
                revert with 0, 17
            if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if t < 10 * t / 10:
                revert with 0, 17
            if 48 > -uint8(t - (10 * t / 10)) + 255:
                revert with 0, 17
            if v - 1 >= mem[_812]:
                revert with 0, 50
            mem[v + _812 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
            v = v - 1
            t = t / 10
            continue 
        _1012 = mem[64]
        _1020 = mem[s]
        t = 0
        while t < _1020:
            mem[t + _1012 + 32] = mem[t + s + 32]
            t = t + 32
            continue 
        if ceil32(_1020) <= _1020:
            _1195 = mem[_437]
            s = 0
            while s < _1195:
                mem[s + _1012 + _1020 + 32] = mem[s + _437 + 32]
                s = s + 32
                continue 
            if ceil32(_1195) <= _1195:
                _1321 = mem[_812]
                idx = 0
                while idx < _1321:
                    mem[idx + _1012 + _1020 + _1195 + 32] = mem[idx + _812 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1321) <= _1321:
                    _1413 = mem[64]
                    mem[mem[64]] = _1321 + _1012 + _1020 + _1195 - mem[64]
                    mem[64] = _1321 + _1012 + _1020 + _1195 + 32
                    if not ceil32(_1195) + 1:
                        revert with 0, 17
                    s = ceil32(_1195) + 1
                    s = _1413
                    u = _631
                    continue 
                mem[_1321 + _1012 + _1020 + _1195 + 32] = 0
                _1414 = mem[64]
                mem[mem[64]] = _1321 + _1012 + _1020 + _1195 - mem[64]
                mem[64] = _1321 + _1012 + _1020 + _1195 + 32
                if not ceil32(_1195) + 1:
                    revert with 0, 17
                s = ceil32(_1195) + 1
                s = _1414
                u = _631
                continue 
            mem[_1195 + _1012 + _1020 + 32] = 0
            _1322 = mem[_812]
            idx = 0
            while idx < _1322:
                mem[idx + _1012 + _1020 + _1195 + 32] = mem[idx + _812 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1322) <= _1322:
                _1415 = mem[64]
                mem[mem[64]] = _1322 + _1012 + _1020 + _1195 - mem[64]
                mem[64] = _1322 + _1012 + _1020 + _1195 + 32
                if not ceil32(_1195) + 1:
                    revert with 0, 17
                s = ceil32(_1195) + 1
                s = _1415
                u = _631
                continue 
            mem[_1322 + _1012 + _1020 + _1195 + 32] = 0
            _1416 = mem[64]
            mem[mem[64]] = _1322 + _1012 + _1020 + _1195 - mem[64]
            mem[64] = _1322 + _1012 + _1020 + _1195 + 32
            if not ceil32(_1195) + 1:
                revert with 0, 17
            s = ceil32(_1195) + 1
            s = _1416
            u = _631
            continue 
        mem[_1020 + _1012 + 32] = 0
        _1196 = mem[_437]
        s = 0
        while s < _1196:
            mem[s + _1012 + _1020 + 32] = mem[s + _437 + 32]
            s = s + 32
            continue 
        if ceil32(_1196) <= _1196:
            _1323 = mem[_812]
            idx = 0
            while idx < _1323:
                mem[idx + _1012 + _1020 + _1196 + 32] = mem[idx + _812 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1323) <= _1323:
                _1417 = mem[64]
                mem[mem[64]] = _1323 + _1012 + _1020 + _1196 - mem[64]
                mem[64] = _1323 + _1012 + _1020 + _1196 + 32
                if not ceil32(_1196) + 1:
                    revert with 0, 17
                s = ceil32(_1196) + 1
                s = _1417
                u = _631
                continue 
            mem[_1323 + _1012 + _1020 + _1196 + 32] = 0
            _1418 = mem[64]
            mem[mem[64]] = _1323 + _1012 + _1020 + _1196 - mem[64]
            mem[64] = _1323 + _1012 + _1020 + _1196 + 32
            if not ceil32(_1196) + 1:
                revert with 0, 17
            s = ceil32(_1196) + 1
            s = _1418
            u = _631
            continue 
        mem[_1196 + _1012 + _1020 + 32] = 0
        _1324 = mem[_812]
        idx = 0
        while idx < _1324:
            mem[idx + _1012 + _1020 + _1196 + 32] = mem[idx + _812 + 32]
            idx = idx + 32
            continue 
        if ceil32(_1324) <= _1324:
            _1419 = mem[64]
            mem[mem[64]] = _1324 + _1012 + _1020 + _1196 - mem[64]
            mem[64] = _1324 + _1012 + _1020 + _1196 + 32
            if not ceil32(_1196) + 1:
                revert with 0, 17
            s = ceil32(_1196) + 1
            s = _1419
            u = _631
            continue 
        mem[_1324 + _1012 + _1020 + _1196 + 32] = 0
        _1420 = mem[64]
        mem[mem[64]] = _1324 + _1012 + _1020 + _1196 - mem[64]
        mem[64] = _1324 + _1012 + _1020 + _1196 + 32
        if not ceil32(_1196) + 1:
            revert with 0, 17
        s = ceil32(_1196) + 1
        s = _1420
        u = _631
        continue 
    _630 = mem[64]
    mem[mem[64]] = 32
    _643 = mem[s]
    mem[mem[64] + 32] = mem[s]
    mem[mem[64] + 64 len ceil32(_643)] = mem[s + 32 len ceil32(_643)]
    if ceil32(_643) <= _643:
        return 32, mem[mem[64] + 32 len ceil32(_643) + 32]
    mem[_643 + mem[64] + 64] = 0
    return memory
      from mem[64]
       len ceil32(_643) + _630 + -mem[64] + 64
}

function sub_5b53f6fc(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    mem[0] = address(arg1)
    mem[32] = 10
    mem[64] = (32 * sub_2c534595[address(arg1)].field_0) + 128
    mem[96] = sub_2c534595[address(arg1)].field_0
    s = 128
    idx = 0
    while idx < sub_2c534595[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 10)
        _134 = mem[64]
        mem[64] = mem[64] + 160
        if sub_2c534595[address(arg1)][idx].field_0:
            if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                revert with 0, 34
            _139 = mem[64]
            mem[64] = mem[64] + ceil32(uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) + 32
            mem[_139] = uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5
            if sub_2c534595[address(arg1)][idx].field_0:
                if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                    revert with 0, 34
                if Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                    if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                        mem[_139 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                    else:
                        mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                        mem[_139 + 32] = sub_2c534595[address(arg1)][idx].field_0
                        t = _139 + 32
                        u = sha3(mem[0])
                        while _139 + (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                mem[_134] = _139
                mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _134
                s = s + 32
                idx = idx + 1
                continue 
            if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                revert with 0, 34
            if not sub_2c534595[address(arg1)][idx].field_1:
                mem[_134] = _139
                mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _134
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                mem[_139 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                mem[_134] = _139
                mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _134
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
            mem[_139 + 32] = sub_2c534595[address(arg1)][idx].field_0
            t = _139 + 32
            u = sha3(mem[0])
            while _139 + sub_2c534595[address(arg1)][u].field_1 > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_134] = _139
            mem[_134 + 32] = sub_2c534595[address(arg1)][u].field_256
            mem[_134 + 64] = sub_2c534595[address(arg1)][u].field_512
            mem[_134 + 96] = sub_2c534595[address(arg1)][u].field_768
            mem[_134 + 128] = sub_2c534595[address(arg1)][u].field_1024
            mem[t] = _134
            t = t + 32
            u = u + 1
            continue 
        if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
            revert with 0, 34
        _141 = mem[64]
        mem[64] = mem[64] + ceil32(sub_2c534595[address(arg1)][idx].field_1) + 32
        mem[_141] = sub_2c534595[address(arg1)][idx].field_1
        if sub_2c534595[address(arg1)][idx].field_0:
            if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                revert with 0, 34
            if not Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                mem[_134] = _141
                mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _134
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                mem[_141 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                mem[_134] = _141
                mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _134
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
            mem[_141 + 32] = sub_2c534595[address(arg1)][idx].field_0
            t = _141 + 32
            u = sha3(mem[0])
            while _141 + (uint255(sub_2c534595[address(arg1)][u].field_0) * 0.5) > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_134] = _141
            mem[_134 + 32] = sub_2c534595[address(arg1)][u].field_256
            mem[_134 + 64] = sub_2c534595[address(arg1)][u].field_512
            mem[_134 + 96] = sub_2c534595[address(arg1)][u].field_768
            mem[_134 + 128] = sub_2c534595[address(arg1)][u].field_1024
            mem[t] = _134
            t = t + 32
            u = u + 1
            continue 
        if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
            revert with 0, 34
        if sub_2c534595[address(arg1)][idx].field_1:
            if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                mem[_141 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
            else:
                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                mem[_141 + 32] = sub_2c534595[address(arg1)][idx].field_0
                t = _141 + 32
                u = sha3(mem[0])
                while _141 + sub_2c534595[address(arg1)][idx].field_1 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
        mem[_134] = _141
        mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
        mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
        mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
        mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
        mem[s] = _134
        s = s + 32
        idx = idx + 1
        continue 
    _132 = mem[96]
    _135 = mem[64]
    mem[64] = mem[64] + 160
    mem[_135] = 96
    mem[_135 + 32] = 0
    mem[_135 + 64] = 0
    mem[_135 + 96] = 0
    mem[_135 + 128] = 0
    if 0 >= mem[96]:
        revert with 0, 50
    _138 = mem[mem[128] + 128]
    if not -mem[mem[128] + 156 len 4]:
        _140 = mem[64]
        mem[64] = mem[64] + 64
        mem[_140] = 1
        mem[_140 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
        _142 = mem[64]
        mem[64] = mem[64] + 64
        mem[_142] = 1
        mem[_142 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _140
        t = _135
        while idx < _132:
            if idx >= mem[96]:
                revert with 0, 50
            _264 = mem[(32 * idx) + 128]
            _265 = mem[mem[(32 * idx) + 128] + 128]
            if not -mem[mem[(32 * idx) + 128] + 156 len 4]:
                _267 = mem[64]
                mem[64] = mem[64] + 64
                mem[_267] = 1
                mem[_267 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _268 = mem[64]
                _270 = mem[s]
                t = 0
                while t < _270:
                    mem[t + _268 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_270) <= _270:
                    _439 = mem[_142]
                    s = 0
                    while s < _439:
                        mem[s + _268 + _270 + 32] = mem[s + _142 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_439) <= _439:
                        _637 = mem[_267]
                        s = 0
                        while s < _637:
                            mem[s + _268 + _270 + _439 + 32] = mem[s + _267 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_637) <= _637:
                            _821 = mem[64]
                            mem[mem[64]] = _637 + _268 + _270 + _439 - mem[64]
                            mem[64] = _637 + _268 + _270 + _439 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _821
                            t = _264
                            continue 
                        mem[_637 + _268 + _270 + _439 + 32] = 0
                        _822 = mem[64]
                        mem[mem[64]] = _637 + _268 + _270 + _439 - mem[64]
                        mem[64] = _637 + _268 + _270 + _439 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _822
                        t = _264
                        continue 
                    mem[_439 + _268 + _270 + 32] = 0
                    _638 = mem[_267]
                    s = 0
                    while s < _638:
                        mem[s + _268 + _270 + _439 + 32] = mem[s + _267 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_638) <= _638:
                        _823 = mem[64]
                        mem[mem[64]] = _638 + _268 + _270 + _439 - mem[64]
                        mem[64] = _638 + _268 + _270 + _439 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _823
                        t = _264
                        continue 
                    mem[_638 + _268 + _270 + _439 + 32] = 0
                    _824 = mem[64]
                    mem[mem[64]] = _638 + _268 + _270 + _439 - mem[64]
                    mem[64] = _638 + _268 + _270 + _439 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _824
                    t = _264
                    continue 
                mem[_270 + _268 + 32] = 0
                _440 = mem[_142]
                s = 0
                while s < _440:
                    mem[s + _268 + _270 + 32] = mem[s + _142 + 32]
                    s = s + 32
                    continue 
                if ceil32(_440) <= _440:
                    _639 = mem[_267]
                    s = 0
                    while s < _639:
                        mem[s + _268 + _270 + _440 + 32] = mem[s + _267 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_639) <= _639:
                        _825 = mem[64]
                        mem[mem[64]] = _639 + _268 + _270 + _440 - mem[64]
                        mem[64] = _639 + _268 + _270 + _440 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _825
                        t = _264
                        continue 
                    mem[_639 + _268 + _270 + _440 + 32] = 0
                    _826 = mem[64]
                    mem[mem[64]] = _639 + _268 + _270 + _440 - mem[64]
                    mem[64] = _639 + _268 + _270 + _440 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _826
                    t = _264
                    continue 
                mem[_440 + _268 + _270 + 32] = 0
                _640 = mem[_267]
                s = 0
                while s < _640:
                    mem[s + _268 + _270 + _440 + 32] = mem[s + _267 + 32]
                    s = s + 32
                    continue 
                if ceil32(_640) <= _640:
                    _827 = mem[64]
                    mem[mem[64]] = _640 + _268 + _270 + _440 - mem[64]
                    mem[64] = _640 + _268 + _270 + _440 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _827
                    t = _264
                    continue 
                mem[_640 + _268 + _270 + _440 + 32] = 0
                _828 = mem[64]
                mem[mem[64]] = _640 + _268 + _270 + _440 - mem[64]
                mem[64] = _640 + _268 + _270 + _440 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _828
                t = _264
                continue 
            u = 0
            t = mem[mem[(32 * idx) + 128] + 156 len 4]
            while t:
                if not u + 1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _438 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = uint32(_265)
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_438]:
                        revert with 0, 50
                    mem[v + _438 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _633 = mem[64]
                _635 = mem[s]
                t = 0
                while t < _635:
                    mem[t + _633 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_635) <= _635:
                    _817 = mem[_142]
                    s = 0
                    while s < _817:
                        mem[s + _633 + _635 + 32] = mem[s + _142 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_817) <= _817:
                        _1025 = mem[_438]
                        s = 0
                        while s < _1025:
                            mem[s + _633 + _635 + _817 + 32] = mem[s + _438 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_1025) <= _1025:
                            _1213 = mem[64]
                            mem[mem[64]] = _1025 + _633 + _635 + _817 - mem[64]
                            mem[64] = _1025 + _633 + _635 + _817 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _1213
                            t = _264
                            continue 
                        mem[_1025 + _633 + _635 + _817 + 32] = 0
                        _1214 = mem[64]
                        mem[mem[64]] = _1025 + _633 + _635 + _817 - mem[64]
                        mem[64] = _1025 + _633 + _635 + _817 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1214
                        t = _264
                        continue 
                    mem[_817 + _633 + _635 + 32] = 0
                    _1026 = mem[_438]
                    s = 0
                    while s < _1026:
                        mem[s + _633 + _635 + _817 + 32] = mem[s + _438 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1026) <= _1026:
                        _1215 = mem[64]
                        mem[mem[64]] = _1026 + _633 + _635 + _817 - mem[64]
                        mem[64] = _1026 + _633 + _635 + _817 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1215
                        t = _264
                        continue 
                    mem[_1026 + _633 + _635 + _817 + 32] = 0
                    _1216 = mem[64]
                    mem[mem[64]] = _1026 + _633 + _635 + _817 - mem[64]
                    mem[64] = _1026 + _633 + _635 + _817 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1216
                    t = _264
                    continue 
                mem[_635 + _633 + 32] = 0
                _818 = mem[_142]
                s = 0
                while s < _818:
                    mem[s + _633 + _635 + 32] = mem[s + _142 + 32]
                    s = s + 32
                    continue 
                if ceil32(_818) <= _818:
                    _1027 = mem[_438]
                    s = 0
                    while s < _1027:
                        mem[s + _633 + _635 + _818 + 32] = mem[s + _438 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1027) <= _1027:
                        _1217 = mem[64]
                        mem[mem[64]] = _1027 + _633 + _635 + _818 - mem[64]
                        mem[64] = _1027 + _633 + _635 + _818 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1217
                        t = _264
                        continue 
                    mem[_1027 + _633 + _635 + _818 + 32] = 0
                    _1218 = mem[64]
                    mem[mem[64]] = _1027 + _633 + _635 + _818 - mem[64]
                    mem[64] = _1027 + _633 + _635 + _818 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1218
                    t = _264
                    continue 
                mem[_818 + _633 + _635 + 32] = 0
                _1028 = mem[_438]
                s = 0
                while s < _1028:
                    mem[s + _633 + _635 + _818 + 32] = mem[s + _438 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1028) <= _1028:
                    _1219 = mem[64]
                    mem[mem[64]] = _1028 + _633 + _635 + _818 - mem[64]
                    mem[64] = _1028 + _633 + _635 + _818 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1219
                    t = _264
                    continue 
                mem[_1028 + _633 + _635 + _818 + 32] = 0
                _1220 = mem[64]
                mem[mem[64]] = _1028 + _633 + _635 + _818 - mem[64]
                mem[64] = _1028 + _633 + _635 + _818 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1220
                t = _264
                continue 
            mem[_438 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = uint32(_265)
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_438]:
                    revert with 0, 50
                mem[v + _438 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _634 = mem[64]
            _636 = mem[s]
            t = 0
            while t < _636:
                mem[t + _634 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_636) <= _636:
                _819 = mem[_142]
                s = 0
                while s < _819:
                    mem[s + _634 + _636 + 32] = mem[s + _142 + 32]
                    s = s + 32
                    continue 
                if ceil32(_819) <= _819:
                    _1029 = mem[_438]
                    idx = 0
                    while idx < _1029:
                        mem[idx + _634 + _636 + _819 + 32] = mem[idx + _438 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_1029) <= _1029:
                        _1221 = mem[64]
                        mem[mem[64]] = _1029 + _634 + _636 + _819 - mem[64]
                        mem[64] = _1029 + _634 + _636 + _819 + 32
                        if not ceil32(_819) + 1:
                            revert with 0, 17
                        s = ceil32(_819) + 1
                        s = _1221
                        t = _264
                        continue 
                    mem[_1029 + _634 + _636 + _819 + 32] = 0
                    _1222 = mem[64]
                    mem[mem[64]] = _1029 + _634 + _636 + _819 - mem[64]
                    mem[64] = _1029 + _634 + _636 + _819 + 32
                    if not ceil32(_819) + 1:
                        revert with 0, 17
                    s = ceil32(_819) + 1
                    s = _1222
                    t = _264
                    continue 
                mem[_819 + _634 + _636 + 32] = 0
                _1030 = mem[_438]
                idx = 0
                while idx < _1030:
                    mem[idx + _634 + _636 + _819 + 32] = mem[idx + _438 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1030) <= _1030:
                    _1223 = mem[64]
                    mem[mem[64]] = _1030 + _634 + _636 + _819 - mem[64]
                    mem[64] = _1030 + _634 + _636 + _819 + 32
                    if not ceil32(_819) + 1:
                        revert with 0, 17
                    s = ceil32(_819) + 1
                    s = _1223
                    t = _264
                    continue 
                mem[_1030 + _634 + _636 + _819 + 32] = 0
                _1224 = mem[64]
                mem[mem[64]] = _1030 + _634 + _636 + _819 - mem[64]
                mem[64] = _1030 + _634 + _636 + _819 + 32
                if not ceil32(_819) + 1:
                    revert with 0, 17
                s = ceil32(_819) + 1
                s = _1224
                t = _264
                continue 
            mem[_636 + _634 + 32] = 0
            _820 = mem[_142]
            s = 0
            while s < _820:
                mem[s + _634 + _636 + 32] = mem[s + _142 + 32]
                s = s + 32
                continue 
            if ceil32(_820) <= _820:
                _1031 = mem[_438]
                idx = 0
                while idx < _1031:
                    mem[idx + _634 + _636 + _820 + 32] = mem[idx + _438 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1031) <= _1031:
                    _1225 = mem[64]
                    mem[mem[64]] = _1031 + _634 + _636 + _820 - mem[64]
                    mem[64] = _1031 + _634 + _636 + _820 + 32
                    if not ceil32(_820) + 1:
                        revert with 0, 17
                    s = ceil32(_820) + 1
                    s = _1225
                    t = _264
                    continue 
                mem[_1031 + _634 + _636 + _820 + 32] = 0
                _1226 = mem[64]
                mem[mem[64]] = _1031 + _634 + _636 + _820 - mem[64]
                mem[64] = _1031 + _634 + _636 + _820 + 32
                if not ceil32(_820) + 1:
                    revert with 0, 17
                s = ceil32(_820) + 1
                s = _1226
                t = _264
                continue 
            mem[_820 + _634 + _636 + 32] = 0
            _1032 = mem[_438]
            idx = 0
            while idx < _1032:
                mem[idx + _634 + _636 + _820 + 32] = mem[idx + _438 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1032) <= _1032:
                _1227 = mem[64]
                mem[mem[64]] = _1032 + _634 + _636 + _820 - mem[64]
                mem[64] = _1032 + _634 + _636 + _820 + 32
                if not ceil32(_820) + 1:
                    revert with 0, 17
                s = ceil32(_820) + 1
                s = _1227
                t = _264
                continue 
            mem[_1032 + _634 + _636 + _820 + 32] = 0
            _1228 = mem[64]
            mem[mem[64]] = _1032 + _634 + _636 + _820 - mem[64]
            mem[64] = _1032 + _634 + _636 + _820 + 32
            if not ceil32(_820) + 1:
                revert with 0, 17
            s = ceil32(_820) + 1
            s = _1228
            t = _264
            continue 
        _263 = mem[64]
        mem[mem[64]] = 32
        _266 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_266)] = mem[s + 32 len ceil32(_266)]
        if ceil32(_266) <= _266:
            return 32, mem[mem[64] + 32 len ceil32(_266) + 32]
        mem[_266 + mem[64] + 64] = 0
        return memory
          from mem[64]
           len ceil32(_266) + _263 + -mem[64] + 64
    s = 0
    idx = mem[mem[128] + 156 len 4]
    while idx:
        if not s + 1:
            revert with 0, 17
        s = s + 1
        idx = idx / 10
        continue 
    if s > test266151307():
        revert with 0, 65
    _262 = mem[64]
    mem[mem[64]] = s
    mem[64] = mem[64] + ceil32(s) + 32
    if not s:
        t = s
        idx = uint32(_138)
        while idx:
            if t < 1:
                revert with 0, 17
            if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if idx < 10 * idx / 10:
                revert with 0, 17
            if 48 > -uint8(idx - (10 * idx / 10)) + 255:
                revert with 0, 17
            if t - 1 >= mem[_262]:
                revert with 0, 50
            mem[t + _262 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        _436 = mem[64]
        mem[64] = mem[64] + 64
        mem[_436] = 1
        mem[_436 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _262
        u = _135
        while idx < _132:
            if idx >= mem[96]:
                revert with 0, 50
            _628 = mem[(32 * idx) + 128]
            _629 = mem[mem[(32 * idx) + 128] + 128]
            if not -mem[mem[(32 * idx) + 128] + 156 len 4]:
                _642 = mem[64]
                mem[64] = mem[64] + 64
                mem[_642] = 1
                mem[_642 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _645 = mem[64]
                _647 = mem[s]
                u = 0
                while u < _647:
                    mem[u + _645 + 32] = mem[u + s + 32]
                    u = u + 32
                    continue 
                if ceil32(_647) <= _647:
                    _813 = mem[_436]
                    s = 0
                    while s < _813:
                        mem[s + _645 + _647 + 32] = mem[s + _436 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_813) <= _813:
                        _1015 = mem[_642]
                        s = 0
                        while s < _1015:
                            mem[s + _645 + _647 + _813 + 32] = mem[s + _642 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_1015) <= _1015:
                            _1197 = mem[64]
                            mem[mem[64]] = _1015 + _645 + _647 + _813 - mem[64]
                            mem[64] = _1015 + _645 + _647 + _813 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _1197
                            u = _628
                            continue 
                        mem[_1015 + _645 + _647 + _813 + 32] = 0
                        _1198 = mem[64]
                        mem[mem[64]] = _1015 + _645 + _647 + _813 - mem[64]
                        mem[64] = _1015 + _645 + _647 + _813 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1198
                        u = _628
                        continue 
                    mem[_813 + _645 + _647 + 32] = 0
                    _1016 = mem[_642]
                    s = 0
                    while s < _1016:
                        mem[s + _645 + _647 + _813 + 32] = mem[s + _642 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1016) <= _1016:
                        _1199 = mem[64]
                        mem[mem[64]] = _1016 + _645 + _647 + _813 - mem[64]
                        mem[64] = _1016 + _645 + _647 + _813 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1199
                        u = _628
                        continue 
                    mem[_1016 + _645 + _647 + _813 + 32] = 0
                    _1200 = mem[64]
                    mem[mem[64]] = _1016 + _645 + _647 + _813 - mem[64]
                    mem[64] = _1016 + _645 + _647 + _813 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1200
                    u = _628
                    continue 
                mem[_647 + _645 + 32] = 0
                _814 = mem[_436]
                s = 0
                while s < _814:
                    mem[s + _645 + _647 + 32] = mem[s + _436 + 32]
                    s = s + 32
                    continue 
                if ceil32(_814) <= _814:
                    _1017 = mem[_642]
                    s = 0
                    while s < _1017:
                        mem[s + _645 + _647 + _814 + 32] = mem[s + _642 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1017) <= _1017:
                        _1201 = mem[64]
                        mem[mem[64]] = _1017 + _645 + _647 + _814 - mem[64]
                        mem[64] = _1017 + _645 + _647 + _814 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1201
                        u = _628
                        continue 
                    mem[_1017 + _645 + _647 + _814 + 32] = 0
                    _1202 = mem[64]
                    mem[mem[64]] = _1017 + _645 + _647 + _814 - mem[64]
                    mem[64] = _1017 + _645 + _647 + _814 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1202
                    u = _628
                    continue 
                mem[_814 + _645 + _647 + 32] = 0
                _1018 = mem[_642]
                s = 0
                while s < _1018:
                    mem[s + _645 + _647 + _814 + 32] = mem[s + _642 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1018) <= _1018:
                    _1203 = mem[64]
                    mem[mem[64]] = _1018 + _645 + _647 + _814 - mem[64]
                    mem[64] = _1018 + _645 + _647 + _814 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1203
                    u = _628
                    continue 
                mem[_1018 + _645 + _647 + _814 + 32] = 0
                _1204 = mem[64]
                mem[mem[64]] = _1018 + _645 + _647 + _814 - mem[64]
                mem[64] = _1018 + _645 + _647 + _814 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1204
                u = _628
                continue 
            u = 0
            t = mem[mem[(32 * idx) + 128] + 156 len 4]
            while t:
                if not u + 1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _811 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = uint32(_629)
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_811]:
                        revert with 0, 50
                    mem[v + _811 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _1009 = mem[64]
                _1013 = mem[s]
                t = 0
                while t < _1013:
                    mem[t + _1009 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_1013) <= _1013:
                    _1189 = mem[_436]
                    s = 0
                    while s < _1189:
                        mem[s + _1009 + _1013 + 32] = mem[s + _436 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1189) <= _1189:
                        _1309 = mem[_811]
                        s = 0
                        while s < _1309:
                            mem[s + _1009 + _1013 + _1189 + 32] = mem[s + _811 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_1309) <= _1309:
                            _1389 = mem[64]
                            mem[mem[64]] = _1309 + _1009 + _1013 + _1189 - mem[64]
                            mem[64] = _1309 + _1009 + _1013 + _1189 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _1389
                            u = _628
                            continue 
                        mem[_1309 + _1009 + _1013 + _1189 + 32] = 0
                        _1390 = mem[64]
                        mem[mem[64]] = _1309 + _1009 + _1013 + _1189 - mem[64]
                        mem[64] = _1309 + _1009 + _1013 + _1189 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1390
                        u = _628
                        continue 
                    mem[_1189 + _1009 + _1013 + 32] = 0
                    _1310 = mem[_811]
                    s = 0
                    while s < _1310:
                        mem[s + _1009 + _1013 + _1189 + 32] = mem[s + _811 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1310) <= _1310:
                        _1391 = mem[64]
                        mem[mem[64]] = _1310 + _1009 + _1013 + _1189 - mem[64]
                        mem[64] = _1310 + _1009 + _1013 + _1189 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1391
                        u = _628
                        continue 
                    mem[_1310 + _1009 + _1013 + _1189 + 32] = 0
                    _1392 = mem[64]
                    mem[mem[64]] = _1310 + _1009 + _1013 + _1189 - mem[64]
                    mem[64] = _1310 + _1009 + _1013 + _1189 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1392
                    u = _628
                    continue 
                mem[_1013 + _1009 + 32] = 0
                _1190 = mem[_436]
                s = 0
                while s < _1190:
                    mem[s + _1009 + _1013 + 32] = mem[s + _436 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1190) <= _1190:
                    _1311 = mem[_811]
                    s = 0
                    while s < _1311:
                        mem[s + _1009 + _1013 + _1190 + 32] = mem[s + _811 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1311) <= _1311:
                        _1393 = mem[64]
                        mem[mem[64]] = _1311 + _1009 + _1013 + _1190 - mem[64]
                        mem[64] = _1311 + _1009 + _1013 + _1190 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1393
                        u = _628
                        continue 
                    mem[_1311 + _1009 + _1013 + _1190 + 32] = 0
                    _1394 = mem[64]
                    mem[mem[64]] = _1311 + _1009 + _1013 + _1190 - mem[64]
                    mem[64] = _1311 + _1009 + _1013 + _1190 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1394
                    u = _628
                    continue 
                mem[_1190 + _1009 + _1013 + 32] = 0
                _1312 = mem[_811]
                s = 0
                while s < _1312:
                    mem[s + _1009 + _1013 + _1190 + 32] = mem[s + _811 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1312) <= _1312:
                    _1395 = mem[64]
                    mem[mem[64]] = _1312 + _1009 + _1013 + _1190 - mem[64]
                    mem[64] = _1312 + _1009 + _1013 + _1190 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1395
                    u = _628
                    continue 
                mem[_1312 + _1009 + _1013 + _1190 + 32] = 0
                _1396 = mem[64]
                mem[mem[64]] = _1312 + _1009 + _1013 + _1190 - mem[64]
                mem[64] = _1312 + _1009 + _1013 + _1190 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1396
                u = _628
                continue 
            mem[_811 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = uint32(_629)
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_811]:
                    revert with 0, 50
                mem[v + _811 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _1010 = mem[64]
            _1014 = mem[s]
            t = 0
            while t < _1014:
                mem[t + _1010 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_1014) <= _1014:
                _1191 = mem[_436]
                s = 0
                while s < _1191:
                    mem[s + _1010 + _1014 + 32] = mem[s + _436 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1191) <= _1191:
                    _1313 = mem[_811]
                    idx = 0
                    while idx < _1313:
                        mem[idx + _1010 + _1014 + _1191 + 32] = mem[idx + _811 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_1313) <= _1313:
                        _1397 = mem[64]
                        mem[mem[64]] = _1313 + _1010 + _1014 + _1191 - mem[64]
                        mem[64] = _1313 + _1010 + _1014 + _1191 + 32
                        if not ceil32(_1191) + 1:
                            revert with 0, 17
                        s = ceil32(_1191) + 1
                        s = _1397
                        u = _628
                        continue 
                    mem[_1313 + _1010 + _1014 + _1191 + 32] = 0
                    _1398 = mem[64]
                    mem[mem[64]] = _1313 + _1010 + _1014 + _1191 - mem[64]
                    mem[64] = _1313 + _1010 + _1014 + _1191 + 32
                    if not ceil32(_1191) + 1:
                        revert with 0, 17
                    s = ceil32(_1191) + 1
                    s = _1398
                    u = _628
                    continue 
                mem[_1191 + _1010 + _1014 + 32] = 0
                _1314 = mem[_811]
                idx = 0
                while idx < _1314:
                    mem[idx + _1010 + _1014 + _1191 + 32] = mem[idx + _811 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1314) <= _1314:
                    _1399 = mem[64]
                    mem[mem[64]] = _1314 + _1010 + _1014 + _1191 - mem[64]
                    mem[64] = _1314 + _1010 + _1014 + _1191 + 32
                    if not ceil32(_1191) + 1:
                        revert with 0, 17
                    s = ceil32(_1191) + 1
                    s = _1399
                    u = _628
                    continue 
                mem[_1314 + _1010 + _1014 + _1191 + 32] = 0
                _1400 = mem[64]
                mem[mem[64]] = _1314 + _1010 + _1014 + _1191 - mem[64]
                mem[64] = _1314 + _1010 + _1014 + _1191 + 32
                if not ceil32(_1191) + 1:
                    revert with 0, 17
                s = ceil32(_1191) + 1
                s = _1400
                u = _628
                continue 
            mem[_1014 + _1010 + 32] = 0
            _1192 = mem[_436]
            s = 0
            while s < _1192:
                mem[s + _1010 + _1014 + 32] = mem[s + _436 + 32]
                s = s + 32
                continue 
            if ceil32(_1192) <= _1192:
                _1315 = mem[_811]
                idx = 0
                while idx < _1315:
                    mem[idx + _1010 + _1014 + _1192 + 32] = mem[idx + _811 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1315) <= _1315:
                    _1401 = mem[64]
                    mem[mem[64]] = _1315 + _1010 + _1014 + _1192 - mem[64]
                    mem[64] = _1315 + _1010 + _1014 + _1192 + 32
                    if not ceil32(_1192) + 1:
                        revert with 0, 17
                    s = ceil32(_1192) + 1
                    s = _1401
                    u = _628
                    continue 
                mem[_1315 + _1010 + _1014 + _1192 + 32] = 0
                _1402 = mem[64]
                mem[mem[64]] = _1315 + _1010 + _1014 + _1192 - mem[64]
                mem[64] = _1315 + _1010 + _1014 + _1192 + 32
                if not ceil32(_1192) + 1:
                    revert with 0, 17
                s = ceil32(_1192) + 1
                s = _1402
                u = _628
                continue 
            mem[_1192 + _1010 + _1014 + 32] = 0
            _1316 = mem[_811]
            idx = 0
            while idx < _1316:
                mem[idx + _1010 + _1014 + _1192 + 32] = mem[idx + _811 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1316) <= _1316:
                _1403 = mem[64]
                mem[mem[64]] = _1316 + _1010 + _1014 + _1192 - mem[64]
                mem[64] = _1316 + _1010 + _1014 + _1192 + 32
                if not ceil32(_1192) + 1:
                    revert with 0, 17
                s = ceil32(_1192) + 1
                s = _1403
                u = _628
                continue 
            mem[_1316 + _1010 + _1014 + _1192 + 32] = 0
            _1404 = mem[64]
            mem[mem[64]] = _1316 + _1010 + _1014 + _1192 - mem[64]
            mem[64] = _1316 + _1010 + _1014 + _1192 + 32
            if not ceil32(_1192) + 1:
                revert with 0, 17
            s = ceil32(_1192) + 1
            s = _1404
            u = _628
            continue 
        _627 = mem[64]
        mem[mem[64]] = 32
        _641 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_641)] = mem[s + 32 len ceil32(_641)]
        if ceil32(_641) <= _641:
            return 32, mem[mem[64] + 32 len ceil32(_641) + 32]
        mem[_641 + mem[64] + 64] = 0
        return memory
          from mem[64]
           len ceil32(_641) + _627 + -mem[64] + 64
    mem[_262 + 32 len s] = call.data[calldata.size len s]
    t = s
    idx = uint32(_138)
    while idx:
        if t < 1:
            revert with 0, 17
        if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
            revert with 0, 17
        if idx < 10 * idx / 10:
            revert with 0, 17
        if 48 > -uint8(idx - (10 * idx / 10)) + 255:
            revert with 0, 17
        if t - 1 >= mem[_262]:
            revert with 0, 50
        mem[t + _262 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
        t = t - 1
        idx = idx / 10
        continue 
    _437 = mem[64]
    mem[64] = mem[64] + 64
    mem[_437] = 1
    mem[_437 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
    idx = 1
    s = _262
    u = _135
    while idx < _132:
        if idx >= mem[96]:
            revert with 0, 50
        _631 = mem[(32 * idx) + 128]
        _632 = mem[mem[(32 * idx) + 128] + 128]
        if not -mem[mem[(32 * idx) + 128] + 156 len 4]:
            _644 = mem[64]
            mem[64] = mem[64] + 64
            mem[_644] = 1
            mem[_644 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
            _646 = mem[64]
            _648 = mem[s]
            u = 0
            while u < _648:
                mem[u + _646 + 32] = mem[u + s + 32]
                u = u + 32
                continue 
            if ceil32(_648) <= _648:
                _815 = mem[_437]
                s = 0
                while s < _815:
                    mem[s + _646 + _648 + 32] = mem[s + _437 + 32]
                    s = s + 32
                    continue 
                if ceil32(_815) <= _815:
                    _1021 = mem[_644]
                    s = 0
                    while s < _1021:
                        mem[s + _646 + _648 + _815 + 32] = mem[s + _644 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1021) <= _1021:
                        _1205 = mem[64]
                        mem[mem[64]] = _1021 + _646 + _648 + _815 - mem[64]
                        mem[64] = _1021 + _646 + _648 + _815 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1205
                        u = _631
                        continue 
                    mem[_1021 + _646 + _648 + _815 + 32] = 0
                    _1206 = mem[64]
                    mem[mem[64]] = _1021 + _646 + _648 + _815 - mem[64]
                    mem[64] = _1021 + _646 + _648 + _815 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1206
                    u = _631
                    continue 
                mem[_815 + _646 + _648 + 32] = 0
                _1022 = mem[_644]
                s = 0
                while s < _1022:
                    mem[s + _646 + _648 + _815 + 32] = mem[s + _644 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1022) <= _1022:
                    _1207 = mem[64]
                    mem[mem[64]] = _1022 + _646 + _648 + _815 - mem[64]
                    mem[64] = _1022 + _646 + _648 + _815 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1207
                    u = _631
                    continue 
                mem[_1022 + _646 + _648 + _815 + 32] = 0
                _1208 = mem[64]
                mem[mem[64]] = _1022 + _646 + _648 + _815 - mem[64]
                mem[64] = _1022 + _646 + _648 + _815 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1208
                u = _631
                continue 
            mem[_648 + _646 + 32] = 0
            _816 = mem[_437]
            s = 0
            while s < _816:
                mem[s + _646 + _648 + 32] = mem[s + _437 + 32]
                s = s + 32
                continue 
            if ceil32(_816) <= _816:
                _1023 = mem[_644]
                s = 0
                while s < _1023:
                    mem[s + _646 + _648 + _816 + 32] = mem[s + _644 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1023) <= _1023:
                    _1209 = mem[64]
                    mem[mem[64]] = _1023 + _646 + _648 + _816 - mem[64]
                    mem[64] = _1023 + _646 + _648 + _816 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1209
                    u = _631
                    continue 
                mem[_1023 + _646 + _648 + _816 + 32] = 0
                _1210 = mem[64]
                mem[mem[64]] = _1023 + _646 + _648 + _816 - mem[64]
                mem[64] = _1023 + _646 + _648 + _816 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1210
                u = _631
                continue 
            mem[_816 + _646 + _648 + 32] = 0
            _1024 = mem[_644]
            s = 0
            while s < _1024:
                mem[s + _646 + _648 + _816 + 32] = mem[s + _644 + 32]
                s = s + 32
                continue 
            if ceil32(_1024) <= _1024:
                _1211 = mem[64]
                mem[mem[64]] = _1024 + _646 + _648 + _816 - mem[64]
                mem[64] = _1024 + _646 + _648 + _816 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1211
                u = _631
                continue 
            mem[_1024 + _646 + _648 + _816 + 32] = 0
            _1212 = mem[64]
            mem[mem[64]] = _1024 + _646 + _648 + _816 - mem[64]
            mem[64] = _1024 + _646 + _648 + _816 + 32
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            s = _1212
            u = _631
            continue 
        u = 0
        t = mem[mem[(32 * idx) + 128] + 156 len 4]
        while t:
            if not u + 1:
                revert with 0, 17
            u = u + 1
            t = t / 10
            continue 
        if u > test266151307():
            revert with 0, 65
        _812 = mem[64]
        mem[mem[64]] = u
        mem[64] = mem[64] + ceil32(u) + 32
        if not u:
            v = u
            t = uint32(_632)
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_812]:
                    revert with 0, 50
                mem[v + _812 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _1011 = mem[64]
            _1019 = mem[s]
            t = 0
            while t < _1019:
                mem[t + _1011 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_1019) <= _1019:
                _1193 = mem[_437]
                s = 0
                while s < _1193:
                    mem[s + _1011 + _1019 + 32] = mem[s + _437 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1193) <= _1193:
                    _1317 = mem[_812]
                    s = 0
                    while s < _1317:
                        mem[s + _1011 + _1019 + _1193 + 32] = mem[s + _812 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1317) <= _1317:
                        _1405 = mem[64]
                        mem[mem[64]] = _1317 + _1011 + _1019 + _1193 - mem[64]
                        mem[64] = _1317 + _1011 + _1019 + _1193 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1405
                        u = _631
                        continue 
                    mem[_1317 + _1011 + _1019 + _1193 + 32] = 0
                    _1406 = mem[64]
                    mem[mem[64]] = _1317 + _1011 + _1019 + _1193 - mem[64]
                    mem[64] = _1317 + _1011 + _1019 + _1193 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1406
                    u = _631
                    continue 
                mem[_1193 + _1011 + _1019 + 32] = 0
                _1318 = mem[_812]
                s = 0
                while s < _1318:
                    mem[s + _1011 + _1019 + _1193 + 32] = mem[s + _812 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1318) <= _1318:
                    _1407 = mem[64]
                    mem[mem[64]] = _1318 + _1011 + _1019 + _1193 - mem[64]
                    mem[64] = _1318 + _1011 + _1019 + _1193 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1407
                    u = _631
                    continue 
                mem[_1318 + _1011 + _1019 + _1193 + 32] = 0
                _1408 = mem[64]
                mem[mem[64]] = _1318 + _1011 + _1019 + _1193 - mem[64]
                mem[64] = _1318 + _1011 + _1019 + _1193 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1408
                u = _631
                continue 
            mem[_1019 + _1011 + 32] = 0
            _1194 = mem[_437]
            s = 0
            while s < _1194:
                mem[s + _1011 + _1019 + 32] = mem[s + _437 + 32]
                s = s + 32
                continue 
            if ceil32(_1194) <= _1194:
                _1319 = mem[_812]
                s = 0
                while s < _1319:
                    mem[s + _1011 + _1019 + _1194 + 32] = mem[s + _812 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1319) <= _1319:
                    _1409 = mem[64]
                    mem[mem[64]] = _1319 + _1011 + _1019 + _1194 - mem[64]
                    mem[64] = _1319 + _1011 + _1019 + _1194 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1409
                    u = _631
                    continue 
                mem[_1319 + _1011 + _1019 + _1194 + 32] = 0
                _1410 = mem[64]
                mem[mem[64]] = _1319 + _1011 + _1019 + _1194 - mem[64]
                mem[64] = _1319 + _1011 + _1019 + _1194 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1410
                u = _631
                continue 
            mem[_1194 + _1011 + _1019 + 32] = 0
            _1320 = mem[_812]
            s = 0
            while s < _1320:
                mem[s + _1011 + _1019 + _1194 + 32] = mem[s + _812 + 32]
                s = s + 32
                continue 
            if ceil32(_1320) <= _1320:
                _1411 = mem[64]
                mem[mem[64]] = _1320 + _1011 + _1019 + _1194 - mem[64]
                mem[64] = _1320 + _1011 + _1019 + _1194 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1411
                u = _631
                continue 
            mem[_1320 + _1011 + _1019 + _1194 + 32] = 0
            _1412 = mem[64]
            mem[mem[64]] = _1320 + _1011 + _1019 + _1194 - mem[64]
            mem[64] = _1320 + _1011 + _1019 + _1194 + 32
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            s = _1412
            u = _631
            continue 
        mem[_812 + 32 len u] = call.data[calldata.size len u]
        v = u
        t = uint32(_632)
        while t:
            if v < 1:
                revert with 0, 17
            if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if t < 10 * t / 10:
                revert with 0, 17
            if 48 > -uint8(t - (10 * t / 10)) + 255:
                revert with 0, 17
            if v - 1 >= mem[_812]:
                revert with 0, 50
            mem[v + _812 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
            v = v - 1
            t = t / 10
            continue 
        _1012 = mem[64]
        _1020 = mem[s]
        t = 0
        while t < _1020:
            mem[t + _1012 + 32] = mem[t + s + 32]
            t = t + 32
            continue 
        if ceil32(_1020) <= _1020:
            _1195 = mem[_437]
            s = 0
            while s < _1195:
                mem[s + _1012 + _1020 + 32] = mem[s + _437 + 32]
                s = s + 32
                continue 
            if ceil32(_1195) <= _1195:
                _1321 = mem[_812]
                idx = 0
                while idx < _1321:
                    mem[idx + _1012 + _1020 + _1195 + 32] = mem[idx + _812 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1321) <= _1321:
                    _1413 = mem[64]
                    mem[mem[64]] = _1321 + _1012 + _1020 + _1195 - mem[64]
                    mem[64] = _1321 + _1012 + _1020 + _1195 + 32
                    if not ceil32(_1195) + 1:
                        revert with 0, 17
                    s = ceil32(_1195) + 1
                    s = _1413
                    u = _631
                    continue 
                mem[_1321 + _1012 + _1020 + _1195 + 32] = 0
                _1414 = mem[64]
                mem[mem[64]] = _1321 + _1012 + _1020 + _1195 - mem[64]
                mem[64] = _1321 + _1012 + _1020 + _1195 + 32
                if not ceil32(_1195) + 1:
                    revert with 0, 17
                s = ceil32(_1195) + 1
                s = _1414
                u = _631
                continue 
            mem[_1195 + _1012 + _1020 + 32] = 0
            _1322 = mem[_812]
            idx = 0
            while idx < _1322:
                mem[idx + _1012 + _1020 + _1195 + 32] = mem[idx + _812 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1322) <= _1322:
                _1415 = mem[64]
                mem[mem[64]] = _1322 + _1012 + _1020 + _1195 - mem[64]
                mem[64] = _1322 + _1012 + _1020 + _1195 + 32
                if not ceil32(_1195) + 1:
                    revert with 0, 17
                s = ceil32(_1195) + 1
                s = _1415
                u = _631
                continue 
            mem[_1322 + _1012 + _1020 + _1195 + 32] = 0
            _1416 = mem[64]
            mem[mem[64]] = _1322 + _1012 + _1020 + _1195 - mem[64]
            mem[64] = _1322 + _1012 + _1020 + _1195 + 32
            if not ceil32(_1195) + 1:
                revert with 0, 17
            s = ceil32(_1195) + 1
            s = _1416
            u = _631
            continue 
        mem[_1020 + _1012 + 32] = 0
        _1196 = mem[_437]
        s = 0
        while s < _1196:
            mem[s + _1012 + _1020 + 32] = mem[s + _437 + 32]
            s = s + 32
            continue 
        if ceil32(_1196) <= _1196:
            _1323 = mem[_812]
            idx = 0
            while idx < _1323:
                mem[idx + _1012 + _1020 + _1196 + 32] = mem[idx + _812 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1323) <= _1323:
                _1417 = mem[64]
                mem[mem[64]] = _1323 + _1012 + _1020 + _1196 - mem[64]
                mem[64] = _1323 + _1012 + _1020 + _1196 + 32
                if not ceil32(_1196) + 1:
                    revert with 0, 17
                s = ceil32(_1196) + 1
                s = _1417
                u = _631
                continue 
            mem[_1323 + _1012 + _1020 + _1196 + 32] = 0
            _1418 = mem[64]
            mem[mem[64]] = _1323 + _1012 + _1020 + _1196 - mem[64]
            mem[64] = _1323 + _1012 + _1020 + _1196 + 32
            if not ceil32(_1196) + 1:
                revert with 0, 17
            s = ceil32(_1196) + 1
            s = _1418
            u = _631
            continue 
        mem[_1196 + _1012 + _1020 + 32] = 0
        _1324 = mem[_812]
        idx = 0
        while idx < _1324:
            mem[idx + _1012 + _1020 + _1196 + 32] = mem[idx + _812 + 32]
            idx = idx + 32
            continue 
        if ceil32(_1324) <= _1324:
            _1419 = mem[64]
            mem[mem[64]] = _1324 + _1012 + _1020 + _1196 - mem[64]
            mem[64] = _1324 + _1012 + _1020 + _1196 + 32
            if not ceil32(_1196) + 1:
                revert with 0, 17
            s = ceil32(_1196) + 1
            s = _1419
            u = _631
            continue 
        mem[_1324 + _1012 + _1020 + _1196 + 32] = 0
        _1420 = mem[64]
        mem[mem[64]] = _1324 + _1012 + _1020 + _1196 - mem[64]
        mem[64] = _1324 + _1012 + _1020 + _1196 + 32
        if not ceil32(_1196) + 1:
            revert with 0, 17
        s = ceil32(_1196) + 1
        s = _1420
        u = _631
        continue 
    _630 = mem[64]
    mem[mem[64]] = 32
    _643 = mem[s]
    mem[mem[64] + 32] = mem[s]
    mem[mem[64] + 64 len ceil32(_643)] = mem[s + 32 len ceil32(_643)]
    if ceil32(_643) <= _643:
        return 32, mem[mem[64] + 32 len ceil32(_643) + 32]
    mem[_643 + mem[64] + 64] = 0
    return memory
      from mem[64]
       len ceil32(_643) + _630 + -mem[64] + 64
}

function sub_afed2bc4(?) payable {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    mem[0] = address(arg1)
    mem[32] = 10
    mem[64] = (32 * sub_2c534595[address(arg1)].field_0) + 128
    mem[96] = sub_2c534595[address(arg1)].field_0
    s = 128
    idx = 0
    while idx < sub_2c534595[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 10)
        _134 = mem[64]
        mem[64] = mem[64] + 160
        if sub_2c534595[address(arg1)][idx].field_0:
            if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                revert with 0, 34
            _139 = mem[64]
            mem[64] = mem[64] + ceil32(uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) + 32
            mem[_139] = uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5
            if sub_2c534595[address(arg1)][idx].field_0:
                if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                    revert with 0, 34
                if Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                    if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                        mem[_139 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                    else:
                        mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                        mem[_139 + 32] = sub_2c534595[address(arg1)][idx].field_0
                        t = _139 + 32
                        u = sha3(mem[0])
                        while _139 + (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                mem[_134] = _139
                mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _134
                s = s + 32
                idx = idx + 1
                continue 
            if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                revert with 0, 34
            if not sub_2c534595[address(arg1)][idx].field_1:
                mem[_134] = _139
                mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _134
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                mem[_139 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                mem[_134] = _139
                mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _134
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
            mem[_139 + 32] = sub_2c534595[address(arg1)][idx].field_0
            t = _139 + 32
            u = sha3(mem[0])
            while _139 + sub_2c534595[address(arg1)][u].field_1 > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_134] = _139
            mem[_134 + 32] = sub_2c534595[address(arg1)][u].field_256
            mem[_134 + 64] = sub_2c534595[address(arg1)][u].field_512
            mem[_134 + 96] = sub_2c534595[address(arg1)][u].field_768
            mem[_134 + 128] = sub_2c534595[address(arg1)][u].field_1024
            mem[t] = _134
            t = t + 32
            u = u + 1
            continue 
        if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
            revert with 0, 34
        _141 = mem[64]
        mem[64] = mem[64] + ceil32(sub_2c534595[address(arg1)][idx].field_1) + 32
        mem[_141] = sub_2c534595[address(arg1)][idx].field_1
        if sub_2c534595[address(arg1)][idx].field_0:
            if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                revert with 0, 34
            if not Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                mem[_134] = _141
                mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _134
                s = s + 32
                idx = idx + 1
                continue 
            if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                mem[_141 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                mem[_134] = _141
                mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
                mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
                mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
                mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                mem[s] = _134
                s = s + 32
                idx = idx + 1
                continue 
            mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
            mem[_141 + 32] = sub_2c534595[address(arg1)][idx].field_0
            t = _141 + 32
            u = sha3(mem[0])
            while _141 + (uint255(sub_2c534595[address(arg1)][u].field_0) * 0.5) > t:
                mem[t + 32] = uint256(stor1[u])
                t = t + 32
                u = u + 1
                continue 
            mem[_134] = _141
            mem[_134 + 32] = sub_2c534595[address(arg1)][u].field_256
            mem[_134 + 64] = sub_2c534595[address(arg1)][u].field_512
            mem[_134 + 96] = sub_2c534595[address(arg1)][u].field_768
            mem[_134 + 128] = sub_2c534595[address(arg1)][u].field_1024
            mem[t] = _134
            t = t + 32
            u = u + 1
            continue 
        if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
            revert with 0, 34
        if sub_2c534595[address(arg1)][idx].field_1:
            if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                mem[_141 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
            else:
                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                mem[_141 + 32] = sub_2c534595[address(arg1)][idx].field_0
                t = _141 + 32
                u = sha3(mem[0])
                while _141 + sub_2c534595[address(arg1)][idx].field_1 > t:
                    mem[t + 32] = uint256(stor1[u])
                    t = t + 32
                    u = u + 1
                    continue 
        mem[_134] = _141
        mem[_134 + 32] = sub_2c534595[address(arg1)][idx].field_256
        mem[_134 + 64] = sub_2c534595[address(arg1)][idx].field_512
        mem[_134 + 96] = sub_2c534595[address(arg1)][idx].field_768
        mem[_134 + 128] = sub_2c534595[address(arg1)][idx].field_1024
        mem[s] = _134
        s = s + 32
        idx = idx + 1
        continue 
    _132 = mem[96]
    _135 = mem[64]
    mem[64] = mem[64] + 160
    mem[_135] = 96
    mem[_135 + 32] = 0
    mem[_135 + 64] = 0
    mem[_135 + 96] = 0
    mem[_135 + 128] = 0
    if 0 >= mem[96]:
        revert with 0, 50
    _138 = mem[mem[128] + 128]
    if not -mem[mem[128] + 156 len 4]:
        _140 = mem[64]
        mem[64] = mem[64] + 64
        mem[_140] = 1
        mem[_140 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
        _142 = mem[64]
        mem[64] = mem[64] + 64
        mem[_142] = 1
        mem[_142 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _140
        t = _135
        while idx < _132:
            if idx >= mem[96]:
                revert with 0, 50
            _264 = mem[(32 * idx) + 128]
            _265 = mem[mem[(32 * idx) + 128] + 128]
            if not -mem[mem[(32 * idx) + 128] + 156 len 4]:
                _267 = mem[64]
                mem[64] = mem[64] + 64
                mem[_267] = 1
                mem[_267 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _268 = mem[64]
                _270 = mem[s]
                t = 0
                while t < _270:
                    mem[t + _268 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_270) <= _270:
                    _439 = mem[_142]
                    s = 0
                    while s < _439:
                        mem[s + _268 + _270 + 32] = mem[s + _142 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_439) <= _439:
                        _637 = mem[_267]
                        s = 0
                        while s < _637:
                            mem[s + _268 + _270 + _439 + 32] = mem[s + _267 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_637) <= _637:
                            _821 = mem[64]
                            mem[mem[64]] = _637 + _268 + _270 + _439 - mem[64]
                            mem[64] = _637 + _268 + _270 + _439 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _821
                            t = _264
                            continue 
                        mem[_637 + _268 + _270 + _439 + 32] = 0
                        _822 = mem[64]
                        mem[mem[64]] = _637 + _268 + _270 + _439 - mem[64]
                        mem[64] = _637 + _268 + _270 + _439 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _822
                        t = _264
                        continue 
                    mem[_439 + _268 + _270 + 32] = 0
                    _638 = mem[_267]
                    s = 0
                    while s < _638:
                        mem[s + _268 + _270 + _439 + 32] = mem[s + _267 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_638) <= _638:
                        _823 = mem[64]
                        mem[mem[64]] = _638 + _268 + _270 + _439 - mem[64]
                        mem[64] = _638 + _268 + _270 + _439 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _823
                        t = _264
                        continue 
                    mem[_638 + _268 + _270 + _439 + 32] = 0
                    _824 = mem[64]
                    mem[mem[64]] = _638 + _268 + _270 + _439 - mem[64]
                    mem[64] = _638 + _268 + _270 + _439 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _824
                    t = _264
                    continue 
                mem[_270 + _268 + 32] = 0
                _440 = mem[_142]
                s = 0
                while s < _440:
                    mem[s + _268 + _270 + 32] = mem[s + _142 + 32]
                    s = s + 32
                    continue 
                if ceil32(_440) <= _440:
                    _639 = mem[_267]
                    s = 0
                    while s < _639:
                        mem[s + _268 + _270 + _440 + 32] = mem[s + _267 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_639) <= _639:
                        _825 = mem[64]
                        mem[mem[64]] = _639 + _268 + _270 + _440 - mem[64]
                        mem[64] = _639 + _268 + _270 + _440 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _825
                        t = _264
                        continue 
                    mem[_639 + _268 + _270 + _440 + 32] = 0
                    _826 = mem[64]
                    mem[mem[64]] = _639 + _268 + _270 + _440 - mem[64]
                    mem[64] = _639 + _268 + _270 + _440 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _826
                    t = _264
                    continue 
                mem[_440 + _268 + _270 + 32] = 0
                _640 = mem[_267]
                s = 0
                while s < _640:
                    mem[s + _268 + _270 + _440 + 32] = mem[s + _267 + 32]
                    s = s + 32
                    continue 
                if ceil32(_640) <= _640:
                    _827 = mem[64]
                    mem[mem[64]] = _640 + _268 + _270 + _440 - mem[64]
                    mem[64] = _640 + _268 + _270 + _440 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _827
                    t = _264
                    continue 
                mem[_640 + _268 + _270 + _440 + 32] = 0
                _828 = mem[64]
                mem[mem[64]] = _640 + _268 + _270 + _440 - mem[64]
                mem[64] = _640 + _268 + _270 + _440 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _828
                t = _264
                continue 
            u = 0
            t = mem[mem[(32 * idx) + 128] + 156 len 4]
            while t:
                if not u + 1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _438 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = uint32(_265)
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_438]:
                        revert with 0, 50
                    mem[v + _438 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _633 = mem[64]
                _635 = mem[s]
                t = 0
                while t < _635:
                    mem[t + _633 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_635) <= _635:
                    _817 = mem[_142]
                    s = 0
                    while s < _817:
                        mem[s + _633 + _635 + 32] = mem[s + _142 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_817) <= _817:
                        _1025 = mem[_438]
                        s = 0
                        while s < _1025:
                            mem[s + _633 + _635 + _817 + 32] = mem[s + _438 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_1025) <= _1025:
                            _1213 = mem[64]
                            mem[mem[64]] = _1025 + _633 + _635 + _817 - mem[64]
                            mem[64] = _1025 + _633 + _635 + _817 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _1213
                            t = _264
                            continue 
                        mem[_1025 + _633 + _635 + _817 + 32] = 0
                        _1214 = mem[64]
                        mem[mem[64]] = _1025 + _633 + _635 + _817 - mem[64]
                        mem[64] = _1025 + _633 + _635 + _817 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1214
                        t = _264
                        continue 
                    mem[_817 + _633 + _635 + 32] = 0
                    _1026 = mem[_438]
                    s = 0
                    while s < _1026:
                        mem[s + _633 + _635 + _817 + 32] = mem[s + _438 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1026) <= _1026:
                        _1215 = mem[64]
                        mem[mem[64]] = _1026 + _633 + _635 + _817 - mem[64]
                        mem[64] = _1026 + _633 + _635 + _817 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1215
                        t = _264
                        continue 
                    mem[_1026 + _633 + _635 + _817 + 32] = 0
                    _1216 = mem[64]
                    mem[mem[64]] = _1026 + _633 + _635 + _817 - mem[64]
                    mem[64] = _1026 + _633 + _635 + _817 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1216
                    t = _264
                    continue 
                mem[_635 + _633 + 32] = 0
                _818 = mem[_142]
                s = 0
                while s < _818:
                    mem[s + _633 + _635 + 32] = mem[s + _142 + 32]
                    s = s + 32
                    continue 
                if ceil32(_818) <= _818:
                    _1027 = mem[_438]
                    s = 0
                    while s < _1027:
                        mem[s + _633 + _635 + _818 + 32] = mem[s + _438 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1027) <= _1027:
                        _1217 = mem[64]
                        mem[mem[64]] = _1027 + _633 + _635 + _818 - mem[64]
                        mem[64] = _1027 + _633 + _635 + _818 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1217
                        t = _264
                        continue 
                    mem[_1027 + _633 + _635 + _818 + 32] = 0
                    _1218 = mem[64]
                    mem[mem[64]] = _1027 + _633 + _635 + _818 - mem[64]
                    mem[64] = _1027 + _633 + _635 + _818 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1218
                    t = _264
                    continue 
                mem[_818 + _633 + _635 + 32] = 0
                _1028 = mem[_438]
                s = 0
                while s < _1028:
                    mem[s + _633 + _635 + _818 + 32] = mem[s + _438 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1028) <= _1028:
                    _1219 = mem[64]
                    mem[mem[64]] = _1028 + _633 + _635 + _818 - mem[64]
                    mem[64] = _1028 + _633 + _635 + _818 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1219
                    t = _264
                    continue 
                mem[_1028 + _633 + _635 + _818 + 32] = 0
                _1220 = mem[64]
                mem[mem[64]] = _1028 + _633 + _635 + _818 - mem[64]
                mem[64] = _1028 + _633 + _635 + _818 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1220
                t = _264
                continue 
            mem[_438 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = uint32(_265)
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_438]:
                    revert with 0, 50
                mem[v + _438 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _634 = mem[64]
            _636 = mem[s]
            t = 0
            while t < _636:
                mem[t + _634 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_636) <= _636:
                _819 = mem[_142]
                s = 0
                while s < _819:
                    mem[s + _634 + _636 + 32] = mem[s + _142 + 32]
                    s = s + 32
                    continue 
                if ceil32(_819) <= _819:
                    _1029 = mem[_438]
                    idx = 0
                    while idx < _1029:
                        mem[idx + _634 + _636 + _819 + 32] = mem[idx + _438 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_1029) <= _1029:
                        _1221 = mem[64]
                        mem[mem[64]] = _1029 + _634 + _636 + _819 - mem[64]
                        mem[64] = _1029 + _634 + _636 + _819 + 32
                        if not ceil32(_819) + 1:
                            revert with 0, 17
                        s = ceil32(_819) + 1
                        s = _1221
                        t = _264
                        continue 
                    mem[_1029 + _634 + _636 + _819 + 32] = 0
                    _1222 = mem[64]
                    mem[mem[64]] = _1029 + _634 + _636 + _819 - mem[64]
                    mem[64] = _1029 + _634 + _636 + _819 + 32
                    if not ceil32(_819) + 1:
                        revert with 0, 17
                    s = ceil32(_819) + 1
                    s = _1222
                    t = _264
                    continue 
                mem[_819 + _634 + _636 + 32] = 0
                _1030 = mem[_438]
                idx = 0
                while idx < _1030:
                    mem[idx + _634 + _636 + _819 + 32] = mem[idx + _438 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1030) <= _1030:
                    _1223 = mem[64]
                    mem[mem[64]] = _1030 + _634 + _636 + _819 - mem[64]
                    mem[64] = _1030 + _634 + _636 + _819 + 32
                    if not ceil32(_819) + 1:
                        revert with 0, 17
                    s = ceil32(_819) + 1
                    s = _1223
                    t = _264
                    continue 
                mem[_1030 + _634 + _636 + _819 + 32] = 0
                _1224 = mem[64]
                mem[mem[64]] = _1030 + _634 + _636 + _819 - mem[64]
                mem[64] = _1030 + _634 + _636 + _819 + 32
                if not ceil32(_819) + 1:
                    revert with 0, 17
                s = ceil32(_819) + 1
                s = _1224
                t = _264
                continue 
            mem[_636 + _634 + 32] = 0
            _820 = mem[_142]
            s = 0
            while s < _820:
                mem[s + _634 + _636 + 32] = mem[s + _142 + 32]
                s = s + 32
                continue 
            if ceil32(_820) <= _820:
                _1031 = mem[_438]
                idx = 0
                while idx < _1031:
                    mem[idx + _634 + _636 + _820 + 32] = mem[idx + _438 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1031) <= _1031:
                    _1225 = mem[64]
                    mem[mem[64]] = _1031 + _634 + _636 + _820 - mem[64]
                    mem[64] = _1031 + _634 + _636 + _820 + 32
                    if not ceil32(_820) + 1:
                        revert with 0, 17
                    s = ceil32(_820) + 1
                    s = _1225
                    t = _264
                    continue 
                mem[_1031 + _634 + _636 + _820 + 32] = 0
                _1226 = mem[64]
                mem[mem[64]] = _1031 + _634 + _636 + _820 - mem[64]
                mem[64] = _1031 + _634 + _636 + _820 + 32
                if not ceil32(_820) + 1:
                    revert with 0, 17
                s = ceil32(_820) + 1
                s = _1226
                t = _264
                continue 
            mem[_820 + _634 + _636 + 32] = 0
            _1032 = mem[_438]
            idx = 0
            while idx < _1032:
                mem[idx + _634 + _636 + _820 + 32] = mem[idx + _438 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1032) <= _1032:
                _1227 = mem[64]
                mem[mem[64]] = _1032 + _634 + _636 + _820 - mem[64]
                mem[64] = _1032 + _634 + _636 + _820 + 32
                if not ceil32(_820) + 1:
                    revert with 0, 17
                s = ceil32(_820) + 1
                s = _1227
                t = _264
                continue 
            mem[_1032 + _634 + _636 + _820 + 32] = 0
            _1228 = mem[64]
            mem[mem[64]] = _1032 + _634 + _636 + _820 - mem[64]
            mem[64] = _1032 + _634 + _636 + _820 + 32
            if not ceil32(_820) + 1:
                revert with 0, 17
            s = ceil32(_820) + 1
            s = _1228
            t = _264
            continue 
        _263 = mem[64]
        mem[mem[64]] = 32
        _266 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_266)] = mem[s + 32 len ceil32(_266)]
        if ceil32(_266) <= _266:
            return 32, mem[mem[64] + 32 len ceil32(_266) + 32]
        mem[_266 + mem[64] + 64] = 0
        return memory
          from mem[64]
           len ceil32(_266) + _263 + -mem[64] + 64
    s = 0
    idx = mem[mem[128] + 156 len 4]
    while idx:
        if not s + 1:
            revert with 0, 17
        s = s + 1
        idx = idx / 10
        continue 
    if s > test266151307():
        revert with 0, 65
    _262 = mem[64]
    mem[mem[64]] = s
    mem[64] = mem[64] + ceil32(s) + 32
    if not s:
        t = s
        idx = uint32(_138)
        while idx:
            if t < 1:
                revert with 0, 17
            if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if idx < 10 * idx / 10:
                revert with 0, 17
            if 48 > -uint8(idx - (10 * idx / 10)) + 255:
                revert with 0, 17
            if t - 1 >= mem[_262]:
                revert with 0, 50
            mem[t + _262 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        _436 = mem[64]
        mem[64] = mem[64] + 64
        mem[_436] = 1
        mem[_436 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
        idx = 1
        s = _262
        u = _135
        while idx < _132:
            if idx >= mem[96]:
                revert with 0, 50
            _628 = mem[(32 * idx) + 128]
            _629 = mem[mem[(32 * idx) + 128] + 128]
            if not -mem[mem[(32 * idx) + 128] + 156 len 4]:
                _642 = mem[64]
                mem[64] = mem[64] + 64
                mem[_642] = 1
                mem[_642 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
                _645 = mem[64]
                _647 = mem[s]
                u = 0
                while u < _647:
                    mem[u + _645 + 32] = mem[u + s + 32]
                    u = u + 32
                    continue 
                if ceil32(_647) <= _647:
                    _813 = mem[_436]
                    s = 0
                    while s < _813:
                        mem[s + _645 + _647 + 32] = mem[s + _436 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_813) <= _813:
                        _1015 = mem[_642]
                        s = 0
                        while s < _1015:
                            mem[s + _645 + _647 + _813 + 32] = mem[s + _642 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_1015) <= _1015:
                            _1197 = mem[64]
                            mem[mem[64]] = _1015 + _645 + _647 + _813 - mem[64]
                            mem[64] = _1015 + _645 + _647 + _813 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _1197
                            u = _628
                            continue 
                        mem[_1015 + _645 + _647 + _813 + 32] = 0
                        _1198 = mem[64]
                        mem[mem[64]] = _1015 + _645 + _647 + _813 - mem[64]
                        mem[64] = _1015 + _645 + _647 + _813 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1198
                        u = _628
                        continue 
                    mem[_813 + _645 + _647 + 32] = 0
                    _1016 = mem[_642]
                    s = 0
                    while s < _1016:
                        mem[s + _645 + _647 + _813 + 32] = mem[s + _642 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1016) <= _1016:
                        _1199 = mem[64]
                        mem[mem[64]] = _1016 + _645 + _647 + _813 - mem[64]
                        mem[64] = _1016 + _645 + _647 + _813 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1199
                        u = _628
                        continue 
                    mem[_1016 + _645 + _647 + _813 + 32] = 0
                    _1200 = mem[64]
                    mem[mem[64]] = _1016 + _645 + _647 + _813 - mem[64]
                    mem[64] = _1016 + _645 + _647 + _813 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1200
                    u = _628
                    continue 
                mem[_647 + _645 + 32] = 0
                _814 = mem[_436]
                s = 0
                while s < _814:
                    mem[s + _645 + _647 + 32] = mem[s + _436 + 32]
                    s = s + 32
                    continue 
                if ceil32(_814) <= _814:
                    _1017 = mem[_642]
                    s = 0
                    while s < _1017:
                        mem[s + _645 + _647 + _814 + 32] = mem[s + _642 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1017) <= _1017:
                        _1201 = mem[64]
                        mem[mem[64]] = _1017 + _645 + _647 + _814 - mem[64]
                        mem[64] = _1017 + _645 + _647 + _814 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1201
                        u = _628
                        continue 
                    mem[_1017 + _645 + _647 + _814 + 32] = 0
                    _1202 = mem[64]
                    mem[mem[64]] = _1017 + _645 + _647 + _814 - mem[64]
                    mem[64] = _1017 + _645 + _647 + _814 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1202
                    u = _628
                    continue 
                mem[_814 + _645 + _647 + 32] = 0
                _1018 = mem[_642]
                s = 0
                while s < _1018:
                    mem[s + _645 + _647 + _814 + 32] = mem[s + _642 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1018) <= _1018:
                    _1203 = mem[64]
                    mem[mem[64]] = _1018 + _645 + _647 + _814 - mem[64]
                    mem[64] = _1018 + _645 + _647 + _814 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1203
                    u = _628
                    continue 
                mem[_1018 + _645 + _647 + _814 + 32] = 0
                _1204 = mem[64]
                mem[mem[64]] = _1018 + _645 + _647 + _814 - mem[64]
                mem[64] = _1018 + _645 + _647 + _814 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1204
                u = _628
                continue 
            u = 0
            t = mem[mem[(32 * idx) + 128] + 156 len 4]
            while t:
                if not u + 1:
                    revert with 0, 17
                u = u + 1
                t = t / 10
                continue 
            if u > test266151307():
                revert with 0, 65
            _811 = mem[64]
            mem[mem[64]] = u
            mem[64] = mem[64] + ceil32(u) + 32
            if not u:
                v = u
                t = uint32(_629)
                while t:
                    if v < 1:
                        revert with 0, 17
                    if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                        revert with 0, 17
                    if t < 10 * t / 10:
                        revert with 0, 17
                    if 48 > -uint8(t - (10 * t / 10)) + 255:
                        revert with 0, 17
                    if v - 1 >= mem[_811]:
                        revert with 0, 50
                    mem[v + _811 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                    v = v - 1
                    t = t / 10
                    continue 
                _1009 = mem[64]
                _1013 = mem[s]
                t = 0
                while t < _1013:
                    mem[t + _1009 + 32] = mem[t + s + 32]
                    t = t + 32
                    continue 
                if ceil32(_1013) <= _1013:
                    _1189 = mem[_436]
                    s = 0
                    while s < _1189:
                        mem[s + _1009 + _1013 + 32] = mem[s + _436 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1189) <= _1189:
                        _1309 = mem[_811]
                        s = 0
                        while s < _1309:
                            mem[s + _1009 + _1013 + _1189 + 32] = mem[s + _811 + 32]
                            s = s + 32
                            continue 
                        if ceil32(_1309) <= _1309:
                            _1389 = mem[64]
                            mem[mem[64]] = _1309 + _1009 + _1013 + _1189 - mem[64]
                            mem[64] = _1309 + _1009 + _1013 + _1189 + 32
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = _1389
                            u = _628
                            continue 
                        mem[_1309 + _1009 + _1013 + _1189 + 32] = 0
                        _1390 = mem[64]
                        mem[mem[64]] = _1309 + _1009 + _1013 + _1189 - mem[64]
                        mem[64] = _1309 + _1009 + _1013 + _1189 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1390
                        u = _628
                        continue 
                    mem[_1189 + _1009 + _1013 + 32] = 0
                    _1310 = mem[_811]
                    s = 0
                    while s < _1310:
                        mem[s + _1009 + _1013 + _1189 + 32] = mem[s + _811 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1310) <= _1310:
                        _1391 = mem[64]
                        mem[mem[64]] = _1310 + _1009 + _1013 + _1189 - mem[64]
                        mem[64] = _1310 + _1009 + _1013 + _1189 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1391
                        u = _628
                        continue 
                    mem[_1310 + _1009 + _1013 + _1189 + 32] = 0
                    _1392 = mem[64]
                    mem[mem[64]] = _1310 + _1009 + _1013 + _1189 - mem[64]
                    mem[64] = _1310 + _1009 + _1013 + _1189 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1392
                    u = _628
                    continue 
                mem[_1013 + _1009 + 32] = 0
                _1190 = mem[_436]
                s = 0
                while s < _1190:
                    mem[s + _1009 + _1013 + 32] = mem[s + _436 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1190) <= _1190:
                    _1311 = mem[_811]
                    s = 0
                    while s < _1311:
                        mem[s + _1009 + _1013 + _1190 + 32] = mem[s + _811 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1311) <= _1311:
                        _1393 = mem[64]
                        mem[mem[64]] = _1311 + _1009 + _1013 + _1190 - mem[64]
                        mem[64] = _1311 + _1009 + _1013 + _1190 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1393
                        u = _628
                        continue 
                    mem[_1311 + _1009 + _1013 + _1190 + 32] = 0
                    _1394 = mem[64]
                    mem[mem[64]] = _1311 + _1009 + _1013 + _1190 - mem[64]
                    mem[64] = _1311 + _1009 + _1013 + _1190 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1394
                    u = _628
                    continue 
                mem[_1190 + _1009 + _1013 + 32] = 0
                _1312 = mem[_811]
                s = 0
                while s < _1312:
                    mem[s + _1009 + _1013 + _1190 + 32] = mem[s + _811 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1312) <= _1312:
                    _1395 = mem[64]
                    mem[mem[64]] = _1312 + _1009 + _1013 + _1190 - mem[64]
                    mem[64] = _1312 + _1009 + _1013 + _1190 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1395
                    u = _628
                    continue 
                mem[_1312 + _1009 + _1013 + _1190 + 32] = 0
                _1396 = mem[64]
                mem[mem[64]] = _1312 + _1009 + _1013 + _1190 - mem[64]
                mem[64] = _1312 + _1009 + _1013 + _1190 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1396
                u = _628
                continue 
            mem[_811 + 32 len u] = call.data[calldata.size len u]
            v = u
            t = uint32(_629)
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_811]:
                    revert with 0, 50
                mem[v + _811 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _1010 = mem[64]
            _1014 = mem[s]
            t = 0
            while t < _1014:
                mem[t + _1010 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_1014) <= _1014:
                _1191 = mem[_436]
                s = 0
                while s < _1191:
                    mem[s + _1010 + _1014 + 32] = mem[s + _436 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1191) <= _1191:
                    _1313 = mem[_811]
                    idx = 0
                    while idx < _1313:
                        mem[idx + _1010 + _1014 + _1191 + 32] = mem[idx + _811 + 32]
                        idx = idx + 32
                        continue 
                    if ceil32(_1313) <= _1313:
                        _1397 = mem[64]
                        mem[mem[64]] = _1313 + _1010 + _1014 + _1191 - mem[64]
                        mem[64] = _1313 + _1010 + _1014 + _1191 + 32
                        if not ceil32(_1191) + 1:
                            revert with 0, 17
                        s = ceil32(_1191) + 1
                        s = _1397
                        u = _628
                        continue 
                    mem[_1313 + _1010 + _1014 + _1191 + 32] = 0
                    _1398 = mem[64]
                    mem[mem[64]] = _1313 + _1010 + _1014 + _1191 - mem[64]
                    mem[64] = _1313 + _1010 + _1014 + _1191 + 32
                    if not ceil32(_1191) + 1:
                        revert with 0, 17
                    s = ceil32(_1191) + 1
                    s = _1398
                    u = _628
                    continue 
                mem[_1191 + _1010 + _1014 + 32] = 0
                _1314 = mem[_811]
                idx = 0
                while idx < _1314:
                    mem[idx + _1010 + _1014 + _1191 + 32] = mem[idx + _811 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1314) <= _1314:
                    _1399 = mem[64]
                    mem[mem[64]] = _1314 + _1010 + _1014 + _1191 - mem[64]
                    mem[64] = _1314 + _1010 + _1014 + _1191 + 32
                    if not ceil32(_1191) + 1:
                        revert with 0, 17
                    s = ceil32(_1191) + 1
                    s = _1399
                    u = _628
                    continue 
                mem[_1314 + _1010 + _1014 + _1191 + 32] = 0
                _1400 = mem[64]
                mem[mem[64]] = _1314 + _1010 + _1014 + _1191 - mem[64]
                mem[64] = _1314 + _1010 + _1014 + _1191 + 32
                if not ceil32(_1191) + 1:
                    revert with 0, 17
                s = ceil32(_1191) + 1
                s = _1400
                u = _628
                continue 
            mem[_1014 + _1010 + 32] = 0
            _1192 = mem[_436]
            s = 0
            while s < _1192:
                mem[s + _1010 + _1014 + 32] = mem[s + _436 + 32]
                s = s + 32
                continue 
            if ceil32(_1192) <= _1192:
                _1315 = mem[_811]
                idx = 0
                while idx < _1315:
                    mem[idx + _1010 + _1014 + _1192 + 32] = mem[idx + _811 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1315) <= _1315:
                    _1401 = mem[64]
                    mem[mem[64]] = _1315 + _1010 + _1014 + _1192 - mem[64]
                    mem[64] = _1315 + _1010 + _1014 + _1192 + 32
                    if not ceil32(_1192) + 1:
                        revert with 0, 17
                    s = ceil32(_1192) + 1
                    s = _1401
                    u = _628
                    continue 
                mem[_1315 + _1010 + _1014 + _1192 + 32] = 0
                _1402 = mem[64]
                mem[mem[64]] = _1315 + _1010 + _1014 + _1192 - mem[64]
                mem[64] = _1315 + _1010 + _1014 + _1192 + 32
                if not ceil32(_1192) + 1:
                    revert with 0, 17
                s = ceil32(_1192) + 1
                s = _1402
                u = _628
                continue 
            mem[_1192 + _1010 + _1014 + 32] = 0
            _1316 = mem[_811]
            idx = 0
            while idx < _1316:
                mem[idx + _1010 + _1014 + _1192 + 32] = mem[idx + _811 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1316) <= _1316:
                _1403 = mem[64]
                mem[mem[64]] = _1316 + _1010 + _1014 + _1192 - mem[64]
                mem[64] = _1316 + _1010 + _1014 + _1192 + 32
                if not ceil32(_1192) + 1:
                    revert with 0, 17
                s = ceil32(_1192) + 1
                s = _1403
                u = _628
                continue 
            mem[_1316 + _1010 + _1014 + _1192 + 32] = 0
            _1404 = mem[64]
            mem[mem[64]] = _1316 + _1010 + _1014 + _1192 - mem[64]
            mem[64] = _1316 + _1010 + _1014 + _1192 + 32
            if not ceil32(_1192) + 1:
                revert with 0, 17
            s = ceil32(_1192) + 1
            s = _1404
            u = _628
            continue 
        _627 = mem[64]
        mem[mem[64]] = 32
        _641 = mem[s]
        mem[mem[64] + 32] = mem[s]
        mem[mem[64] + 64 len ceil32(_641)] = mem[s + 32 len ceil32(_641)]
        if ceil32(_641) <= _641:
            return 32, mem[mem[64] + 32 len ceil32(_641) + 32]
        mem[_641 + mem[64] + 64] = 0
        return memory
          from mem[64]
           len ceil32(_641) + _627 + -mem[64] + 64
    mem[_262 + 32 len s] = call.data[calldata.size len s]
    t = s
    idx = uint32(_138)
    while idx:
        if t < 1:
            revert with 0, 17
        if idx / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
            revert with 0, 17
        if idx < 10 * idx / 10:
            revert with 0, 17
        if 48 > -uint8(idx - (10 * idx / 10)) + 255:
            revert with 0, 17
        if t - 1 >= mem[_262]:
            revert with 0, 50
        mem[t + _262 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 0), ('mul', -10, ('div', ('var', 0), 10)))))), 0) - 256
        t = t - 1
        idx = idx / 10
        continue 
    _437 = mem[64]
    mem[64] = mem[64] + 64
    mem[_437] = 1
    mem[_437 + 32] = 0x2300000000000000000000000000000000000000000000000000000000000000
    idx = 1
    s = _262
    u = _135
    while idx < _132:
        if idx >= mem[96]:
            revert with 0, 50
        _631 = mem[(32 * idx) + 128]
        _632 = mem[mem[(32 * idx) + 128] + 128]
        if not -mem[mem[(32 * idx) + 128] + 156 len 4]:
            _644 = mem[64]
            mem[64] = mem[64] + 64
            mem[_644] = 1
            mem[_644 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
            _646 = mem[64]
            _648 = mem[s]
            u = 0
            while u < _648:
                mem[u + _646 + 32] = mem[u + s + 32]
                u = u + 32
                continue 
            if ceil32(_648) <= _648:
                _815 = mem[_437]
                s = 0
                while s < _815:
                    mem[s + _646 + _648 + 32] = mem[s + _437 + 32]
                    s = s + 32
                    continue 
                if ceil32(_815) <= _815:
                    _1021 = mem[_644]
                    s = 0
                    while s < _1021:
                        mem[s + _646 + _648 + _815 + 32] = mem[s + _644 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1021) <= _1021:
                        _1205 = mem[64]
                        mem[mem[64]] = _1021 + _646 + _648 + _815 - mem[64]
                        mem[64] = _1021 + _646 + _648 + _815 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1205
                        u = _631
                        continue 
                    mem[_1021 + _646 + _648 + _815 + 32] = 0
                    _1206 = mem[64]
                    mem[mem[64]] = _1021 + _646 + _648 + _815 - mem[64]
                    mem[64] = _1021 + _646 + _648 + _815 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1206
                    u = _631
                    continue 
                mem[_815 + _646 + _648 + 32] = 0
                _1022 = mem[_644]
                s = 0
                while s < _1022:
                    mem[s + _646 + _648 + _815 + 32] = mem[s + _644 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1022) <= _1022:
                    _1207 = mem[64]
                    mem[mem[64]] = _1022 + _646 + _648 + _815 - mem[64]
                    mem[64] = _1022 + _646 + _648 + _815 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1207
                    u = _631
                    continue 
                mem[_1022 + _646 + _648 + _815 + 32] = 0
                _1208 = mem[64]
                mem[mem[64]] = _1022 + _646 + _648 + _815 - mem[64]
                mem[64] = _1022 + _646 + _648 + _815 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1208
                u = _631
                continue 
            mem[_648 + _646 + 32] = 0
            _816 = mem[_437]
            s = 0
            while s < _816:
                mem[s + _646 + _648 + 32] = mem[s + _437 + 32]
                s = s + 32
                continue 
            if ceil32(_816) <= _816:
                _1023 = mem[_644]
                s = 0
                while s < _1023:
                    mem[s + _646 + _648 + _816 + 32] = mem[s + _644 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1023) <= _1023:
                    _1209 = mem[64]
                    mem[mem[64]] = _1023 + _646 + _648 + _816 - mem[64]
                    mem[64] = _1023 + _646 + _648 + _816 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1209
                    u = _631
                    continue 
                mem[_1023 + _646 + _648 + _816 + 32] = 0
                _1210 = mem[64]
                mem[mem[64]] = _1023 + _646 + _648 + _816 - mem[64]
                mem[64] = _1023 + _646 + _648 + _816 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1210
                u = _631
                continue 
            mem[_816 + _646 + _648 + 32] = 0
            _1024 = mem[_644]
            s = 0
            while s < _1024:
                mem[s + _646 + _648 + _816 + 32] = mem[s + _644 + 32]
                s = s + 32
                continue 
            if ceil32(_1024) <= _1024:
                _1211 = mem[64]
                mem[mem[64]] = _1024 + _646 + _648 + _816 - mem[64]
                mem[64] = _1024 + _646 + _648 + _816 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1211
                u = _631
                continue 
            mem[_1024 + _646 + _648 + _816 + 32] = 0
            _1212 = mem[64]
            mem[mem[64]] = _1024 + _646 + _648 + _816 - mem[64]
            mem[64] = _1024 + _646 + _648 + _816 + 32
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            s = _1212
            u = _631
            continue 
        u = 0
        t = mem[mem[(32 * idx) + 128] + 156 len 4]
        while t:
            if not u + 1:
                revert with 0, 17
            u = u + 1
            t = t / 10
            continue 
        if u > test266151307():
            revert with 0, 65
        _812 = mem[64]
        mem[mem[64]] = u
        mem[64] = mem[64] + ceil32(u) + 32
        if not u:
            v = u
            t = uint32(_632)
            while t:
                if v < 1:
                    revert with 0, 17
                if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                    revert with 0, 17
                if t < 10 * t / 10:
                    revert with 0, 17
                if 48 > -uint8(t - (10 * t / 10)) + 255:
                    revert with 0, 17
                if v - 1 >= mem[_812]:
                    revert with 0, 50
                mem[v + _812 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
                v = v - 1
                t = t / 10
                continue 
            _1011 = mem[64]
            _1019 = mem[s]
            t = 0
            while t < _1019:
                mem[t + _1011 + 32] = mem[t + s + 32]
                t = t + 32
                continue 
            if ceil32(_1019) <= _1019:
                _1193 = mem[_437]
                s = 0
                while s < _1193:
                    mem[s + _1011 + _1019 + 32] = mem[s + _437 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1193) <= _1193:
                    _1317 = mem[_812]
                    s = 0
                    while s < _1317:
                        mem[s + _1011 + _1019 + _1193 + 32] = mem[s + _812 + 32]
                        s = s + 32
                        continue 
                    if ceil32(_1317) <= _1317:
                        _1405 = mem[64]
                        mem[mem[64]] = _1317 + _1011 + _1019 + _1193 - mem[64]
                        mem[64] = _1317 + _1011 + _1019 + _1193 + 32
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = _1405
                        u = _631
                        continue 
                    mem[_1317 + _1011 + _1019 + _1193 + 32] = 0
                    _1406 = mem[64]
                    mem[mem[64]] = _1317 + _1011 + _1019 + _1193 - mem[64]
                    mem[64] = _1317 + _1011 + _1019 + _1193 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1406
                    u = _631
                    continue 
                mem[_1193 + _1011 + _1019 + 32] = 0
                _1318 = mem[_812]
                s = 0
                while s < _1318:
                    mem[s + _1011 + _1019 + _1193 + 32] = mem[s + _812 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1318) <= _1318:
                    _1407 = mem[64]
                    mem[mem[64]] = _1318 + _1011 + _1019 + _1193 - mem[64]
                    mem[64] = _1318 + _1011 + _1019 + _1193 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1407
                    u = _631
                    continue 
                mem[_1318 + _1011 + _1019 + _1193 + 32] = 0
                _1408 = mem[64]
                mem[mem[64]] = _1318 + _1011 + _1019 + _1193 - mem[64]
                mem[64] = _1318 + _1011 + _1019 + _1193 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1408
                u = _631
                continue 
            mem[_1019 + _1011 + 32] = 0
            _1194 = mem[_437]
            s = 0
            while s < _1194:
                mem[s + _1011 + _1019 + 32] = mem[s + _437 + 32]
                s = s + 32
                continue 
            if ceil32(_1194) <= _1194:
                _1319 = mem[_812]
                s = 0
                while s < _1319:
                    mem[s + _1011 + _1019 + _1194 + 32] = mem[s + _812 + 32]
                    s = s + 32
                    continue 
                if ceil32(_1319) <= _1319:
                    _1409 = mem[64]
                    mem[mem[64]] = _1319 + _1011 + _1019 + _1194 - mem[64]
                    mem[64] = _1319 + _1011 + _1019 + _1194 + 32
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = _1409
                    u = _631
                    continue 
                mem[_1319 + _1011 + _1019 + _1194 + 32] = 0
                _1410 = mem[64]
                mem[mem[64]] = _1319 + _1011 + _1019 + _1194 - mem[64]
                mem[64] = _1319 + _1011 + _1019 + _1194 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1410
                u = _631
                continue 
            mem[_1194 + _1011 + _1019 + 32] = 0
            _1320 = mem[_812]
            s = 0
            while s < _1320:
                mem[s + _1011 + _1019 + _1194 + 32] = mem[s + _812 + 32]
                s = s + 32
                continue 
            if ceil32(_1320) <= _1320:
                _1411 = mem[64]
                mem[mem[64]] = _1320 + _1011 + _1019 + _1194 - mem[64]
                mem[64] = _1320 + _1011 + _1019 + _1194 + 32
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = _1411
                u = _631
                continue 
            mem[_1320 + _1011 + _1019 + _1194 + 32] = 0
            _1412 = mem[64]
            mem[mem[64]] = _1320 + _1011 + _1019 + _1194 - mem[64]
            mem[64] = _1320 + _1011 + _1019 + _1194 + 32
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            s = _1412
            u = _631
            continue 
        mem[_812 + 32 len u] = call.data[calldata.size len u]
        v = u
        t = uint32(_632)
        while t:
            if v < 1:
                revert with 0, 17
            if t / 10 > 0x1999999999999999999999999999999999999999999999999999999999999999:
                revert with 0, 17
            if t < 10 * t / 10:
                revert with 0, 17
            if 48 > -uint8(t - (10 * t / 10)) + 255:
                revert with 0, 17
            if v - 1 >= mem[_812]:
                revert with 0, 50
            mem[v + _812 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mask_shl', 8, 0, 0, ('add', ('var', 2), ('mul', -10, ('div', ('var', 2), 10)))))), 0) - 256
            v = v - 1
            t = t / 10
            continue 
        _1012 = mem[64]
        _1020 = mem[s]
        t = 0
        while t < _1020:
            mem[t + _1012 + 32] = mem[t + s + 32]
            t = t + 32
            continue 
        if ceil32(_1020) <= _1020:
            _1195 = mem[_437]
            s = 0
            while s < _1195:
                mem[s + _1012 + _1020 + 32] = mem[s + _437 + 32]
                s = s + 32
                continue 
            if ceil32(_1195) <= _1195:
                _1321 = mem[_812]
                idx = 0
                while idx < _1321:
                    mem[idx + _1012 + _1020 + _1195 + 32] = mem[idx + _812 + 32]
                    idx = idx + 32
                    continue 
                if ceil32(_1321) <= _1321:
                    _1413 = mem[64]
                    mem[mem[64]] = _1321 + _1012 + _1020 + _1195 - mem[64]
                    mem[64] = _1321 + _1012 + _1020 + _1195 + 32
                    if not ceil32(_1195) + 1:
                        revert with 0, 17
                    s = ceil32(_1195) + 1
                    s = _1413
                    u = _631
                    continue 
                mem[_1321 + _1012 + _1020 + _1195 + 32] = 0
                _1414 = mem[64]
                mem[mem[64]] = _1321 + _1012 + _1020 + _1195 - mem[64]
                mem[64] = _1321 + _1012 + _1020 + _1195 + 32
                if not ceil32(_1195) + 1:
                    revert with 0, 17
                s = ceil32(_1195) + 1
                s = _1414
                u = _631
                continue 
            mem[_1195 + _1012 + _1020 + 32] = 0
            _1322 = mem[_812]
            idx = 0
            while idx < _1322:
                mem[idx + _1012 + _1020 + _1195 + 32] = mem[idx + _812 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1322) <= _1322:
                _1415 = mem[64]
                mem[mem[64]] = _1322 + _1012 + _1020 + _1195 - mem[64]
                mem[64] = _1322 + _1012 + _1020 + _1195 + 32
                if not ceil32(_1195) + 1:
                    revert with 0, 17
                s = ceil32(_1195) + 1
                s = _1415
                u = _631
                continue 
            mem[_1322 + _1012 + _1020 + _1195 + 32] = 0
            _1416 = mem[64]
            mem[mem[64]] = _1322 + _1012 + _1020 + _1195 - mem[64]
            mem[64] = _1322 + _1012 + _1020 + _1195 + 32
            if not ceil32(_1195) + 1:
                revert with 0, 17
            s = ceil32(_1195) + 1
            s = _1416
            u = _631
            continue 
        mem[_1020 + _1012 + 32] = 0
        _1196 = mem[_437]
        s = 0
        while s < _1196:
            mem[s + _1012 + _1020 + 32] = mem[s + _437 + 32]
            s = s + 32
            continue 
        if ceil32(_1196) <= _1196:
            _1323 = mem[_812]
            idx = 0
            while idx < _1323:
                mem[idx + _1012 + _1020 + _1196 + 32] = mem[idx + _812 + 32]
                idx = idx + 32
                continue 
            if ceil32(_1323) <= _1323:
                _1417 = mem[64]
                mem[mem[64]] = _1323 + _1012 + _1020 + _1196 - mem[64]
                mem[64] = _1323 + _1012 + _1020 + _1196 + 32
                if not ceil32(_1196) + 1:
                    revert with 0, 17
                s = ceil32(_1196) + 1
                s = _1417
                u = _631
                continue 
            mem[_1323 + _1012 + _1020 + _1196 + 32] = 0
            _1418 = mem[64]
            mem[mem[64]] = _1323 + _1012 + _1020 + _1196 - mem[64]
            mem[64] = _1323 + _1012 + _1020 + _1196 + 32
            if not ceil32(_1196) + 1:
                revert with 0, 17
            s = ceil32(_1196) + 1
            s = _1418
            u = _631
            continue 
        mem[_1196 + _1012 + _1020 + 32] = 0
        _1324 = mem[_812]
        idx = 0
        while idx < _1324:
            mem[idx + _1012 + _1020 + _1196 + 32] = mem[idx + _812 + 32]
            idx = idx + 32
            continue 
        if ceil32(_1324) <= _1324:
            _1419 = mem[64]
            mem[mem[64]] = _1324 + _1012 + _1020 + _1196 - mem[64]
            mem[64] = _1324 + _1012 + _1020 + _1196 + 32
            if not ceil32(_1196) + 1:
                revert with 0, 17
            s = ceil32(_1196) + 1
            s = _1419
            u = _631
            continue 
        mem[_1324 + _1012 + _1020 + _1196 + 32] = 0
        _1420 = mem[64]
        mem[mem[64]] = _1324 + _1012 + _1020 + _1196 - mem[64]
        mem[64] = _1324 + _1012 + _1020 + _1196 + 32
        if not ceil32(_1196) + 1:
            revert with 0, 17
        s = ceil32(_1196) + 1
        s = _1420
        u = _631
        continue 
    _630 = mem[64]
    mem[mem[64]] = 32
    _643 = mem[s]
    mem[mem[64] + 32] = mem[s]
    mem[mem[64] + 64 len ceil32(_643)] = mem[s + 32 len ceil32(_643)]
    if ceil32(_643) <= _643:
        return 32, mem[mem[64] + 32 len ceil32(_643) + 32]
    mem[_643 + mem[64] + 64] = 0
    return memory
      from mem[64]
       len ceil32(_643) + _630 + -mem[64] + 64
}

function _getRewardAmountOf(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    mem[0] = arg1
    mem[32] = 10
    idx = 0
    s = 0
    while idx < sub_2c534595[address(arg1)].field_0:
        mem[0] = sha3(address(arg1), 10)
        _521 = mem[64]
        mem[64] = mem[64] + 160
        if sub_2c534595[address(arg1)][idx].field_0:
            if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                revert with 0, 34
            _522 = mem[64]
            mem[64] = mem[64] + ceil32(uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) + 32
            mem[_522] = uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5
            if sub_2c534595[address(arg1)][idx].field_0:
                if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                    revert with 0, 34
                if not Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                    mem[_521] = _522
                    mem[_521 + 32] = sub_2c534595[address(arg1)][idx].field_256
                    mem[_521 + 64] = sub_2c534595[address(arg1)][idx].field_512
                    mem[_521 + 96] = sub_2c534595[address(arg1)][idx].field_768
                    mem[_521 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                    if -sub_2c534595[address(arg1)][idx].field_512:
                        _530 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_530] = 30
                        mem[_530 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                            _538 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _538 + 68] = mem[idx + _530 + 32]
                                idx = idx + 32
                                continue 
                            mem[_538 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _538 + -mem[64] + 100
                        if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                            revert with 0, 17
                        _577 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_577] = 26
                        mem[_577 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _598 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _598 + 68] = mem[idx + _577 + 32]
                                idx = idx + 32
                                continue 
                            mem[_598 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _598 + -mem[64] + 100
                        if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                            revert with 0, 17
                        if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -rewardPerNode:
                            if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                        continue 
                    _570 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_570] = 30
                    mem[_570 + 32] = 'SafeMath: subtraction overflow'
                    if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                        _587 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _587 + 68] = mem[idx + _570 + 32]
                            idx = idx + 32
                            continue 
                        mem[_587 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _587 + -mem[64] + 100
                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                        revert with 0, 17
                    _672 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_672] = 26
                    mem[_672 + 32] = 'SafeMath: division by zero'
                    if not claimTime:
                        _701 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _701 + 68] = mem[idx + _672 + 32]
                            idx = idx + 32
                            continue 
                        mem[_701 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _701 + -mem[64] + 100
                else:
                    if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                        mem[_522 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                        mem[_521] = _522
                        mem[_521 + 32] = sub_2c534595[address(arg1)][idx].field_256
                        mem[_521 + 64] = sub_2c534595[address(arg1)][idx].field_512
                        mem[_521 + 96] = sub_2c534595[address(arg1)][idx].field_768
                        mem[_521 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                        if -sub_2c534595[address(arg1)][idx].field_512:
                            _540 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_540] = 30
                            mem[_540 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                _551 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _551 + 68] = mem[idx + _540 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_551 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _551 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _599 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_599] = 26
                            mem[_599 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _626 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _626 + 68] = mem[idx + _599 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_626 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _626 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        _590 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_590] = 30
                        mem[_590 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                            _615 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _615 + 68] = mem[idx + _590 + 32]
                                idx = idx + 32
                                continue 
                            mem[_615 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _615 + -mem[64] + 100
                        if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _703 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_703] = 26
                        mem[_703 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _729 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _729 + 68] = mem[idx + _703 + 32]
                                idx = idx + 32
                                continue 
                            mem[_729 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _729 + -mem[64] + 100
                    else:
                        mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                        mem[_522 + 32] = sub_2c534595[address(arg1)][idx].field_0
                        t = _522 + 32
                        u = sha3(mem[0])
                        while _522 + (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_521] = _522
                        mem[_521 + 32] = sub_2c534595[address(arg1)][idx].field_256
                        mem[_521 + 64] = sub_2c534595[address(arg1)][idx].field_512
                        mem[_521 + 96] = sub_2c534595[address(arg1)][idx].field_768
                        mem[_521 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                        if -sub_2c534595[address(arg1)][idx].field_512:
                            _1076 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1076] = 30
                            mem[_1076 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                _1136 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1136 + 68] = mem[idx + _1076 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1136 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1136 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1156 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1156] = 26
                            mem[_1156 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _1164 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1164 + 68] = mem[idx + _1156 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1164 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1164 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        _1149 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1149] = 30
                        mem[_1149 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                            _1160 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1160 + 68] = mem[idx + _1149 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1160 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1160 + -mem[64] + 100
                        if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1189 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1189] = 26
                        mem[_1189 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _1196 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1196 + 68] = mem[idx + _1189 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1196 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1196 + -mem[64] + 100
            else:
                if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                    revert with 0, 34
                if not sub_2c534595[address(arg1)][idx].field_1:
                    mem[_521] = _522
                    mem[_521 + 32] = sub_2c534595[address(arg1)][idx].field_256
                    mem[_521 + 64] = sub_2c534595[address(arg1)][idx].field_512
                    mem[_521 + 96] = sub_2c534595[address(arg1)][idx].field_768
                    mem[_521 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                    if -sub_2c534595[address(arg1)][idx].field_512:
                        _534 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_534] = 30
                        mem[_534 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                            _543 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _543 + 68] = mem[idx + _534 + 32]
                                idx = idx + 32
                                continue 
                            mem[_543 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _543 + -mem[64] + 100
                        if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                            revert with 0, 17
                        _591 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_591] = 26
                        mem[_591 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _616 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _616 + 68] = mem[idx + _591 + 32]
                                idx = idx + 32
                                continue 
                            mem[_616 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _616 + -mem[64] + 100
                        if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                            revert with 0, 17
                        if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -rewardPerNode:
                            if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                        continue 
                    _580 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_580] = 30
                    mem[_580 + 32] = 'SafeMath: subtraction overflow'
                    if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                        _600 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _600 + 68] = mem[idx + _580 + 32]
                            idx = idx + 32
                            continue 
                        mem[_600 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _600 + -mem[64] + 100
                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                        revert with 0, 17
                    _689 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_689] = 26
                    mem[_689 + 32] = 'SafeMath: division by zero'
                    if not claimTime:
                        _716 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _716 + 68] = mem[idx + _689 + 32]
                            idx = idx + 32
                            continue 
                        mem[_716 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _716 + -mem[64] + 100
                else:
                    if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                        mem[_522 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                        mem[_521] = _522
                        mem[_521 + 32] = sub_2c534595[address(arg1)][idx].field_256
                        mem[_521 + 64] = sub_2c534595[address(arg1)][idx].field_512
                        mem[_521 + 96] = sub_2c534595[address(arg1)][idx].field_768
                        mem[_521 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                        if -sub_2c534595[address(arg1)][idx].field_512:
                            _545 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_545] = 30
                            mem[_545 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                _558 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _558 + 68] = mem[idx + _545 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_558 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _558 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _617 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_617] = 26
                            mem[_617 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _647 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _647 + 68] = mem[idx + _617 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_647 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _647 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        _603 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_603] = 30
                        mem[_603 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                            _632 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _632 + 68] = mem[idx + _603 + 32]
                                idx = idx + 32
                                continue 
                            mem[_632 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _632 + -mem[64] + 100
                        if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _718 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_718] = 26
                        mem[_718 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _747 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _747 + 68] = mem[idx + _718 + 32]
                                idx = idx + 32
                                continue 
                            mem[_747 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _747 + -mem[64] + 100
                    else:
                        mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                        mem[_522 + 32] = sub_2c534595[address(arg1)][idx].field_0
                        t = _522 + 32
                        u = sha3(mem[0])
                        while _522 + sub_2c534595[address(arg1)][idx].field_1 > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_521] = _522
                        mem[_521 + 32] = sub_2c534595[address(arg1)][idx].field_256
                        mem[_521 + 64] = sub_2c534595[address(arg1)][idx].field_512
                        mem[_521 + 96] = sub_2c534595[address(arg1)][idx].field_768
                        mem[_521 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                        if -sub_2c534595[address(arg1)][idx].field_512:
                            _1093 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1093] = 30
                            mem[_1093 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                _1137 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1137 + 68] = mem[idx + _1093 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1137 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1137 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1157 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1157] = 26
                            mem[_1157 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _1165 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1165 + 68] = mem[idx + _1157 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1165 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1165 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        _1151 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1151] = 30
                        mem[_1151 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                            _1161 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1161 + 68] = mem[idx + _1151 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1161 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1161 + -mem[64] + 100
                        if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1191 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1191] = 26
                        mem[_1191 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _1197 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1197 + 68] = mem[idx + _1191 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1197 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1197 + -mem[64] + 100
        else:
            if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                revert with 0, 34
            _523 = mem[64]
            mem[64] = mem[64] + ceil32(sub_2c534595[address(arg1)][idx].field_1) + 32
            mem[_523] = sub_2c534595[address(arg1)][idx].field_1
            if sub_2c534595[address(arg1)][idx].field_0:
                if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                    revert with 0, 34
                if not Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                    mem[_521] = _523
                    mem[_521 + 32] = sub_2c534595[address(arg1)][idx].field_256
                    mem[_521 + 64] = sub_2c534595[address(arg1)][idx].field_512
                    mem[_521 + 96] = sub_2c534595[address(arg1)][idx].field_768
                    mem[_521 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                    if -sub_2c534595[address(arg1)][idx].field_512:
                        _536 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_536] = 30
                        mem[_536 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                            _546 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _546 + 68] = mem[idx + _536 + 32]
                                idx = idx + 32
                                continue 
                            mem[_546 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _546 + -mem[64] + 100
                        if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                            revert with 0, 17
                        _593 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_593] = 26
                        mem[_593 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _618 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _618 + 68] = mem[idx + _593 + 32]
                                idx = idx + 32
                                continue 
                            mem[_618 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _618 + -mem[64] + 100
                        if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                            revert with 0, 17
                        if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -rewardPerNode:
                            if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                        continue 
                    _583 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_583] = 30
                    mem[_583 + 32] = 'SafeMath: subtraction overflow'
                    if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                        _604 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _604 + 68] = mem[idx + _583 + 32]
                            idx = idx + 32
                            continue 
                        mem[_604 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _604 + -mem[64] + 100
                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                        revert with 0, 17
                    _694 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_694] = 26
                    mem[_694 + 32] = 'SafeMath: division by zero'
                    if not claimTime:
                        _719 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _719 + 68] = mem[idx + _694 + 32]
                            idx = idx + 32
                            continue 
                        mem[_719 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _719 + -mem[64] + 100
                else:
                    if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                        mem[_523 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                        mem[_521] = _523
                        mem[_521 + 32] = sub_2c534595[address(arg1)][idx].field_256
                        mem[_521 + 64] = sub_2c534595[address(arg1)][idx].field_512
                        mem[_521 + 96] = sub_2c534595[address(arg1)][idx].field_768
                        mem[_521 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                        if -sub_2c534595[address(arg1)][idx].field_512:
                            _548 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_548] = 30
                            mem[_548 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                _561 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _561 + 68] = mem[idx + _548 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_561 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _561 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _619 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_619] = 26
                            mem[_619 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _650 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _650 + 68] = mem[idx + _619 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_650 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _650 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        _607 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_607] = 30
                        mem[_607 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                            _638 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _638 + 68] = mem[idx + _607 + 32]
                                idx = idx + 32
                                continue 
                            mem[_638 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _638 + -mem[64] + 100
                        if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _721 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_721] = 26
                        mem[_721 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _753 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _753 + 68] = mem[idx + _721 + 32]
                                idx = idx + 32
                                continue 
                            mem[_753 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _753 + -mem[64] + 100
                    else:
                        mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                        mem[_523 + 32] = sub_2c534595[address(arg1)][idx].field_0
                        t = _523 + 32
                        u = sha3(mem[0])
                        while _523 + (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_521] = _523
                        mem[_521 + 32] = sub_2c534595[address(arg1)][idx].field_256
                        mem[_521 + 64] = sub_2c534595[address(arg1)][idx].field_512
                        mem[_521 + 96] = sub_2c534595[address(arg1)][idx].field_768
                        mem[_521 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                        if -sub_2c534595[address(arg1)][idx].field_512:
                            _1110 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1110] = 30
                            mem[_1110 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                _1138 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1138 + 68] = mem[idx + _1110 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1138 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1138 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1158 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1158] = 26
                            mem[_1158 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _1166 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1166 + 68] = mem[idx + _1158 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1166 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1166 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        _1153 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1153] = 30
                        mem[_1153 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                            _1162 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1162 + 68] = mem[idx + _1153 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1162 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1162 + -mem[64] + 100
                        if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1193 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1193] = 26
                        mem[_1193 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _1198 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1198 + 68] = mem[idx + _1193 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1198 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1198 + -mem[64] + 100
            else:
                if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                    revert with 0, 34
                if not sub_2c534595[address(arg1)][idx].field_1:
                    mem[_521] = _523
                    mem[_521 + 32] = sub_2c534595[address(arg1)][idx].field_256
                    mem[_521 + 64] = sub_2c534595[address(arg1)][idx].field_512
                    mem[_521 + 96] = sub_2c534595[address(arg1)][idx].field_768
                    mem[_521 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                    if -sub_2c534595[address(arg1)][idx].field_512:
                        _541 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_541] = 30
                        mem[_541 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                            _552 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _552 + 68] = mem[idx + _541 + 32]
                                idx = idx + 32
                                continue 
                            mem[_552 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _552 + -mem[64] + 100
                        if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                            revert with 0, 17
                        _608 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_608] = 26
                        mem[_608 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _639 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _639 + 68] = mem[idx + _608 + 32]
                                idx = idx + 32
                                continue 
                            mem[_639 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _639 + -mem[64] + 100
                        if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                            revert with 0, 17
                        if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -rewardPerNode:
                            if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if not idx + 1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                        continue 
                    _596 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_596] = 30
                    mem[_596 + 32] = 'SafeMath: subtraction overflow'
                    if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                        _620 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _620 + 68] = mem[idx + _596 + 32]
                            idx = idx + 32
                            continue 
                        mem[_620 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _620 + -mem[64] + 100
                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                        revert with 0, 17
                    _709 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_709] = 26
                    mem[_709 + 32] = 'SafeMath: division by zero'
                    if not claimTime:
                        _736 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _736 + 68] = mem[idx + _709 + 32]
                            idx = idx + 32
                            continue 
                        mem[_736 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _736 + -mem[64] + 100
                else:
                    if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                        mem[_523 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                        mem[_521] = _523
                        mem[_521 + 32] = sub_2c534595[address(arg1)][idx].field_256
                        mem[_521 + 64] = sub_2c534595[address(arg1)][idx].field_512
                        mem[_521 + 96] = sub_2c534595[address(arg1)][idx].field_768
                        mem[_521 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                        if -sub_2c534595[address(arg1)][idx].field_512:
                            _554 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_554] = 30
                            mem[_554 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                _568 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _568 + 68] = mem[idx + _554 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_568 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _568 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _640 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_640] = 26
                            mem[_640 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _670 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _670 + 68] = mem[idx + _640 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_670 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _670 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        _623 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_623] = 30
                        mem[_623 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                            _656 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _656 + 68] = mem[idx + _623 + 32]
                                idx = idx + 32
                                continue 
                            mem[_656 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _656 + -mem[64] + 100
                        if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _738 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_738] = 26
                        mem[_738 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _773 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _773 + 68] = mem[idx + _738 + 32]
                                idx = idx + 32
                                continue 
                            mem[_773 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _773 + -mem[64] + 100
                    else:
                        mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                        mem[_523 + 32] = sub_2c534595[address(arg1)][idx].field_0
                        t = _523 + 32
                        u = sha3(mem[0])
                        while _523 + sub_2c534595[address(arg1)][idx].field_1 > t:
                            mem[t + 32] = uint256(stor1[u])
                            t = t + 32
                            u = u + 1
                            continue 
                        mem[_521] = _523
                        mem[_521 + 32] = sub_2c534595[address(arg1)][idx].field_256
                        mem[_521 + 64] = sub_2c534595[address(arg1)][idx].field_512
                        mem[_521 + 96] = sub_2c534595[address(arg1)][idx].field_768
                        mem[_521 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                        if -sub_2c534595[address(arg1)][idx].field_512:
                            _1127 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1127] = 30
                            mem[_1127 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                _1139 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _1139 + 68] = mem[idx + _1127 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1139 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _1139 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _1159 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1159] = 26
                            mem[_1159 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _1167 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _1167 + 68] = mem[idx + _1159 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_1167 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _1167 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        _1155 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1155] = 30
                        mem[_1155 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                            _1163 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1163 + 68] = mem[idx + _1155 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1163 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _1163 + -mem[64] + 100
                        if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _1195 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1195] = 26
                        mem[_1195 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _1199 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _1199 + 68] = mem[idx + _1195 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1199 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _1199 + -mem[64] + 100
        ('stor', ('name', 'claimTime', 19))
        if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
            revert with 0, 17
        if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
            revert with 0, 'SafeMath: addition overflow'
        if not -rewardPerNode:
            if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                revert with 0, 17
            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                revert with 0, 'SafeMath: addition overflow'
            if s > !sub_2c534595[address(arg1)][idx].field_768:
                revert with 0, 17
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            s = s + sub_2c534595[address(arg1)][idx].field_768
            continue 
        if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
            revert with 0, 17
        if not rewardPerNode:
            revert with 0, 18
        if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
            revert with 0, 'SafeMath: multiplication overflow'
        if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
            revert with 0, 17
        if sub_2c534595[address(arg1)][idx].field_768 < 0:
            revert with 0, 'SafeMath: addition overflow'
        if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
            revert with 0, 17
        if not idx + 1:
            revert with 0, 17
        idx = idx + 1
        s = s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768
        continue 
    return s
}

function _cashoutAllNodesReward(address arg1) payable {
    mem[64] = 96
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if msg.sender == tokenAddress:
        mem[0] = arg1
        mem[32] = 10
        idx = 0
        s = 0
        while idx < sub_2c534595[address(arg1)].field_0:
            mem[0] = sha3(address(arg1), 10)
            _4007 = mem[64]
            mem[64] = mem[64] + 160
            if sub_2c534595[address(arg1)][idx].field_0:
                if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                    revert with 0, 34
                _4014 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) + 32
                mem[_4014] = uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5
                if sub_2c534595[address(arg1)][idx].field_0:
                    if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    if not Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                        mem[_4007] = _4014
                        mem[_4007 + 32] = sub_2c534595[address(arg1)][idx].field_256
                        mem[_4007 + 64] = sub_2c534595[address(arg1)][idx].field_512
                        mem[_4007 + 96] = sub_2c534595[address(arg1)][idx].field_768
                        mem[_4007 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                        if -sub_2c534595[address(arg1)][idx].field_512:
                            _4038 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4038] = 30
                            mem[_4038 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                _4062 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4062 + 68] = mem[idx + _4038 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4062 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4062 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _4179 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4179] = 26
                            mem[_4179 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4242 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4242 + 68] = mem[idx + _4179 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4242 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4242 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5532 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5532] = 26
                                        mem[_5532 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5750 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5750] = 26
                                        mem[_5750 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5533 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5533] = 26
                                        mem[_5533 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5751 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5751] = 26
                                        mem[_5751 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                    _5748 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5748] = 26
                                    mem[_5748 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6120 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6120] = 26
                                    mem[_6120 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                    _5749 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5749] = 26
                                    mem[_5749 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6121 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6121] = 26
                                    mem[_6121 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2c534595[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 10)
                            sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        _4156 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4156] = 30
                        mem[_4156 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                            _4209 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4209 + 68] = mem[idx + _4156 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4209 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4209 + -mem[64] + 100
                        if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _4462 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4462] = 26
                        mem[_4462 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _4551 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4551 + 68] = mem[idx + _4462 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4551 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4551 + -mem[64] + 100
                        if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                            revert with 0, 17
                        if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -rewardPerNode:
                            if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                    _5799 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5799] = 26
                                    mem[_5799 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6202 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6202] = 26
                                    mem[_6202 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                    _5800 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5800] = 26
                                    mem[_5800 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6203 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6203] = 26
                                    mem[_6203 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2c534595[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 10)
                            sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if idx >= sub_2c534595[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 10)
                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                            revert with 0, 17
                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                            if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                _6200 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6200] = 26
                                mem[_6200 + 32] = 'SafeMath: division by zero'
                            else:
                                if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6790 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6790] = 26
                                mem[_6790 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                        else:
                            if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                _6201 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6201] = 26
                                mem[_6201 + 32] = 'SafeMath: division by zero'
                            else:
                                if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6791 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6791] = 26
                                mem[_6791 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                    else:
                        if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                            mem[_4014 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                            mem[_4007] = _4014
                            mem[_4007 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4007 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4007 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4007 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4064 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4064] = 30
                                mem[_4064 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4097 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4097 + 68] = mem[idx + _4064 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4097 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4097 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4243 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4243] = 26
                                mem[_4243 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4322 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4322 + 68] = mem[idx + _4243 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4322 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4322 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5599 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5599] = 26
                                            mem[_5599 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5864 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5864] = 26
                                            mem[_5864 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5600 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5600] = 26
                                            mem[_5600 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5865 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5865] = 26
                                            mem[_5865 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5862 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5862] = 26
                                        mem[_5862 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6296 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6296] = 26
                                        mem[_6296 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5863 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5863] = 26
                                        mem[_5863 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6297 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6297] = 26
                                        mem[_6297 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4212 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4212] = 30
                            mem[_4212 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4283 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4283 + 68] = mem[idx + _4212 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4283 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4283 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4553 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4553] = 26
                            mem[_4553 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4625 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4625 + 68] = mem[idx + _4553 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4625 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4625 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5927 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5927] = 26
                                        mem[_5927 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6410 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6410] = 26
                                        mem[_6410 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5928 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5928] = 26
                                        mem[_5928 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6411 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6411] = 26
                                        mem[_6411 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6408 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6408] = 26
                                    mem[_6408 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6984 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6984] = 26
                                    mem[_6984 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6409 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6409] = 26
                                    mem[_6409 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6985 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6985] = 26
                                    mem[_6985 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_4014 + 32] = sub_2c534595[address(arg1)][idx].field_0
                            t = _4014 + 32
                            u = sha3(mem[0])
                            while _4014 + (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_4007] = _4014
                            mem[_4007 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4007 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4007 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4007 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _8108 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8108] = 30
                                mem[_8108 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _8304 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8304 + 68] = mem[idx + _8108 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8304 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8304 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _8364 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8364] = 26
                                mem[_8364 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8388 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8388 + 68] = mem[idx + _8364 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8388 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8388 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8808 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8808] = 26
                                            mem[_8808 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _8906 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8906] = 26
                                            mem[_8906 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8809 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8809] = 26
                                            mem[_8809 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _8907 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8907] = 26
                                            mem[_8907 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _8904 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8904] = 26
                                        mem[_8904 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9048 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9048] = 26
                                        mem[_9048 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _8905 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8905] = 26
                                        mem[_8905 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9049 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9049] = 26
                                        mem[_9049 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _8341 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8341] = 30
                            mem[_8341 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _8376 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _8376 + 68] = mem[idx + _8341 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8376 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _8376 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _8461 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8461] = 26
                            mem[_8461 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _8484 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _8484 + 68] = mem[idx + _8461 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8484 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _8484 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _8952 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8952] = 26
                                        mem[_8952 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9124 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9124] = 26
                                        mem[_9124 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _8953 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8953] = 26
                                        mem[_8953 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9125 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9125] = 26
                                        mem[_9125 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _9122 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9122] = 26
                                    mem[_9122 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _9292 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9292] = 26
                                    mem[_9292 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _9123 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9123] = 26
                                    mem[_9123 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _9293 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9293] = 26
                                    mem[_9293 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                else:
                    if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                        revert with 0, 34
                    if not sub_2c534595[address(arg1)][idx].field_1:
                        mem[_4007] = _4014
                        mem[_4007 + 32] = sub_2c534595[address(arg1)][idx].field_256
                        mem[_4007 + 64] = sub_2c534595[address(arg1)][idx].field_512
                        mem[_4007 + 96] = sub_2c534595[address(arg1)][idx].field_768
                        mem[_4007 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                        if -sub_2c534595[address(arg1)][idx].field_512:
                            _4050 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4050] = 30
                            mem[_4050 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                _4077 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4077 + 68] = mem[idx + _4050 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4077 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4077 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _4213 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4213] = 26
                            mem[_4213 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4284 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4284 + 68] = mem[idx + _4213 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4284 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4284 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5564 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5564] = 26
                                        mem[_5564 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5805 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5805] = 26
                                        mem[_5805 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5565 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5565] = 26
                                        mem[_5565 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5806 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5806] = 26
                                        mem[_5806 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                    _5803 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5803] = 26
                                    mem[_5803 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6208 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6208] = 26
                                    mem[_6208 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                    _5804 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5804] = 26
                                    mem[_5804 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6209 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6209] = 26
                                    mem[_6209 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2c534595[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 10)
                            sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        _4182 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4182] = 30
                        mem[_4182 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                            _4244 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4244 + 68] = mem[idx + _4182 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4244 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4244 + -mem[64] + 100
                        if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _4509 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4509] = 26
                        mem[_4509 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _4590 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4590 + 68] = mem[idx + _4509 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4590 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4590 + -mem[64] + 100
                        if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                            revert with 0, 17
                        if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -rewardPerNode:
                            if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                    _5866 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5866] = 26
                                    mem[_5866 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6306 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6306] = 26
                                    mem[_6306 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                    _5867 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5867] = 26
                                    mem[_5867 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6307 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6307] = 26
                                    mem[_6307 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2c534595[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 10)
                            sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if idx >= sub_2c534595[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 10)
                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                            revert with 0, 17
                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                            if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                _6304 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6304] = 26
                                mem[_6304 + 32] = 'SafeMath: division by zero'
                            else:
                                if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6888 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6888] = 26
                                mem[_6888 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                        else:
                            if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                _6305 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6305] = 26
                                mem[_6305 + 32] = 'SafeMath: division by zero'
                            else:
                                if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6889 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6889] = 26
                                mem[_6889 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                    else:
                        if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                            mem[_4014 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                            mem[_4007] = _4014
                            mem[_4007 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4007 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4007 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4007 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4079 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4079] = 30
                                mem[_4079 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4116 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4116 + 68] = mem[idx + _4079 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4116 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4116 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4285 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4285] = 26
                                mem[_4285 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4377 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4377 + 68] = mem[idx + _4285 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4377 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4377 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5636 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5636] = 26
                                            mem[_5636 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5934 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5934] = 26
                                            mem[_5934 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5637 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5637] = 26
                                            mem[_5637 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5935 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5935] = 26
                                            mem[_5935 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5932 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5932] = 26
                                        mem[_5932 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6414 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6414] = 26
                                        mem[_6414 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5933 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5933] = 26
                                        mem[_5933 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6415 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6415] = 26
                                        mem[_6415 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4247 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4247] = 30
                            mem[_4247 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4328 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4328 + 68] = mem[idx + _4247 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4328 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4328 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4592 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4592] = 26
                            mem[_4592 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4673 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4673 + 68] = mem[idx + _4592 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4673 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4673 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5999 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5999] = 26
                                        mem[_5999 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6524 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6524] = 26
                                        mem[_6524 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _6000 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6000] = 26
                                        mem[_6000 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6525 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6525] = 26
                                        mem[_6525 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6522 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6522] = 26
                                    mem[_6522 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7100 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7100] = 26
                                    mem[_7100 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6523 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6523] = 26
                                    mem[_6523 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7101 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7101] = 26
                                    mem[_7101 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_4014 + 32] = sub_2c534595[address(arg1)][idx].field_0
                            t = _4014 + 32
                            u = sha3(mem[0])
                            while _4014 + sub_2c534595[address(arg1)][idx].field_1 > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_4007] = _4014
                            mem[_4007 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4007 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4007 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4007 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _8125 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8125] = 30
                                mem[_8125 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _8305 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8305 + 68] = mem[idx + _8125 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8305 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8305 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _8365 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8365] = 26
                                mem[_8365 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8389 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8389 + 68] = mem[idx + _8365 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8389 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8389 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8811 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8811] = 26
                                            mem[_8811 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _8910 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8910] = 26
                                            mem[_8910 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8812 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8812] = 26
                                            mem[_8812 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _8911 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8911] = 26
                                            mem[_8911 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _8908 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8908] = 26
                                        mem[_8908 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9054 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9054] = 26
                                        mem[_9054 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _8909 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8909] = 26
                                        mem[_8909 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9055 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9055] = 26
                                        mem[_9055 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _8343 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8343] = 30
                            mem[_8343 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _8377 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _8377 + 68] = mem[idx + _8343 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8377 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _8377 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _8463 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8463] = 26
                            mem[_8463 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _8485 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _8485 + 68] = mem[idx + _8463 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8485 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _8485 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _8954 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8954] = 26
                                        mem[_8954 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9130 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9130] = 26
                                        mem[_9130 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _8955 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8955] = 26
                                        mem[_8955 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9131 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9131] = 26
                                        mem[_9131 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _9128 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9128] = 26
                                    mem[_9128 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _9300 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9300] = 26
                                    mem[_9300 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _9129 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9129] = 26
                                    mem[_9129 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _9301 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9301] = 26
                                    mem[_9301 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
            else:
                if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                    revert with 0, 34
                _4017 = mem[64]
                mem[64] = mem[64] + ceil32(sub_2c534595[address(arg1)][idx].field_1) + 32
                mem[_4017] = sub_2c534595[address(arg1)][idx].field_1
                if sub_2c534595[address(arg1)][idx].field_0:
                    if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    if not Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                        mem[_4007] = _4017
                        mem[_4007 + 32] = sub_2c534595[address(arg1)][idx].field_256
                        mem[_4007 + 64] = sub_2c534595[address(arg1)][idx].field_512
                        mem[_4007 + 96] = sub_2c534595[address(arg1)][idx].field_768
                        mem[_4007 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                        if -sub_2c534595[address(arg1)][idx].field_512:
                            _4052 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4052] = 30
                            mem[_4052 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                _4080 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4080 + 68] = mem[idx + _4052 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4080 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4080 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _4215 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4215] = 26
                            mem[_4215 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4286 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4286 + 68] = mem[idx + _4215 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4286 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4286 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5568 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5568] = 26
                                        mem[_5568 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5812 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5812] = 26
                                        mem[_5812 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5569 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5569] = 26
                                        mem[_5569 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5813 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5813] = 26
                                        mem[_5813 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                    _5810 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5810] = 26
                                    mem[_5810 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6216 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6216] = 26
                                    mem[_6216 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                    _5811 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5811] = 26
                                    mem[_5811 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6217 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6217] = 26
                                    mem[_6217 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2c534595[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 10)
                            sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        _4185 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4185] = 30
                        mem[_4185 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                            _4248 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4248 + 68] = mem[idx + _4185 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4248 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4248 + -mem[64] + 100
                        if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _4514 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4514] = 26
                        mem[_4514 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _4593 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4593 + 68] = mem[idx + _4514 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4593 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4593 + -mem[64] + 100
                        if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                            revert with 0, 17
                        if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -rewardPerNode:
                            if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                    _5870 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5870] = 26
                                    mem[_5870 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6316 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6316] = 26
                                    mem[_6316 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                    _5871 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5871] = 26
                                    mem[_5871 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6317 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6317] = 26
                                    mem[_6317 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2c534595[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 10)
                            sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if idx >= sub_2c534595[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 10)
                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                            revert with 0, 17
                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                            if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                _6314 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6314] = 26
                                mem[_6314 + 32] = 'SafeMath: division by zero'
                            else:
                                if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6898 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6898] = 26
                                mem[_6898 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                        else:
                            if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                _6315 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6315] = 26
                                mem[_6315 + 32] = 'SafeMath: division by zero'
                            else:
                                if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6899 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6899] = 26
                                mem[_6899 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                    else:
                        if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                            mem[_4017 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                            mem[_4007] = _4017
                            mem[_4007 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4007 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4007 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4007 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4082 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4082] = 30
                                mem[_4082 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4119 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4119 + 68] = mem[idx + _4082 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4119 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4119 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4287 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4287] = 26
                                mem[_4287 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4380 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4380 + 68] = mem[idx + _4287 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4380 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4380 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5640 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5640] = 26
                                            mem[_5640 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5941 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5941] = 26
                                            mem[_5941 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5641 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5641] = 26
                                            mem[_5641 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5942 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5942] = 26
                                            mem[_5942 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5939 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5939] = 26
                                        mem[_5939 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6422 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6422] = 26
                                        mem[_6422 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5940 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5940] = 26
                                        mem[_5940 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6423 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6423] = 26
                                        mem[_6423 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4251 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4251] = 30
                            mem[_4251 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4334 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4334 + 68] = mem[idx + _4251 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4334 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4334 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4595 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4595] = 26
                            mem[_4595 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4679 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4679 + 68] = mem[idx + _4595 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4679 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4679 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _6003 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6003] = 26
                                        mem[_6003 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6534 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6534] = 26
                                        mem[_6534 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _6004 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6004] = 26
                                        mem[_6004 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6535 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6535] = 26
                                        mem[_6535 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6532 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6532] = 26
                                    mem[_6532 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7110 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7110] = 26
                                    mem[_7110 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6533 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6533] = 26
                                    mem[_6533 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7111 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7111] = 26
                                    mem[_7111 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_4017 + 32] = sub_2c534595[address(arg1)][idx].field_0
                            t = _4017 + 32
                            u = sha3(mem[0])
                            while _4017 + (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_4007] = _4017
                            mem[_4007 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4007 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4007 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4007 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _8142 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8142] = 30
                                mem[_8142 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _8306 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8306 + 68] = mem[idx + _8142 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8306 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8306 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _8366 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8366] = 26
                                mem[_8366 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8390 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8390 + 68] = mem[idx + _8366 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8390 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8390 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8814 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8814] = 26
                                            mem[_8814 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _8914 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8914] = 26
                                            mem[_8914 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8815 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8815] = 26
                                            mem[_8815 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _8915 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8915] = 26
                                            mem[_8915 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _8912 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8912] = 26
                                        mem[_8912 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9060 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9060] = 26
                                        mem[_9060 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _8913 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8913] = 26
                                        mem[_8913 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9061 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9061] = 26
                                        mem[_9061 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _8345 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8345] = 30
                            mem[_8345 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _8378 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _8378 + 68] = mem[idx + _8345 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8378 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _8378 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _8465 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8465] = 26
                            mem[_8465 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _8486 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _8486 + 68] = mem[idx + _8465 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8486 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _8486 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _8956 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8956] = 26
                                        mem[_8956 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9136 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9136] = 26
                                        mem[_9136 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _8957 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8957] = 26
                                        mem[_8957 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9137 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9137] = 26
                                        mem[_9137 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _9134 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9134] = 26
                                    mem[_9134 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _9308 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9308] = 26
                                    mem[_9308 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _9135 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9135] = 26
                                    mem[_9135 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _9309 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9309] = 26
                                    mem[_9309 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                else:
                    if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                        revert with 0, 34
                    if not sub_2c534595[address(arg1)][idx].field_1:
                        mem[_4007] = _4017
                        mem[_4007 + 32] = sub_2c534595[address(arg1)][idx].field_256
                        mem[_4007 + 64] = sub_2c534595[address(arg1)][idx].field_512
                        mem[_4007 + 96] = sub_2c534595[address(arg1)][idx].field_768
                        mem[_4007 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                        if -sub_2c534595[address(arg1)][idx].field_512:
                            _4065 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4065] = 30
                            mem[_4065 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                _4098 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4098 + 68] = mem[idx + _4065 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4098 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4098 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _4252 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4252] = 26
                            mem[_4252 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4335 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4335 + 68] = mem[idx + _4252 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4335 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4335 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5606 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5606] = 26
                                        mem[_5606 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5876 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5876] = 26
                                        mem[_5876 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5607 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5607] = 26
                                        mem[_5607 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5877 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5877] = 26
                                        mem[_5877 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                    _5874 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5874] = 26
                                    mem[_5874 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6322 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6322] = 26
                                    mem[_6322 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                    _5875 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5875] = 26
                                    mem[_5875 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6323 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6323] = 26
                                    mem[_6323 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2c534595[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 10)
                            sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        _4218 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4218] = 30
                        mem[_4218 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                            _4288 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4288 + 68] = mem[idx + _4218 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4288 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4288 + -mem[64] + 100
                        if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _4559 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4559] = 26
                        mem[_4559 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _4632 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4632 + 68] = mem[idx + _4559 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4632 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4632 + -mem[64] + 100
                        if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                            revert with 0, 17
                        if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -rewardPerNode:
                            if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                    _5943 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5943] = 26
                                    mem[_5943 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6432 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6432] = 26
                                    mem[_6432 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                    _5944 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5944] = 26
                                    mem[_5944 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6433 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6433] = 26
                                    mem[_6433 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2c534595[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 10)
                            sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if idx >= sub_2c534595[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 10)
                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                            revert with 0, 17
                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                            if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                _6430 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6430] = 26
                                mem[_6430 + 32] = 'SafeMath: division by zero'
                            else:
                                if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _7008 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7008] = 26
                                mem[_7008 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                        else:
                            if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                _6431 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6431] = 26
                                mem[_6431 + 32] = 'SafeMath: division by zero'
                            else:
                                if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _7009 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7009] = 26
                                mem[_7009 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                    else:
                        if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                            mem[_4017 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                            mem[_4007] = _4017
                            mem[_4007 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4007 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4007 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4007 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4100 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4100] = 30
                                mem[_4100 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4140 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4140 + 68] = mem[idx + _4100 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4140 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4140 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4336 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4336] = 26
                                mem[_4336 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4432 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4432 + 68] = mem[idx + _4336 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4432 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4432 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5676 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5676] = 26
                                            mem[_5676 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6010 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6010] = 26
                                            mem[_6010 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5677 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5677] = 26
                                            mem[_5677 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6011 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6011] = 26
                                            mem[_6011 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6008 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6008] = 26
                                        mem[_6008 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6538 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6538] = 26
                                        mem[_6538 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6009 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6009] = 26
                                        mem[_6009 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6539 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6539] = 26
                                        mem[_6539 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4291 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4291] = 30
                            mem[_4291 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4386 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4386 + 68] = mem[idx + _4291 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4386 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4386 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4634 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4634] = 26
                            mem[_4634 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4735 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4735 + 68] = mem[idx + _4634 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4735 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4735 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _6074 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6074] = 26
                                        mem[_6074 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6640 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6640] = 26
                                        mem[_6640 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _6075 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6075] = 26
                                        mem[_6075 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6641 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6641] = 26
                                        mem[_6641 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6638 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6638] = 26
                                    mem[_6638 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7224 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7224] = 26
                                    mem[_7224 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6639 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6639] = 26
                                    mem[_6639 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7225 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7225] = 26
                                    mem[_7225 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_4017 + 32] = sub_2c534595[address(arg1)][idx].field_0
                            t = _4017 + 32
                            u = sha3(mem[0])
                            while _4017 + sub_2c534595[address(arg1)][idx].field_1 > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_4007] = _4017
                            mem[_4007 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4007 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4007 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4007 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _8159 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8159] = 30
                                mem[_8159 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _8307 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8307 + 68] = mem[idx + _8159 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8307 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8307 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _8367 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8367] = 26
                                mem[_8367 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8391 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8391 + 68] = mem[idx + _8367 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8391 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8391 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8817 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8817] = 26
                                            mem[_8817 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _8918 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8918] = 26
                                            mem[_8918 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8818 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8818] = 26
                                            mem[_8818 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _8919 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8919] = 26
                                            mem[_8919 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _8916 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8916] = 26
                                        mem[_8916 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9066 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9066] = 26
                                        mem[_9066 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _8917 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8917] = 26
                                        mem[_8917 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9067 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9067] = 26
                                        mem[_9067 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _8347 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8347] = 30
                            mem[_8347 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _8379 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _8379 + 68] = mem[idx + _8347 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8379 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _8379 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _8467 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8467] = 26
                            mem[_8467 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _8487 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _8487 + 68] = mem[idx + _8467 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8487 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _8487 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _8958 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8958] = 26
                                        mem[_8958 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9142 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9142] = 26
                                        mem[_9142 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _8959 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8959] = 26
                                        mem[_8959 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9143 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9143] = 26
                                        mem[_9143 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _9140 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9140] = 26
                                    mem[_9140 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _9316 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9316] = 26
                                    mem[_9316 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _9141 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9141] = 26
                                    mem[_9141 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _9317 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9317] = 26
                                    mem[_9317 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
            if idx >= sub_2c534595[address(arg1)].field_0:
                revert with 0, 50
            sub_2c534595[address(arg1)][idx].field_768 = 0
            mem[0] = sha3(address(arg1), 10)
            sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            s = s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768
            continue 
    else:
        if msg.sender == gateKeeperAddress:
            mem[0] = arg1
            mem[32] = 10
            idx = 0
            s = 0
            while idx < sub_2c534595[address(arg1)].field_0:
                mem[0] = sha3(address(arg1), 10)
                _4010 = mem[64]
                mem[64] = mem[64] + 160
                if sub_2c534595[address(arg1)][idx].field_0:
                    if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    _4015 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) + 32
                    mem[_4015] = uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5
                    if sub_2c534595[address(arg1)][idx].field_0:
                        if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                            revert with 0, 34
                        if not Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                            mem[_4010] = _4015
                            mem[_4010 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4010 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4010 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4010 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4042 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4042] = 30
                                mem[_4042 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4067 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4067 + 68] = mem[idx + _4042 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4067 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4067 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4189 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4189] = 26
                                mem[_4189 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4254 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4254 + 68] = mem[idx + _4189 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4254 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4254 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5542 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5542] = 26
                                            mem[_5542 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5767 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5767] = 26
                                            mem[_5767 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5543 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5543] = 26
                                            mem[_5543 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5768 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5768] = 26
                                            mem[_5768 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5765 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5765] = 26
                                        mem[_5765 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6146 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6146] = 26
                                        mem[_6146 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5766 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5766] = 26
                                        mem[_5766 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6147 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6147] = 26
                                        mem[_6147 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4164 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4164] = 30
                            mem[_4164 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4220 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4220 + 68] = mem[idx + _4164 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4220 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4220 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4477 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4477] = 26
                            mem[_4477 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4563 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4563 + 68] = mem[idx + _4477 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4563 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4563 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5819 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5819] = 26
                                        mem[_5819 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6234 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6234] = 26
                                        mem[_6234 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5820 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5820] = 26
                                        mem[_5820 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6235 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6235] = 26
                                        mem[_6235 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6232 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6232] = 26
                                    mem[_6232 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6820 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6820] = 26
                                    mem[_6820 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6233 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6233] = 26
                                    mem[_6233 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6821 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6821] = 26
                                    mem[_6821 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                                mem[_4015 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                                mem[_4010] = _4015
                                mem[_4010 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4010 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4010 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4010 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _4069 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4069] = 30
                                    mem[_4069 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _4103 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4103 + 68] = mem[idx + _4069 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4103 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4103 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4255 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4255] = 26
                                    mem[_4255 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4339 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4339 + 68] = mem[idx + _4255 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4339 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4339 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5611 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5611] = 26
                                                mem[_5611 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5886 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5886] = 26
                                                mem[_5886 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5612 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5612] = 26
                                                mem[_5612 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5887 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5887] = 26
                                                mem[_5887 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5884 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5884] = 26
                                            mem[_5884 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6332 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6332] = 26
                                            mem[_6332 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5885 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5885] = 26
                                            mem[_5885 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6333 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6333] = 26
                                            mem[_6333 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _4223 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4223] = 30
                                mem[_4223 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _4297 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4297 + 68] = mem[idx + _4223 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4297 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4297 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4565 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4565] = 26
                                mem[_4565 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4640 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4640 + 68] = mem[idx + _4565 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4640 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4640 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5949 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5949] = 26
                                            mem[_5949 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6446 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6446] = 26
                                            mem[_6446 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5950 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5950] = 26
                                            mem[_5950 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6447 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6447] = 26
                                            mem[_6447 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6444 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6444] = 26
                                        mem[_6444 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7020 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7020] = 26
                                        mem[_7020 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6445 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6445] = 26
                                        mem[_6445 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7021 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7021] = 26
                                        mem[_7021 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                            else:
                                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_4015 + 32] = sub_2c534595[address(arg1)][idx].field_0
                                t = _4015 + 32
                                u = sha3(mem[0])
                                while _4015 + (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_4010] = _4015
                                mem[_4010 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4010 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4010 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4010 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _8176 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8176] = 30
                                    mem[_8176 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _8308 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _8308 + 68] = mem[idx + _8176 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8308 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8308 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _8368 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8368] = 26
                                    mem[_8368 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _8392 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _8392 + 68] = mem[idx + _8368 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8392 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8392 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8820 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8820] = 26
                                                mem[_8820 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8922 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8922] = 26
                                                mem[_8922 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8821 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8821] = 26
                                                mem[_8821 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8923 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8923] = 26
                                                mem[_8923 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8920 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8920] = 26
                                            mem[_8920 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9072 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9072] = 26
                                            mem[_9072 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8921 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8921] = 26
                                            mem[_8921 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9073 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9073] = 26
                                            mem[_9073 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _8349 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8349] = 30
                                mem[_8349 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _8380 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8380 + 68] = mem[idx + _8349 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8380 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8380 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _8469 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8469] = 26
                                mem[_8469 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8488 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8488 + 68] = mem[idx + _8469 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8488 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8488 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8960 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8960] = 26
                                            mem[_8960 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9148 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9148] = 26
                                            mem[_9148 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8961 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8961] = 26
                                            mem[_8961 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9149 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9149] = 26
                                            mem[_9149 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9146 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9146] = 26
                                        mem[_9146 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9324 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9324] = 26
                                        mem[_9324 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9147 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9147] = 26
                                        mem[_9147 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9325 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9325] = 26
                                        mem[_9325 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                    else:
                        if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                            revert with 0, 34
                        if not sub_2c534595[address(arg1)][idx].field_1:
                            mem[_4010] = _4015
                            mem[_4010 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4010 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4010 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4010 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4054 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4054] = 30
                                mem[_4054 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4083 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4083 + 68] = mem[idx + _4054 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4083 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4083 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4224 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4224] = 26
                                mem[_4224 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4298 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4298 + 68] = mem[idx + _4224 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4298 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4298 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5576 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5576] = 26
                                            mem[_5576 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5825 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5825] = 26
                                            mem[_5825 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5577 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5577] = 26
                                            mem[_5577 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5826 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5826] = 26
                                            mem[_5826 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5823 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5823] = 26
                                        mem[_5823 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6240 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6240] = 26
                                        mem[_6240 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5824 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5824] = 26
                                        mem[_5824 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6241 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6241] = 26
                                        mem[_6241 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4192 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4192] = 30
                            mem[_4192 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4256 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4256 + 68] = mem[idx + _4192 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4256 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4256 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4524 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4524] = 26
                            mem[_4524 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4601 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4601 + 68] = mem[idx + _4524 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4601 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4601 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5888 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5888] = 26
                                        mem[_5888 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6342 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6342] = 26
                                        mem[_6342 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5889 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5889] = 26
                                        mem[_5889 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6343 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6343] = 26
                                        mem[_6343 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6340 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6340] = 26
                                    mem[_6340 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6922 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6922] = 26
                                    mem[_6922 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6341 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6341] = 26
                                    mem[_6341 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6923 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6923] = 26
                                    mem[_6923 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                                mem[_4015 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                                mem[_4010] = _4015
                                mem[_4010 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4010 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4010 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4010 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _4085 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4085] = 30
                                    mem[_4085 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _4123 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4123 + 68] = mem[idx + _4085 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4123 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4123 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4299 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4299] = 26
                                    mem[_4299 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4393 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4393 + 68] = mem[idx + _4299 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4393 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4393 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5647 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5647] = 26
                                                mem[_5647 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5956 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5956] = 26
                                                mem[_5956 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5648 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5648] = 26
                                                mem[_5648 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5957 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5957] = 26
                                                mem[_5957 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5954 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5954] = 26
                                            mem[_5954 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6450 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6450] = 26
                                            mem[_6450 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5955 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5955] = 26
                                            mem[_5955 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6451 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6451] = 26
                                            mem[_6451 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _4259 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4259] = 30
                                mem[_4259 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _4345 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4345 + 68] = mem[idx + _4259 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4345 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4345 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4603 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4603] = 26
                                mem[_4603 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4691 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4691 + 68] = mem[idx + _4603 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4691 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4691 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6020 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6020] = 26
                                            mem[_6020 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6558 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6558] = 26
                                            mem[_6558 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6021 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6021] = 26
                                            mem[_6021 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6559 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6559] = 26
                                            mem[_6559 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6556 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6556] = 26
                                        mem[_6556 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7136 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7136] = 26
                                        mem[_7136 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6557 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6557] = 26
                                        mem[_6557 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7137 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7137] = 26
                                        mem[_7137 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                            else:
                                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_4015 + 32] = sub_2c534595[address(arg1)][idx].field_0
                                t = _4015 + 32
                                u = sha3(mem[0])
                                while _4015 + sub_2c534595[address(arg1)][idx].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_4010] = _4015
                                mem[_4010 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4010 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4010 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4010 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _8193 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8193] = 30
                                    mem[_8193 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _8309 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _8309 + 68] = mem[idx + _8193 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8309 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8309 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _8369 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8369] = 26
                                    mem[_8369 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _8393 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _8393 + 68] = mem[idx + _8369 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8393 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8393 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8823 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8823] = 26
                                                mem[_8823 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8926 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8926] = 26
                                                mem[_8926 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8824 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8824] = 26
                                                mem[_8824 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8927 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8927] = 26
                                                mem[_8927 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8924 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8924] = 26
                                            mem[_8924 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9078 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9078] = 26
                                            mem[_9078 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8925 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8925] = 26
                                            mem[_8925 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9079 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9079] = 26
                                            mem[_9079 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _8351 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8351] = 30
                                mem[_8351 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _8381 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8381 + 68] = mem[idx + _8351 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8381 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8381 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _8471 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8471] = 26
                                mem[_8471 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8489 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8489 + 68] = mem[idx + _8471 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8489 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8489 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8962 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8962] = 26
                                            mem[_8962 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9154 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9154] = 26
                                            mem[_9154 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8963 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8963] = 26
                                            mem[_8963 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9155 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9155] = 26
                                            mem[_9155 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9152 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9152] = 26
                                        mem[_9152 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9332 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9332] = 26
                                        mem[_9332 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9153 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9153] = 26
                                        mem[_9153 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9333 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9333] = 26
                                        mem[_9333 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                else:
                    if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                        revert with 0, 34
                    _4018 = mem[64]
                    mem[64] = mem[64] + ceil32(sub_2c534595[address(arg1)][idx].field_1) + 32
                    mem[_4018] = sub_2c534595[address(arg1)][idx].field_1
                    if sub_2c534595[address(arg1)][idx].field_0:
                        if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                            revert with 0, 34
                        if not Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                            mem[_4010] = _4018
                            mem[_4010 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4010 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4010 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4010 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4056 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4056] = 30
                                mem[_4056 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4086 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4086 + 68] = mem[idx + _4056 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4086 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4086 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4226 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4226] = 26
                                mem[_4226 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4300 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4300 + 68] = mem[idx + _4226 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4300 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4300 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5580 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5580] = 26
                                            mem[_5580 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5832 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5832] = 26
                                            mem[_5832 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5581 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5581] = 26
                                            mem[_5581 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5833 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5833] = 26
                                            mem[_5833 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5830 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5830] = 26
                                        mem[_5830 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6248 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6248] = 26
                                        mem[_6248 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5831 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5831] = 26
                                        mem[_5831 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6249 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6249] = 26
                                        mem[_6249 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4195 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4195] = 30
                            mem[_4195 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4260 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4260 + 68] = mem[idx + _4195 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4260 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4260 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4529 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4529] = 26
                            mem[_4529 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4604 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4604 + 68] = mem[idx + _4529 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4604 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4604 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5892 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5892] = 26
                                        mem[_5892 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6352 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6352] = 26
                                        mem[_6352 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5893 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5893] = 26
                                        mem[_5893 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6353 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6353] = 26
                                        mem[_6353 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6350 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6350] = 26
                                    mem[_6350 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6932 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6932] = 26
                                    mem[_6932 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6351 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6351] = 26
                                    mem[_6351 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6933 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6933] = 26
                                    mem[_6933 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                                mem[_4018 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                                mem[_4010] = _4018
                                mem[_4010 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4010 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4010 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4010 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _4088 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4088] = 30
                                    mem[_4088 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _4126 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4126 + 68] = mem[idx + _4088 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4126 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4126 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4301 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4301] = 26
                                    mem[_4301 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4396 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4396 + 68] = mem[idx + _4301 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4396 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4396 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5651 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5651] = 26
                                                mem[_5651 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5963 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5963] = 26
                                                mem[_5963 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5652 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5652] = 26
                                                mem[_5652 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5964 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5964] = 26
                                                mem[_5964 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5961 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5961] = 26
                                            mem[_5961 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6458 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6458] = 26
                                            mem[_6458 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5962 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5962] = 26
                                            mem[_5962 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6459 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6459] = 26
                                            mem[_6459 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _4263 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4263] = 30
                                mem[_4263 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _4351 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4351 + 68] = mem[idx + _4263 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4351 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4351 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4606 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4606] = 26
                                mem[_4606 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4697 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4697 + 68] = mem[idx + _4606 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4697 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4697 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6024 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6024] = 26
                                            mem[_6024 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6568 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6568] = 26
                                            mem[_6568 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6025 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6025] = 26
                                            mem[_6025 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6569 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6569] = 26
                                            mem[_6569 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6566 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6566] = 26
                                        mem[_6566 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7146 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7146] = 26
                                        mem[_7146 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6567 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6567] = 26
                                        mem[_6567 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7147 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7147] = 26
                                        mem[_7147 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                            else:
                                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_4018 + 32] = sub_2c534595[address(arg1)][idx].field_0
                                t = _4018 + 32
                                u = sha3(mem[0])
                                while _4018 + (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_4010] = _4018
                                mem[_4010 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4010 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4010 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4010 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _8210 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8210] = 30
                                    mem[_8210 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _8310 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _8310 + 68] = mem[idx + _8210 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8310 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8310 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _8370 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8370] = 26
                                    mem[_8370 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _8394 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _8394 + 68] = mem[idx + _8370 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8394 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8394 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8826 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8826] = 26
                                                mem[_8826 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8930 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8930] = 26
                                                mem[_8930 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8827 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8827] = 26
                                                mem[_8827 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8931 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8931] = 26
                                                mem[_8931 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8928 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8928] = 26
                                            mem[_8928 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9084 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9084] = 26
                                            mem[_9084 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8929 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8929] = 26
                                            mem[_8929 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9085 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9085] = 26
                                            mem[_9085 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _8353 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8353] = 30
                                mem[_8353 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _8382 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8382 + 68] = mem[idx + _8353 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8382 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8382 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _8473 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8473] = 26
                                mem[_8473 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8490 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8490 + 68] = mem[idx + _8473 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8490 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8490 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8964 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8964] = 26
                                            mem[_8964 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9160 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9160] = 26
                                            mem[_9160 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8965 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8965] = 26
                                            mem[_8965 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9161 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9161] = 26
                                            mem[_9161 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9158 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9158] = 26
                                        mem[_9158 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9340 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9340] = 26
                                        mem[_9340 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9159 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9159] = 26
                                        mem[_9159 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9341 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9341] = 26
                                        mem[_9341 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                    else:
                        if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                            revert with 0, 34
                        if not sub_2c534595[address(arg1)][idx].field_1:
                            mem[_4010] = _4018
                            mem[_4010 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4010 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4010 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4010 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4070 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4070] = 30
                                mem[_4070 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4104 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4104 + 68] = mem[idx + _4070 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4104 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4104 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4264 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4264] = 26
                                mem[_4264 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4352 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4352 + 68] = mem[idx + _4264 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4352 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4352 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5618 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5618] = 26
                                            mem[_5618 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5898 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5898] = 26
                                            mem[_5898 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5619 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5619] = 26
                                            mem[_5619 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5899 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5899] = 26
                                            mem[_5899 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5896 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5896] = 26
                                        mem[_5896 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6358 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6358] = 26
                                        mem[_6358 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5897 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5897] = 26
                                        mem[_5897 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6359 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6359] = 26
                                        mem[_6359 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4229 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4229] = 30
                            mem[_4229 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4302 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4302 + 68] = mem[idx + _4229 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4302 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4302 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4571 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4571] = 26
                            mem[_4571 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4647 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4647 + 68] = mem[idx + _4571 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4647 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4647 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5965 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5965] = 26
                                        mem[_5965 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6468 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6468] = 26
                                        mem[_6468 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5966 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5966] = 26
                                        mem[_5966 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6469 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6469] = 26
                                        mem[_6469 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6466 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6466] = 26
                                    mem[_6466 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7044 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7044] = 26
                                    mem[_7044 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6467 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6467] = 26
                                    mem[_6467 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7045 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7045] = 26
                                    mem[_7045 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                                mem[_4018 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                                mem[_4010] = _4018
                                mem[_4010 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4010 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4010 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4010 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _4106 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4106] = 30
                                    mem[_4106 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _4147 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4147 + 68] = mem[idx + _4106 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4147 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4147 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4353 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4353] = 26
                                    mem[_4353 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4446 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4446 + 68] = mem[idx + _4353 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4446 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4446 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5688 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5688] = 26
                                                mem[_5688 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _6031 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_6031] = 26
                                                mem[_6031 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5689 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5689] = 26
                                                mem[_5689 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _6032 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_6032] = 26
                                                mem[_6032 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _6029 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6029] = 26
                                            mem[_6029 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6572 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6572] = 26
                                            mem[_6572 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _6030 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6030] = 26
                                            mem[_6030 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6573 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6573] = 26
                                            mem[_6573 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _4305 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4305] = 30
                                mem[_4305 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _4402 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4402 + 68] = mem[idx + _4305 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4402 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4402 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4649 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4649] = 26
                                mem[_4649 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4752 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4752 + 68] = mem[idx + _4649 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4752 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4752 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6096 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6096] = 26
                                            mem[_6096 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6670 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6670] = 26
                                            mem[_6670 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6097 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6097] = 26
                                            mem[_6097 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6671 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6671] = 26
                                            mem[_6671 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6668 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6668] = 26
                                        mem[_6668 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7258 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7258] = 26
                                        mem[_7258 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6669 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6669] = 26
                                        mem[_6669 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7259 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7259] = 26
                                        mem[_7259 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                            else:
                                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_4018 + 32] = sub_2c534595[address(arg1)][idx].field_0
                                t = _4018 + 32
                                u = sha3(mem[0])
                                while _4018 + sub_2c534595[address(arg1)][idx].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_4010] = _4018
                                mem[_4010 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4010 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4010 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4010 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _8227 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8227] = 30
                                    mem[_8227 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _8311 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _8311 + 68] = mem[idx + _8227 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8311 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8311 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _8371 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8371] = 26
                                    mem[_8371 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _8395 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _8395 + 68] = mem[idx + _8371 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8395 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8395 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8829 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8829] = 26
                                                mem[_8829 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8934 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8934] = 26
                                                mem[_8934 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8830 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8830] = 26
                                                mem[_8830 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8935 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8935] = 26
                                                mem[_8935 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8932 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8932] = 26
                                            mem[_8932 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9090 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9090] = 26
                                            mem[_9090 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8933 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8933] = 26
                                            mem[_8933 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9091 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9091] = 26
                                            mem[_9091 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _8355 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8355] = 30
                                mem[_8355 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _8383 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8383 + 68] = mem[idx + _8355 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8383 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8383 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _8475 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8475] = 26
                                mem[_8475 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8491 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8491 + 68] = mem[idx + _8475 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8491 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8491 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8966 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8966] = 26
                                            mem[_8966 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9166 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9166] = 26
                                            mem[_9166 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8967 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8967] = 26
                                            mem[_8967 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9167 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9167] = 26
                                            mem[_9167 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9164 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9164] = 26
                                        mem[_9164 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9348 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9348] = 26
                                        mem[_9348 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9165 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9165] = 26
                                        mem[_9165 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9349 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9349] = 26
                                        mem[_9349 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                if idx >= sub_2c534595[address(arg1)].field_0:
                    revert with 0, 50
                sub_2c534595[address(arg1)][idx].field_768 = 0
                mem[0] = sha3(address(arg1), 10)
                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768
                continue 
        else:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
            mem[0] = arg1
            mem[32] = 10
            idx = 0
            s = 0
            while idx < sub_2c534595[address(arg1)].field_0:
                mem[0] = sha3(address(arg1), 10)
                _4013 = mem[64]
                mem[64] = mem[64] + 160
                if sub_2c534595[address(arg1)][idx].field_0:
                    if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    _4016 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) + 32
                    mem[_4016] = uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5
                    if sub_2c534595[address(arg1)][idx].field_0:
                        if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                            revert with 0, 34
                        if not Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                            mem[_4013] = _4016
                            mem[_4013 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4013 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4013 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4013 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4046 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4046] = 30
                                mem[_4046 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4072 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4072 + 68] = mem[idx + _4046 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4072 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4072 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4199 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4199] = 26
                                mem[_4199 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4266 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4266 + 68] = mem[idx + _4199 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4266 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4266 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5552 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5552] = 26
                                            mem[_5552 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5784 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5784] = 26
                                            mem[_5784 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5553 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5553] = 26
                                            mem[_5553 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5785 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5785] = 26
                                            mem[_5785 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5782 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5782] = 26
                                        mem[_5782 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6172 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6172] = 26
                                        mem[_6172 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5783 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5783] = 26
                                        mem[_5783 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6173 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6173] = 26
                                        mem[_6173 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4172 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4172] = 30
                            mem[_4172 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4231 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4231 + 68] = mem[idx + _4172 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4231 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4231 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4492 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4492] = 26
                            mem[_4492 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4575 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4575 + 68] = mem[idx + _4492 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4575 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4575 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5839 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5839] = 26
                                        mem[_5839 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6266 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6266] = 26
                                        mem[_6266 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5840 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5840] = 26
                                        mem[_5840 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6267 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6267] = 26
                                        mem[_6267 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6264 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6264] = 26
                                    mem[_6264 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6850 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6850] = 26
                                    mem[_6850 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6265 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6265] = 26
                                    mem[_6265 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6851 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6851] = 26
                                    mem[_6851 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                                mem[_4016 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                                mem[_4013] = _4016
                                mem[_4013 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4013 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4013 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4013 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _4074 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4074] = 30
                                    mem[_4074 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _4109 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4109 + 68] = mem[idx + _4074 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4109 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4109 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4267 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4267] = 26
                                    mem[_4267 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4356 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4356 + 68] = mem[idx + _4267 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4356 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4356 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5623 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5623] = 26
                                                mem[_5623 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5908 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5908] = 26
                                                mem[_5908 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5624 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5624] = 26
                                                mem[_5624 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5909 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5909] = 26
                                                mem[_5909 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5906 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5906] = 26
                                            mem[_5906 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6368 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6368] = 26
                                            mem[_6368 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5907 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5907] = 26
                                            mem[_5907 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6369 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6369] = 26
                                            mem[_6369 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _4234 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4234] = 30
                                mem[_4234 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _4311 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4311 + 68] = mem[idx + _4234 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4311 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4311 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4577 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4577] = 26
                                mem[_4577 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4655 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4655 + 68] = mem[idx + _4577 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4655 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4655 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5971 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5971] = 26
                                            mem[_5971 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6482 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6482] = 26
                                            mem[_6482 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5972 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5972] = 26
                                            mem[_5972 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6483 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6483] = 26
                                            mem[_6483 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6480 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6480] = 26
                                        mem[_6480 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7056 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7056] = 26
                                        mem[_7056 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6481 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6481] = 26
                                        mem[_6481 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7057 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7057] = 26
                                        mem[_7057 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                            else:
                                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_4016 + 32] = sub_2c534595[address(arg1)][idx].field_0
                                t = _4016 + 32
                                u = sha3(mem[0])
                                while _4016 + (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_4013] = _4016
                                mem[_4013 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4013 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4013 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4013 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _8244 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8244] = 30
                                    mem[_8244 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _8312 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _8312 + 68] = mem[idx + _8244 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8312 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8312 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _8372 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8372] = 26
                                    mem[_8372 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _8396 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _8396 + 68] = mem[idx + _8372 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8396 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8396 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8832 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8832] = 26
                                                mem[_8832 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8938 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8938] = 26
                                                mem[_8938 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8833 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8833] = 26
                                                mem[_8833 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8939 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8939] = 26
                                                mem[_8939 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8936 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8936] = 26
                                            mem[_8936 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9096 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9096] = 26
                                            mem[_9096 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8937 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8937] = 26
                                            mem[_8937 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9097 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9097] = 26
                                            mem[_9097 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _8357 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8357] = 30
                                mem[_8357 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _8384 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8384 + 68] = mem[idx + _8357 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8384 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8384 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _8477 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8477] = 26
                                mem[_8477 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8492 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8492 + 68] = mem[idx + _8477 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8492 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8492 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8968 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8968] = 26
                                            mem[_8968 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9172 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9172] = 26
                                            mem[_9172 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8969 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8969] = 26
                                            mem[_8969 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9173 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9173] = 26
                                            mem[_9173 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9170 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9170] = 26
                                        mem[_9170 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9356 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9356] = 26
                                        mem[_9356 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9171 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9171] = 26
                                        mem[_9171 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9357 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9357] = 26
                                        mem[_9357 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                    else:
                        if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                            revert with 0, 34
                        if not sub_2c534595[address(arg1)][idx].field_1:
                            mem[_4013] = _4016
                            mem[_4013 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4013 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4013 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4013 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4058 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4058] = 30
                                mem[_4058 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4089 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4089 + 68] = mem[idx + _4058 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4089 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4089 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4235 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4235] = 26
                                mem[_4235 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4312 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4312 + 68] = mem[idx + _4235 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4312 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4312 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5588 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5588] = 26
                                            mem[_5588 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5845 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5845] = 26
                                            mem[_5845 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5589 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5589] = 26
                                            mem[_5589 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5846 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5846] = 26
                                            mem[_5846 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5843 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5843] = 26
                                        mem[_5843 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6272 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6272] = 26
                                        mem[_6272 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5844 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5844] = 26
                                        mem[_5844 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6273 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6273] = 26
                                        mem[_6273 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4202 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4202] = 30
                            mem[_4202 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4268 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4268 + 68] = mem[idx + _4202 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4268 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4268 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4539 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4539] = 26
                            mem[_4539 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4612 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4612 + 68] = mem[idx + _4539 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4612 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4612 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5910 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5910] = 26
                                        mem[_5910 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6378 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6378] = 26
                                        mem[_6378 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5911 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5911] = 26
                                        mem[_5911 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6379 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6379] = 26
                                        mem[_6379 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6376 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6376] = 26
                                    mem[_6376 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6956 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6956] = 26
                                    mem[_6956 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6377 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6377] = 26
                                    mem[_6377 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6957 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6957] = 26
                                    mem[_6957 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                                mem[_4016 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                                mem[_4013] = _4016
                                mem[_4013 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4013 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4013 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4013 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _4091 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4091] = 30
                                    mem[_4091 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _4130 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4130 + 68] = mem[idx + _4091 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4130 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4130 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4313 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4313] = 26
                                    mem[_4313 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4409 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4409 + 68] = mem[idx + _4313 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4409 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4409 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5658 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5658] = 26
                                                mem[_5658 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5978 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5978] = 26
                                                mem[_5978 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5659 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5659] = 26
                                                mem[_5659 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5979 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5979] = 26
                                                mem[_5979 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5976 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5976] = 26
                                            mem[_5976 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6486 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6486] = 26
                                            mem[_6486 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5977 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5977] = 26
                                            mem[_5977 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6487 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6487] = 26
                                            mem[_6487 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _4271 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4271] = 30
                                mem[_4271 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _4362 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4362 + 68] = mem[idx + _4271 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4362 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4362 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4614 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4614] = 26
                                mem[_4614 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4709 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4709 + 68] = mem[idx + _4614 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4709 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4709 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6041 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6041] = 26
                                            mem[_6041 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6592 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6592] = 26
                                            mem[_6592 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6042 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6042] = 26
                                            mem[_6042 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6593 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6593] = 26
                                            mem[_6593 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6590 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6590] = 26
                                        mem[_6590 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7172 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7172] = 26
                                        mem[_7172 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6591 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6591] = 26
                                        mem[_6591 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7173 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7173] = 26
                                        mem[_7173 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                            else:
                                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_4016 + 32] = sub_2c534595[address(arg1)][idx].field_0
                                t = _4016 + 32
                                u = sha3(mem[0])
                                while _4016 + sub_2c534595[address(arg1)][idx].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_4013] = _4016
                                mem[_4013 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4013 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4013 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4013 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _8261 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8261] = 30
                                    mem[_8261 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _8313 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _8313 + 68] = mem[idx + _8261 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8313 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8313 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _8373 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8373] = 26
                                    mem[_8373 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _8397 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _8397 + 68] = mem[idx + _8373 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8397 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8397 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8835 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8835] = 26
                                                mem[_8835 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8942 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8942] = 26
                                                mem[_8942 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8836 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8836] = 26
                                                mem[_8836 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8943 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8943] = 26
                                                mem[_8943 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8940 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8940] = 26
                                            mem[_8940 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9102 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9102] = 26
                                            mem[_9102 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8941 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8941] = 26
                                            mem[_8941 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9103 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9103] = 26
                                            mem[_9103 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _8359 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8359] = 30
                                mem[_8359 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _8385 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8385 + 68] = mem[idx + _8359 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8385 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8385 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _8479 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8479] = 26
                                mem[_8479 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8493 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8493 + 68] = mem[idx + _8479 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8493 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8493 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8970 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8970] = 26
                                            mem[_8970 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9178 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9178] = 26
                                            mem[_9178 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8971 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8971] = 26
                                            mem[_8971 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9179 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9179] = 26
                                            mem[_9179 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9176 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9176] = 26
                                        mem[_9176 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9364 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9364] = 26
                                        mem[_9364 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9177 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9177] = 26
                                        mem[_9177 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9365 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9365] = 26
                                        mem[_9365 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                else:
                    if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                        revert with 0, 34
                    _4019 = mem[64]
                    mem[64] = mem[64] + ceil32(sub_2c534595[address(arg1)][idx].field_1) + 32
                    mem[_4019] = sub_2c534595[address(arg1)][idx].field_1
                    if sub_2c534595[address(arg1)][idx].field_0:
                        if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                            revert with 0, 34
                        if not Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                            mem[_4013] = _4019
                            mem[_4013 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4013 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4013 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4013 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4060 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4060] = 30
                                mem[_4060 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4092 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4092 + 68] = mem[idx + _4060 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4092 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4092 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4237 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4237] = 26
                                mem[_4237 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4314 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4314 + 68] = mem[idx + _4237 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4314 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4314 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5592 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5592] = 26
                                            mem[_5592 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5852 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5852] = 26
                                            mem[_5852 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5593 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5593] = 26
                                            mem[_5593 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5853 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5853] = 26
                                            mem[_5853 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5850 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5850] = 26
                                        mem[_5850 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6280 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6280] = 26
                                        mem[_6280 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5851 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5851] = 26
                                        mem[_5851 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6281 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6281] = 26
                                        mem[_6281 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4205 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4205] = 30
                            mem[_4205 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4272 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4272 + 68] = mem[idx + _4205 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4272 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4272 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4544 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4544] = 26
                            mem[_4544 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4615 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4615 + 68] = mem[idx + _4544 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4615 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4615 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5914 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5914] = 26
                                        mem[_5914 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6388 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6388] = 26
                                        mem[_6388 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5915 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5915] = 26
                                        mem[_5915 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6389 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6389] = 26
                                        mem[_6389 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6386 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6386] = 26
                                    mem[_6386 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6966 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6966] = 26
                                    mem[_6966 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6387 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6387] = 26
                                    mem[_6387 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6967 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6967] = 26
                                    mem[_6967 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                                mem[_4019 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                                mem[_4013] = _4019
                                mem[_4013 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4013 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4013 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4013 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _4094 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4094] = 30
                                    mem[_4094 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _4133 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4133 + 68] = mem[idx + _4094 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4133 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4133 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4315 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4315] = 26
                                    mem[_4315 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4412 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4412 + 68] = mem[idx + _4315 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4412 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4412 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5662 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5662] = 26
                                                mem[_5662 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5985 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5985] = 26
                                                mem[_5985 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5663 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5663] = 26
                                                mem[_5663 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5986 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5986] = 26
                                                mem[_5986 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5983 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5983] = 26
                                            mem[_5983 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6494 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6494] = 26
                                            mem[_6494 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5984 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5984] = 26
                                            mem[_5984 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6495 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6495] = 26
                                            mem[_6495 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _4275 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4275] = 30
                                mem[_4275 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _4368 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4368 + 68] = mem[idx + _4275 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4368 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4368 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4617 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4617] = 26
                                mem[_4617 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4715 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4715 + 68] = mem[idx + _4617 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4715 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4715 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6045 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6045] = 26
                                            mem[_6045 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6602 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6602] = 26
                                            mem[_6602 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6046 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6046] = 26
                                            mem[_6046 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6603 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6603] = 26
                                            mem[_6603 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6600 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6600] = 26
                                        mem[_6600 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7182 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7182] = 26
                                        mem[_7182 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6601 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6601] = 26
                                        mem[_6601 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7183 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7183] = 26
                                        mem[_7183 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                            else:
                                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_4019 + 32] = sub_2c534595[address(arg1)][idx].field_0
                                t = _4019 + 32
                                u = sha3(mem[0])
                                while _4019 + (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_4013] = _4019
                                mem[_4013 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4013 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4013 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4013 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _8278 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8278] = 30
                                    mem[_8278 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _8314 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _8314 + 68] = mem[idx + _8278 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8314 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8314 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _8374 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8374] = 26
                                    mem[_8374 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _8398 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _8398 + 68] = mem[idx + _8374 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8398 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8398 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8838 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8838] = 26
                                                mem[_8838 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8946 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8946] = 26
                                                mem[_8946 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8839 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8839] = 26
                                                mem[_8839 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8947 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8947] = 26
                                                mem[_8947 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8944 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8944] = 26
                                            mem[_8944 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9108 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9108] = 26
                                            mem[_9108 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8945 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8945] = 26
                                            mem[_8945 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9109 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9109] = 26
                                            mem[_9109 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _8361 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8361] = 30
                                mem[_8361 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _8386 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8386 + 68] = mem[idx + _8361 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8386 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8386 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _8481 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8481] = 26
                                mem[_8481 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8494 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8494 + 68] = mem[idx + _8481 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8494 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8494 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8972 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8972] = 26
                                            mem[_8972 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9184 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9184] = 26
                                            mem[_9184 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8973 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8973] = 26
                                            mem[_8973 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9185 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9185] = 26
                                            mem[_9185 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9182 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9182] = 26
                                        mem[_9182 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9372 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9372] = 26
                                        mem[_9372 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9183 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9183] = 26
                                        mem[_9183 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9373 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9373] = 26
                                        mem[_9373 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                    else:
                        if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                            revert with 0, 34
                        if not sub_2c534595[address(arg1)][idx].field_1:
                            mem[_4013] = _4019
                            mem[_4013 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4013 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4013 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4013 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4075 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4075] = 30
                                mem[_4075 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4110 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4110 + 68] = mem[idx + _4075 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4110 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4110 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4276 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4276] = 26
                                mem[_4276 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4369 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4369 + 68] = mem[idx + _4276 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4369 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4369 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5630 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5630] = 26
                                            mem[_5630 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5920 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5920] = 26
                                            mem[_5920 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5631 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5631] = 26
                                            mem[_5631 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5921 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5921] = 26
                                            mem[_5921 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5918 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5918] = 26
                                        mem[_5918 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6394 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6394] = 26
                                        mem[_6394 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5919 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5919] = 26
                                        mem[_5919 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6395 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6395] = 26
                                        mem[_6395 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4240 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4240] = 30
                            mem[_4240 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4316 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4316 + 68] = mem[idx + _4240 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4316 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4316 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4583 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4583] = 26
                            mem[_4583 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4662 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4662 + 68] = mem[idx + _4583 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4662 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4662 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5987 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5987] = 26
                                        mem[_5987 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6504 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6504] = 26
                                        mem[_6504 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5988 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5988] = 26
                                        mem[_5988 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6505 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6505] = 26
                                        mem[_6505 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6502 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6502] = 26
                                    mem[_6502 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7080 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7080] = 26
                                    mem[_7080 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6503 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6503] = 26
                                    mem[_6503 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7081 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7081] = 26
                                    mem[_7081 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                                mem[_4019 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                                mem[_4013] = _4019
                                mem[_4013 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4013 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4013 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4013 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _4112 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4112] = 30
                                    mem[_4112 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _4154 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4154 + 68] = mem[idx + _4112 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4154 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4154 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4370 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4370] = 26
                                    mem[_4370 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4460 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4460 + 68] = mem[idx + _4370 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4460 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4460 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5700 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5700] = 26
                                                mem[_5700 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _6052 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_6052] = 26
                                                mem[_6052 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5701 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5701] = 26
                                                mem[_5701 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _6053 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_6053] = 26
                                                mem[_6053 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _6050 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6050] = 26
                                            mem[_6050 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6606 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6606] = 26
                                            mem[_6606 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _6051 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6051] = 26
                                            mem[_6051 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6607 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6607] = 26
                                            mem[_6607 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _4319 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4319] = 30
                                mem[_4319 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _4418 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4418 + 68] = mem[idx + _4319 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4418 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4418 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4664 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4664] = 26
                                mem[_4664 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4769 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4769 + 68] = mem[idx + _4664 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4769 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4769 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6118 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6118] = 26
                                            mem[_6118 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6700 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6700] = 26
                                            mem[_6700 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6119 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6119] = 26
                                            mem[_6119 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6701 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6701] = 26
                                            mem[_6701 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6698 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6698] = 26
                                        mem[_6698 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7292 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7292] = 26
                                        mem[_7292 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6699 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6699] = 26
                                        mem[_6699 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7293 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7293] = 26
                                        mem[_7293 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                            else:
                                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_4019 + 32] = sub_2c534595[address(arg1)][idx].field_0
                                t = _4019 + 32
                                u = sha3(mem[0])
                                while _4019 + sub_2c534595[address(arg1)][idx].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_4013] = _4019
                                mem[_4013 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4013 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4013 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4013 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _8295 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8295] = 30
                                    mem[_8295 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _8315 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _8315 + 68] = mem[idx + _8295 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8315 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8315 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _8375 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8375] = 26
                                    mem[_8375 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _8399 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _8399 + 68] = mem[idx + _8375 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8399 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8399 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8841 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8841] = 26
                                                mem[_8841 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8950 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8950] = 26
                                                mem[_8950 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8842 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8842] = 26
                                                mem[_8842 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8951 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8951] = 26
                                                mem[_8951 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8948 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8948] = 26
                                            mem[_8948 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9114 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9114] = 26
                                            mem[_9114 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8949 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8949] = 26
                                            mem[_8949 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9115 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9115] = 26
                                            mem[_9115 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _8363 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8363] = 30
                                mem[_8363 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _8387 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8387 + 68] = mem[idx + _8363 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8387 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8387 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _8483 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8483] = 26
                                mem[_8483 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8495 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8495 + 68] = mem[idx + _8483 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8495 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8495 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8974 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8974] = 26
                                            mem[_8974 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9190 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9190] = 26
                                            mem[_9190 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8975 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8975] = 26
                                            mem[_8975 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9191 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9191] = 26
                                            mem[_9191 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9188 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9188] = 26
                                        mem[_9188 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9380 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9380] = 26
                                        mem[_9380 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9189 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9189] = 26
                                        mem[_9189 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9381 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9381] = 26
                                        mem[_9381 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                if idx >= sub_2c534595[address(arg1)].field_0:
                    revert with 0, 50
                sub_2c534595[address(arg1)][idx].field_768 = 0
                mem[0] = sha3(address(arg1), 10)
                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768
                continue 
    return s, 0
}

function sub_9631b48a(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == uint32(arg2)
    if msg.sender == tokenAddress:
        mem[0] = address(arg1)
        mem[32] = 10
        idx = 0
        s = 0
        while idx < sub_2c534595[address(arg1)].field_0:
            mem[0] = sha3(address(arg1), 10)
            if sub_2c534595[address(arg1)][idx].field_1024 - uint32(arg2):
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = s
                continue 
            if idx >= sub_2c534595[address(arg1)].field_0:
                revert with 0, 50
            mem[0] = sha3(address(arg1), 10)
            _4015 = mem[64]
            mem[64] = mem[64] + 160
            if sub_2c534595[address(arg1)][idx].field_0:
                if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                    revert with 0, 34
                _4020 = mem[64]
                mem[64] = mem[64] + ceil32(uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) + 32
                mem[_4020] = uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5
                if sub_2c534595[address(arg1)][idx].field_0:
                    if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    if not Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                        mem[_4015] = _4020
                        mem[_4015 + 32] = sub_2c534595[address(arg1)][idx].field_256
                        mem[_4015 + 64] = sub_2c534595[address(arg1)][idx].field_512
                        mem[_4015 + 96] = sub_2c534595[address(arg1)][idx].field_768
                        mem[_4015 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                        if -sub_2c534595[address(arg1)][idx].field_512:
                            _4044 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4044] = 30
                            mem[_4044 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                _4068 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4068 + 68] = mem[idx + _4044 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4068 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4068 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _4185 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4185] = 26
                            mem[_4185 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4248 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4248 + 68] = mem[idx + _4185 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4248 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4248 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5538 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5538] = 26
                                        mem[_5538 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5756 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5756] = 26
                                        mem[_5756 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5539 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5539] = 26
                                        mem[_5539 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5757 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5757] = 26
                                        mem[_5757 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                    _5754 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5754] = 26
                                    mem[_5754 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6126 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6126] = 26
                                    mem[_6126 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                    _5755 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5755] = 26
                                    mem[_5755 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6127 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6127] = 26
                                    mem[_6127 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2c534595[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 10)
                            sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        _4162 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4162] = 30
                        mem[_4162 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                            _4215 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4215 + 68] = mem[idx + _4162 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4215 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4215 + -mem[64] + 100
                        if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _4468 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4468] = 26
                        mem[_4468 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _4557 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4557 + 68] = mem[idx + _4468 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4557 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4557 + -mem[64] + 100
                        if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                            revert with 0, 17
                        if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -rewardPerNode:
                            if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                    _5805 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5805] = 26
                                    mem[_5805 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6208 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6208] = 26
                                    mem[_6208 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                    _5806 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5806] = 26
                                    mem[_5806 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6209 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6209] = 26
                                    mem[_6209 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2c534595[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 10)
                            sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if idx >= sub_2c534595[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 10)
                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                            revert with 0, 17
                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                            if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                _6206 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6206] = 26
                                mem[_6206 + 32] = 'SafeMath: division by zero'
                            else:
                                if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6796 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6796] = 26
                                mem[_6796 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                        else:
                            if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                _6207 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6207] = 26
                                mem[_6207 + 32] = 'SafeMath: division by zero'
                            else:
                                if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6797 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6797] = 26
                                mem[_6797 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                    else:
                        if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                            mem[_4020 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                            mem[_4015] = _4020
                            mem[_4015 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4015 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4015 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4015 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4070 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4070] = 30
                                mem[_4070 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4103 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4103 + 68] = mem[idx + _4070 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4103 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4103 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4249 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4249] = 26
                                mem[_4249 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4328 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4328 + 68] = mem[idx + _4249 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4328 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4328 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5605 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5605] = 26
                                            mem[_5605 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5870 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5870] = 26
                                            mem[_5870 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5606 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5606] = 26
                                            mem[_5606 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5871 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5871] = 26
                                            mem[_5871 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5868 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5868] = 26
                                        mem[_5868 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6302 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6302] = 26
                                        mem[_6302 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5869 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5869] = 26
                                        mem[_5869 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6303 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6303] = 26
                                        mem[_6303 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4218 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4218] = 30
                            mem[_4218 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4289 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4289 + 68] = mem[idx + _4218 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4289 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4289 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4559 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4559] = 26
                            mem[_4559 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4631 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4631 + 68] = mem[idx + _4559 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4631 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4631 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5933 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5933] = 26
                                        mem[_5933 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6416 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6416] = 26
                                        mem[_6416 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5934 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5934] = 26
                                        mem[_5934 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6417 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6417] = 26
                                        mem[_6417 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6414 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6414] = 26
                                    mem[_6414 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6990 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6990] = 26
                                    mem[_6990 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6415 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6415] = 26
                                    mem[_6415 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6991 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6991] = 26
                                    mem[_6991 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_4020 + 32] = sub_2c534595[address(arg1)][idx].field_0
                            t = _4020 + 32
                            u = sha3(mem[0])
                            while _4020 + (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_4015] = _4020
                            mem[_4015 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4015 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4015 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4015 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _8114 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8114] = 30
                                mem[_8114 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _8310 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8310 + 68] = mem[idx + _8114 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8310 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8310 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _8370 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8370] = 26
                                mem[_8370 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8394 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8394 + 68] = mem[idx + _8370 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8394 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8394 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8814 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8814] = 26
                                            mem[_8814 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _8912 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8912] = 26
                                            mem[_8912 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8815 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8815] = 26
                                            mem[_8815 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _8913 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8913] = 26
                                            mem[_8913 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _8910 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8910] = 26
                                        mem[_8910 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9054 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9054] = 26
                                        mem[_9054 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _8911 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8911] = 26
                                        mem[_8911 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9055 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9055] = 26
                                        mem[_9055 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _8347 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8347] = 30
                            mem[_8347 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _8382 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _8382 + 68] = mem[idx + _8347 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8382 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _8382 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _8467 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8467] = 26
                            mem[_8467 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _8490 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _8490 + 68] = mem[idx + _8467 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8490 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _8490 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _8958 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8958] = 26
                                        mem[_8958 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9130 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9130] = 26
                                        mem[_9130 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _8959 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8959] = 26
                                        mem[_8959 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9131 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9131] = 26
                                        mem[_9131 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _9128 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9128] = 26
                                    mem[_9128 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _9298 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9298] = 26
                                    mem[_9298 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _9129 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9129] = 26
                                    mem[_9129 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _9299 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9299] = 26
                                    mem[_9299 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                else:
                    if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                        revert with 0, 34
                    if not sub_2c534595[address(arg1)][idx].field_1:
                        mem[_4015] = _4020
                        mem[_4015 + 32] = sub_2c534595[address(arg1)][idx].field_256
                        mem[_4015 + 64] = sub_2c534595[address(arg1)][idx].field_512
                        mem[_4015 + 96] = sub_2c534595[address(arg1)][idx].field_768
                        mem[_4015 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                        if -sub_2c534595[address(arg1)][idx].field_512:
                            _4056 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4056] = 30
                            mem[_4056 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                _4083 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4083 + 68] = mem[idx + _4056 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4083 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4083 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _4219 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4219] = 26
                            mem[_4219 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4290 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4290 + 68] = mem[idx + _4219 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4290 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4290 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5570 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5570] = 26
                                        mem[_5570 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5811 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5811] = 26
                                        mem[_5811 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5571 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5571] = 26
                                        mem[_5571 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5812 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5812] = 26
                                        mem[_5812 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                    _5809 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5809] = 26
                                    mem[_5809 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6214 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6214] = 26
                                    mem[_6214 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                    _5810 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5810] = 26
                                    mem[_5810 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6215 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6215] = 26
                                    mem[_6215 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2c534595[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 10)
                            sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        _4188 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4188] = 30
                        mem[_4188 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                            _4250 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4250 + 68] = mem[idx + _4188 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4250 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4250 + -mem[64] + 100
                        if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _4515 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4515] = 26
                        mem[_4515 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _4596 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4596 + 68] = mem[idx + _4515 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4596 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4596 + -mem[64] + 100
                        if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                            revert with 0, 17
                        if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -rewardPerNode:
                            if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                    _5872 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5872] = 26
                                    mem[_5872 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6312 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6312] = 26
                                    mem[_6312 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                    _5873 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5873] = 26
                                    mem[_5873 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6313 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6313] = 26
                                    mem[_6313 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2c534595[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 10)
                            sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if idx >= sub_2c534595[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 10)
                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                            revert with 0, 17
                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                            if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                _6310 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6310] = 26
                                mem[_6310 + 32] = 'SafeMath: division by zero'
                            else:
                                if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6894 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6894] = 26
                                mem[_6894 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                        else:
                            if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                _6311 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6311] = 26
                                mem[_6311 + 32] = 'SafeMath: division by zero'
                            else:
                                if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6895 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6895] = 26
                                mem[_6895 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                    else:
                        if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                            mem[_4020 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                            mem[_4015] = _4020
                            mem[_4015 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4015 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4015 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4015 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4085 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4085] = 30
                                mem[_4085 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4122 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4122 + 68] = mem[idx + _4085 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4122 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4122 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4291 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4291] = 26
                                mem[_4291 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4383 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4383 + 68] = mem[idx + _4291 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4383 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4383 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5642 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5642] = 26
                                            mem[_5642 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5940 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5940] = 26
                                            mem[_5940 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5643 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5643] = 26
                                            mem[_5643 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5941 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5941] = 26
                                            mem[_5941 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5938 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5938] = 26
                                        mem[_5938 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6420 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6420] = 26
                                        mem[_6420 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5939 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5939] = 26
                                        mem[_5939 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6421 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6421] = 26
                                        mem[_6421 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4253 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4253] = 30
                            mem[_4253 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4334 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4334 + 68] = mem[idx + _4253 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4334 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4334 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4598 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4598] = 26
                            mem[_4598 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4679 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4679 + 68] = mem[idx + _4598 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4679 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4679 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _6005 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6005] = 26
                                        mem[_6005 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6530 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6530] = 26
                                        mem[_6530 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _6006 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6006] = 26
                                        mem[_6006 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6531 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6531] = 26
                                        mem[_6531 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6528 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6528] = 26
                                    mem[_6528 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7106 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7106] = 26
                                    mem[_7106 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6529 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6529] = 26
                                    mem[_6529 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7107 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7107] = 26
                                    mem[_7107 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_4020 + 32] = sub_2c534595[address(arg1)][idx].field_0
                            t = _4020 + 32
                            u = sha3(mem[0])
                            while _4020 + sub_2c534595[address(arg1)][idx].field_1 > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_4015] = _4020
                            mem[_4015 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4015 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4015 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4015 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _8131 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8131] = 30
                                mem[_8131 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _8311 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8311 + 68] = mem[idx + _8131 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8311 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8311 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _8371 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8371] = 26
                                mem[_8371 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8395 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8395 + 68] = mem[idx + _8371 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8395 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8395 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8817 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8817] = 26
                                            mem[_8817 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _8916 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8916] = 26
                                            mem[_8916 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8818 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8818] = 26
                                            mem[_8818 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _8917 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8917] = 26
                                            mem[_8917 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _8914 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8914] = 26
                                        mem[_8914 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9060 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9060] = 26
                                        mem[_9060 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _8915 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8915] = 26
                                        mem[_8915 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9061 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9061] = 26
                                        mem[_9061 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _8349 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8349] = 30
                            mem[_8349 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _8383 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _8383 + 68] = mem[idx + _8349 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8383 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _8383 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _8469 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8469] = 26
                            mem[_8469 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _8491 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _8491 + 68] = mem[idx + _8469 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8491 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _8491 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _8960 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8960] = 26
                                        mem[_8960 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9136 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9136] = 26
                                        mem[_9136 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _8961 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8961] = 26
                                        mem[_8961 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9137 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9137] = 26
                                        mem[_9137 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _9134 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9134] = 26
                                    mem[_9134 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _9306 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9306] = 26
                                    mem[_9306 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _9135 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9135] = 26
                                    mem[_9135 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _9307 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9307] = 26
                                    mem[_9307 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
            else:
                if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                    revert with 0, 34
                _4023 = mem[64]
                mem[64] = mem[64] + ceil32(sub_2c534595[address(arg1)][idx].field_1) + 32
                mem[_4023] = sub_2c534595[address(arg1)][idx].field_1
                if sub_2c534595[address(arg1)][idx].field_0:
                    if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    if not Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                        mem[_4015] = _4023
                        mem[_4015 + 32] = sub_2c534595[address(arg1)][idx].field_256
                        mem[_4015 + 64] = sub_2c534595[address(arg1)][idx].field_512
                        mem[_4015 + 96] = sub_2c534595[address(arg1)][idx].field_768
                        mem[_4015 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                        if -sub_2c534595[address(arg1)][idx].field_512:
                            _4058 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4058] = 30
                            mem[_4058 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                _4086 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4086 + 68] = mem[idx + _4058 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4086 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4086 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _4221 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4221] = 26
                            mem[_4221 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4292 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4292 + 68] = mem[idx + _4221 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4292 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4292 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5574 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5574] = 26
                                        mem[_5574 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5818 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5818] = 26
                                        mem[_5818 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5575 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5575] = 26
                                        mem[_5575 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5819 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5819] = 26
                                        mem[_5819 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                    _5816 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5816] = 26
                                    mem[_5816 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6222 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6222] = 26
                                    mem[_6222 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                    _5817 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5817] = 26
                                    mem[_5817 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6223 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6223] = 26
                                    mem[_6223 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2c534595[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 10)
                            sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        _4191 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4191] = 30
                        mem[_4191 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                            _4254 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4254 + 68] = mem[idx + _4191 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4254 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4254 + -mem[64] + 100
                        if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _4520 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4520] = 26
                        mem[_4520 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _4599 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4599 + 68] = mem[idx + _4520 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4599 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4599 + -mem[64] + 100
                        if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                            revert with 0, 17
                        if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -rewardPerNode:
                            if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                    _5876 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5876] = 26
                                    mem[_5876 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6322 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6322] = 26
                                    mem[_6322 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                    _5877 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5877] = 26
                                    mem[_5877 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6323 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6323] = 26
                                    mem[_6323 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2c534595[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 10)
                            sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if idx >= sub_2c534595[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 10)
                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                            revert with 0, 17
                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                            if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                _6320 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6320] = 26
                                mem[_6320 + 32] = 'SafeMath: division by zero'
                            else:
                                if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6904 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6904] = 26
                                mem[_6904 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                        else:
                            if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                _6321 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6321] = 26
                                mem[_6321 + 32] = 'SafeMath: division by zero'
                            else:
                                if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _6905 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6905] = 26
                                mem[_6905 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                    else:
                        if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                            mem[_4023 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                            mem[_4015] = _4023
                            mem[_4015 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4015 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4015 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4015 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4088 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4088] = 30
                                mem[_4088 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4125 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4125 + 68] = mem[idx + _4088 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4125 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4125 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4293 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4293] = 26
                                mem[_4293 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4386 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4386 + 68] = mem[idx + _4293 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4386 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4386 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5646 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5646] = 26
                                            mem[_5646 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5947 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5947] = 26
                                            mem[_5947 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5647 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5647] = 26
                                            mem[_5647 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5948 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5948] = 26
                                            mem[_5948 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5945 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5945] = 26
                                        mem[_5945 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6428 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6428] = 26
                                        mem[_6428 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5946 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5946] = 26
                                        mem[_5946 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6429 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6429] = 26
                                        mem[_6429 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4257 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4257] = 30
                            mem[_4257 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4340 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4340 + 68] = mem[idx + _4257 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4340 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4340 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4601 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4601] = 26
                            mem[_4601 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4685 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4685 + 68] = mem[idx + _4601 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4685 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4685 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _6009 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6009] = 26
                                        mem[_6009 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6540 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6540] = 26
                                        mem[_6540 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _6010 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6010] = 26
                                        mem[_6010 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6541 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6541] = 26
                                        mem[_6541 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6538 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6538] = 26
                                    mem[_6538 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7116 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7116] = 26
                                    mem[_7116 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6539 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6539] = 26
                                    mem[_6539 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7117 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7117] = 26
                                    mem[_7117 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_4023 + 32] = sub_2c534595[address(arg1)][idx].field_0
                            t = _4023 + 32
                            u = sha3(mem[0])
                            while _4023 + (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_4015] = _4023
                            mem[_4015 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4015 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4015 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4015 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _8148 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8148] = 30
                                mem[_8148 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _8312 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8312 + 68] = mem[idx + _8148 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8312 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8312 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _8372 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8372] = 26
                                mem[_8372 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8396 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8396 + 68] = mem[idx + _8372 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8396 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8396 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8820 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8820] = 26
                                            mem[_8820 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _8920 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8920] = 26
                                            mem[_8920 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8821 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8821] = 26
                                            mem[_8821 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _8921 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8921] = 26
                                            mem[_8921 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _8918 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8918] = 26
                                        mem[_8918 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9066 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9066] = 26
                                        mem[_9066 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _8919 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8919] = 26
                                        mem[_8919 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9067 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9067] = 26
                                        mem[_9067 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _8351 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8351] = 30
                            mem[_8351 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _8384 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _8384 + 68] = mem[idx + _8351 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8384 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _8384 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _8471 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8471] = 26
                            mem[_8471 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _8492 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _8492 + 68] = mem[idx + _8471 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8492 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _8492 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _8962 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8962] = 26
                                        mem[_8962 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9142 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9142] = 26
                                        mem[_9142 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _8963 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8963] = 26
                                        mem[_8963 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9143 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9143] = 26
                                        mem[_9143 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _9140 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9140] = 26
                                    mem[_9140 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _9314 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9314] = 26
                                    mem[_9314 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _9141 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9141] = 26
                                    mem[_9141 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _9315 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9315] = 26
                                    mem[_9315 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                else:
                    if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                        revert with 0, 34
                    if not sub_2c534595[address(arg1)][idx].field_1:
                        mem[_4015] = _4023
                        mem[_4015 + 32] = sub_2c534595[address(arg1)][idx].field_256
                        mem[_4015 + 64] = sub_2c534595[address(arg1)][idx].field_512
                        mem[_4015 + 96] = sub_2c534595[address(arg1)][idx].field_768
                        mem[_4015 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                        if -sub_2c534595[address(arg1)][idx].field_512:
                            _4071 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4071] = 30
                            mem[_4071 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                _4104 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4104 + 68] = mem[idx + _4071 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4104 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4104 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                revert with 0, 17
                            _4258 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4258] = 26
                            mem[_4258 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4341 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4341 + 68] = mem[idx + _4258 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4341 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4341 + -mem[64] + 100
                            if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                revert with 0, 17
                            if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5612 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5612] = 26
                                        mem[_5612 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5882 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5882] = 26
                                        mem[_5882 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5613 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5613] = 26
                                        mem[_5613 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _5883 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5883] = 26
                                        mem[_5883 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                    _5880 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5880] = 26
                                    mem[_5880 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6328 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6328] = 26
                                    mem[_6328 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                    _5881 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5881] = 26
                                    mem[_5881 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6329 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6329] = 26
                                    mem[_6329 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2c534595[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 10)
                            sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        _4224 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4224] = 30
                        mem[_4224 + 32] = 'SafeMath: subtraction overflow'
                        if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                            _4294 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _4294 + 68] = mem[idx + _4224 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4294 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _4294 + -mem[64] + 100
                        if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                            revert with 0, 17
                        _4565 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4565] = 26
                        mem[_4565 + 32] = 'SafeMath: division by zero'
                        if not claimTime:
                            _4638 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4638 + 68] = mem[idx + _4565 + 32]
                                idx = idx + 32
                                continue 
                            mem[_4638 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4638 + -mem[64] + 100
                        if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                            revert with 0, 17
                        if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                            revert with 0, 'SafeMath: addition overflow'
                        if not -rewardPerNode:
                            if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                    _5949 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5949] = 26
                                    mem[_5949 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6438 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6438] = 26
                                    mem[_6438 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                    _5950 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_5950] = 26
                                    mem[_5950 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6439 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6439] = 26
                                    mem[_6439 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            sub_2c534595[address(arg1)][idx].field_768 = 0
                            mem[0] = sha3(address(arg1), 10)
                            sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                            if not idx + 1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + sub_2c534595[address(arg1)][idx].field_768
                            continue 
                        if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                            revert with 0, 17
                        if not rewardPerNode:
                            revert with 0, 18
                        if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                            revert with 0, 17
                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                            revert with 0, 17
                        if idx >= sub_2c534595[address(arg1)].field_0:
                            revert with 0, 50
                        mem[0] = sha3(address(arg1), 10)
                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                            revert with 0, 17
                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                            if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                _6436 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6436] = 26
                                mem[_6436 + 32] = 'SafeMath: division by zero'
                            else:
                                if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _7014 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7014] = 26
                                mem[_7014 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                    revert with 0, 17
                        else:
                            if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                _6437 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_6437] = 26
                                mem[_6437 + 32] = 'SafeMath: division by zero'
                            else:
                                if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 18
                                if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _7015 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_7015] = 26
                                mem[_7015 + 32] = 'SafeMath: division by zero'
                                if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                    revert with 0, 17
                    else:
                        if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                            mem[_4023 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                            mem[_4015] = _4023
                            mem[_4015 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4015 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4015 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4015 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4106 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4106] = 30
                                mem[_4106 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4146 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4146 + 68] = mem[idx + _4106 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4146 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4146 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4342 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4342] = 26
                                mem[_4342 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4438 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4438 + 68] = mem[idx + _4342 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4438 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4438 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5682 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5682] = 26
                                            mem[_5682 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6016 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6016] = 26
                                            mem[_6016 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5683 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5683] = 26
                                            mem[_5683 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6017 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6017] = 26
                                            mem[_6017 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6014 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6014] = 26
                                        mem[_6014 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6544 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6544] = 26
                                        mem[_6544 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6015 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6015] = 26
                                        mem[_6015 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6545 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6545] = 26
                                        mem[_6545 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4297 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4297] = 30
                            mem[_4297 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4392 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4392 + 68] = mem[idx + _4297 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4392 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4392 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4640 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4640] = 26
                            mem[_4640 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4741 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4741 + 68] = mem[idx + _4640 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4741 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4741 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _6080 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6080] = 26
                                        mem[_6080 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6646 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6646] = 26
                                        mem[_6646 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _6081 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6081] = 26
                                        mem[_6081 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6647 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6647] = 26
                                        mem[_6647 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6644 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6644] = 26
                                    mem[_6644 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7230 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7230] = 26
                                    mem[_7230 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6645 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6645] = 26
                                    mem[_6645 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7231 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7231] = 26
                                    mem[_7231 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                            mem[_4023 + 32] = sub_2c534595[address(arg1)][idx].field_0
                            t = _4023 + 32
                            u = sha3(mem[0])
                            while _4023 + sub_2c534595[address(arg1)][idx].field_1 > t:
                                mem[t + 32] = uint256(stor1[u])
                                t = t + 32
                                u = u + 1
                                continue 
                            mem[_4015] = _4023
                            mem[_4015 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4015 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4015 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4015 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _8165 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8165] = 30
                                mem[_8165 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _8313 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8313 + 68] = mem[idx + _8165 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8313 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8313 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _8373 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8373] = 26
                                mem[_8373 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8397 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8397 + 68] = mem[idx + _8373 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8397 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8397 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8823 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8823] = 26
                                            mem[_8823 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _8924 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8924] = 26
                                            mem[_8924 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8824 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8824] = 26
                                            mem[_8824 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _8925 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8925] = 26
                                            mem[_8925 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _8922 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8922] = 26
                                        mem[_8922 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9072 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9072] = 26
                                        mem[_9072 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _8923 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8923] = 26
                                        mem[_8923 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9073 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9073] = 26
                                        mem[_9073 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _8353 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8353] = 30
                            mem[_8353 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _8385 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _8385 + 68] = mem[idx + _8353 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8385 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _8385 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _8473 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_8473] = 26
                            mem[_8473 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _8493 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _8493 + 68] = mem[idx + _8473 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_8493 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _8493 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _8964 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8964] = 26
                                        mem[_8964 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9148 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9148] = 26
                                        mem[_9148 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _8965 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_8965] = 26
                                        mem[_8965 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9149 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9149] = 26
                                        mem[_9149 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _9146 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9146] = 26
                                    mem[_9146 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _9322 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9322] = 26
                                    mem[_9322 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _9147 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9147] = 26
                                    mem[_9147 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _9323 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_9323] = 26
                                    mem[_9323 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
            if idx >= sub_2c534595[address(arg1)].field_0:
                revert with 0, 50
            sub_2c534595[address(arg1)][idx].field_768 = 0
            mem[0] = sha3(address(arg1), 10)
            sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
            if not idx + 1:
                revert with 0, 17
            idx = idx + 1
            s = s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768
            continue 
    else:
        if msg.sender == gateKeeperAddress:
            mem[0] = address(arg1)
            mem[32] = 10
            idx = 0
            s = 0
            while idx < sub_2c534595[address(arg1)].field_0:
                mem[0] = sha3(address(arg1), 10)
                if sub_2c534595[address(arg1)][idx].field_1024 - uint32(arg2):
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if idx >= sub_2c534595[address(arg1)].field_0:
                    revert with 0, 50
                mem[0] = sha3(address(arg1), 10)
                _4017 = mem[64]
                mem[64] = mem[64] + 160
                if sub_2c534595[address(arg1)][idx].field_0:
                    if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    _4021 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) + 32
                    mem[_4021] = uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5
                    if sub_2c534595[address(arg1)][idx].field_0:
                        if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                            revert with 0, 34
                        if not Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                            mem[_4017] = _4021
                            mem[_4017 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4017 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4017 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4017 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4048 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4048] = 30
                                mem[_4048 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4073 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4073 + 68] = mem[idx + _4048 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4073 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4073 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4195 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4195] = 26
                                mem[_4195 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4260 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4260 + 68] = mem[idx + _4195 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4260 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4260 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5548 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5548] = 26
                                            mem[_5548 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5773 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5773] = 26
                                            mem[_5773 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5549 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5549] = 26
                                            mem[_5549 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5774 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5774] = 26
                                            mem[_5774 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5771 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5771] = 26
                                        mem[_5771 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6152 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6152] = 26
                                        mem[_6152 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5772 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5772] = 26
                                        mem[_5772 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6153 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6153] = 26
                                        mem[_6153 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4170 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4170] = 30
                            mem[_4170 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4226 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4226 + 68] = mem[idx + _4170 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4226 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4226 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4483 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4483] = 26
                            mem[_4483 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4569 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4569 + 68] = mem[idx + _4483 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4569 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4569 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5825 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5825] = 26
                                        mem[_5825 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6240 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6240] = 26
                                        mem[_6240 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5826 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5826] = 26
                                        mem[_5826 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6241 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6241] = 26
                                        mem[_6241 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6238 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6238] = 26
                                    mem[_6238 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6826 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6826] = 26
                                    mem[_6826 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6239 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6239] = 26
                                    mem[_6239 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6827 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6827] = 26
                                    mem[_6827 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                                mem[_4021 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                                mem[_4017] = _4021
                                mem[_4017 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4017 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4017 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4017 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _4075 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4075] = 30
                                    mem[_4075 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _4109 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4109 + 68] = mem[idx + _4075 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4109 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4109 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4261 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4261] = 26
                                    mem[_4261 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4345 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4345 + 68] = mem[idx + _4261 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4345 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4345 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5617 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5617] = 26
                                                mem[_5617 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5892 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5892] = 26
                                                mem[_5892 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5618 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5618] = 26
                                                mem[_5618 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5893 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5893] = 26
                                                mem[_5893 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5890 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5890] = 26
                                            mem[_5890 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6338 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6338] = 26
                                            mem[_6338 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5891 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5891] = 26
                                            mem[_5891 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6339 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6339] = 26
                                            mem[_6339 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _4229 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4229] = 30
                                mem[_4229 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _4303 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4303 + 68] = mem[idx + _4229 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4303 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4303 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4571 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4571] = 26
                                mem[_4571 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4646 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4646 + 68] = mem[idx + _4571 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4646 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4646 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5955 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5955] = 26
                                            mem[_5955 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6452 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6452] = 26
                                            mem[_6452 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5956 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5956] = 26
                                            mem[_5956 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6453 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6453] = 26
                                            mem[_6453 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6450 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6450] = 26
                                        mem[_6450 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7026 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7026] = 26
                                        mem[_7026 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6451 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6451] = 26
                                        mem[_6451 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7027 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7027] = 26
                                        mem[_7027 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                            else:
                                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_4021 + 32] = sub_2c534595[address(arg1)][idx].field_0
                                t = _4021 + 32
                                u = sha3(mem[0])
                                while _4021 + (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_4017] = _4021
                                mem[_4017 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4017 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4017 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4017 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _8182 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8182] = 30
                                    mem[_8182 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _8314 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _8314 + 68] = mem[idx + _8182 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8314 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8314 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _8374 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8374] = 26
                                    mem[_8374 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _8398 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _8398 + 68] = mem[idx + _8374 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8398 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8398 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8826 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8826] = 26
                                                mem[_8826 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8928 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8928] = 26
                                                mem[_8928 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8827 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8827] = 26
                                                mem[_8827 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8929 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8929] = 26
                                                mem[_8929 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8926 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8926] = 26
                                            mem[_8926 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9078 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9078] = 26
                                            mem[_9078 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8927 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8927] = 26
                                            mem[_8927 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9079 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9079] = 26
                                            mem[_9079 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _8355 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8355] = 30
                                mem[_8355 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _8386 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8386 + 68] = mem[idx + _8355 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8386 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8386 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _8475 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8475] = 26
                                mem[_8475 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8494 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8494 + 68] = mem[idx + _8475 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8494 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8494 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8966 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8966] = 26
                                            mem[_8966 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9154 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9154] = 26
                                            mem[_9154 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8967 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8967] = 26
                                            mem[_8967 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9155 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9155] = 26
                                            mem[_9155 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9152 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9152] = 26
                                        mem[_9152 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9330 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9330] = 26
                                        mem[_9330 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9153 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9153] = 26
                                        mem[_9153 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9331 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9331] = 26
                                        mem[_9331 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                    else:
                        if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                            revert with 0, 34
                        if not sub_2c534595[address(arg1)][idx].field_1:
                            mem[_4017] = _4021
                            mem[_4017 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4017 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4017 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4017 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4060 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4060] = 30
                                mem[_4060 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4089 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4089 + 68] = mem[idx + _4060 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4089 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4089 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4230 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4230] = 26
                                mem[_4230 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4304 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4304 + 68] = mem[idx + _4230 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4304 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4304 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5582 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5582] = 26
                                            mem[_5582 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5831 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5831] = 26
                                            mem[_5831 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5583 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5583] = 26
                                            mem[_5583 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5832 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5832] = 26
                                            mem[_5832 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5829 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5829] = 26
                                        mem[_5829 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6246 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6246] = 26
                                        mem[_6246 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5830 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5830] = 26
                                        mem[_5830 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6247 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6247] = 26
                                        mem[_6247 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4198 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4198] = 30
                            mem[_4198 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4262 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4262 + 68] = mem[idx + _4198 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4262 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4262 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4530 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4530] = 26
                            mem[_4530 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4607 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4607 + 68] = mem[idx + _4530 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4607 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4607 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5894 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5894] = 26
                                        mem[_5894 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6348 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6348] = 26
                                        mem[_6348 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5895 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5895] = 26
                                        mem[_5895 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6349 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6349] = 26
                                        mem[_6349 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6346 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6346] = 26
                                    mem[_6346 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6928 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6928] = 26
                                    mem[_6928 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6347 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6347] = 26
                                    mem[_6347 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6929 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6929] = 26
                                    mem[_6929 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                                mem[_4021 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                                mem[_4017] = _4021
                                mem[_4017 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4017 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4017 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4017 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _4091 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4091] = 30
                                    mem[_4091 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _4129 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4129 + 68] = mem[idx + _4091 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4129 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4129 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4305 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4305] = 26
                                    mem[_4305 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4399 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4399 + 68] = mem[idx + _4305 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4399 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4399 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5653 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5653] = 26
                                                mem[_5653 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5962 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5962] = 26
                                                mem[_5962 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5654 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5654] = 26
                                                mem[_5654 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5963 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5963] = 26
                                                mem[_5963 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5960 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5960] = 26
                                            mem[_5960 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6456 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6456] = 26
                                            mem[_6456 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5961 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5961] = 26
                                            mem[_5961 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6457 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6457] = 26
                                            mem[_6457 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _4265 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4265] = 30
                                mem[_4265 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _4351 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4351 + 68] = mem[idx + _4265 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4351 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4351 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4609 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4609] = 26
                                mem[_4609 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4697 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4697 + 68] = mem[idx + _4609 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4697 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4697 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6026 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6026] = 26
                                            mem[_6026 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6564 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6564] = 26
                                            mem[_6564 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6027 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6027] = 26
                                            mem[_6027 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6565 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6565] = 26
                                            mem[_6565 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6562 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6562] = 26
                                        mem[_6562 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7142 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7142] = 26
                                        mem[_7142 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6563 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6563] = 26
                                        mem[_6563 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7143 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7143] = 26
                                        mem[_7143 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                            else:
                                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_4021 + 32] = sub_2c534595[address(arg1)][idx].field_0
                                t = _4021 + 32
                                u = sha3(mem[0])
                                while _4021 + sub_2c534595[address(arg1)][idx].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_4017] = _4021
                                mem[_4017 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4017 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4017 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4017 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _8199 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8199] = 30
                                    mem[_8199 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _8315 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _8315 + 68] = mem[idx + _8199 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8315 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8315 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _8375 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8375] = 26
                                    mem[_8375 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _8399 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _8399 + 68] = mem[idx + _8375 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8399 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8399 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8829 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8829] = 26
                                                mem[_8829 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8932 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8932] = 26
                                                mem[_8932 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8830 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8830] = 26
                                                mem[_8830 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8933 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8933] = 26
                                                mem[_8933 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8930 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8930] = 26
                                            mem[_8930 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9084 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9084] = 26
                                            mem[_9084 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8931 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8931] = 26
                                            mem[_8931 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9085 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9085] = 26
                                            mem[_9085 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _8357 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8357] = 30
                                mem[_8357 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _8387 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8387 + 68] = mem[idx + _8357 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8387 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8387 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _8477 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8477] = 26
                                mem[_8477 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8495 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8495 + 68] = mem[idx + _8477 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8495 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8495 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8968 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8968] = 26
                                            mem[_8968 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9160 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9160] = 26
                                            mem[_9160 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8969 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8969] = 26
                                            mem[_8969 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9161 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9161] = 26
                                            mem[_9161 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9158 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9158] = 26
                                        mem[_9158 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9338 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9338] = 26
                                        mem[_9338 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9159 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9159] = 26
                                        mem[_9159 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9339 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9339] = 26
                                        mem[_9339 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                else:
                    if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                        revert with 0, 34
                    _4024 = mem[64]
                    mem[64] = mem[64] + ceil32(sub_2c534595[address(arg1)][idx].field_1) + 32
                    mem[_4024] = sub_2c534595[address(arg1)][idx].field_1
                    if sub_2c534595[address(arg1)][idx].field_0:
                        if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                            revert with 0, 34
                        if not Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                            mem[_4017] = _4024
                            mem[_4017 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4017 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4017 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4017 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4062 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4062] = 30
                                mem[_4062 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4092 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4092 + 68] = mem[idx + _4062 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4092 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4092 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4232 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4232] = 26
                                mem[_4232 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4306 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4306 + 68] = mem[idx + _4232 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4306 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4306 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5586 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5586] = 26
                                            mem[_5586 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5838 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5838] = 26
                                            mem[_5838 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5587 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5587] = 26
                                            mem[_5587 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5839 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5839] = 26
                                            mem[_5839 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5836 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5836] = 26
                                        mem[_5836 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6254 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6254] = 26
                                        mem[_6254 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5837 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5837] = 26
                                        mem[_5837 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6255 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6255] = 26
                                        mem[_6255 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4201 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4201] = 30
                            mem[_4201 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4266 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4266 + 68] = mem[idx + _4201 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4266 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4266 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4535 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4535] = 26
                            mem[_4535 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4610 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4610 + 68] = mem[idx + _4535 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4610 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4610 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5898 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5898] = 26
                                        mem[_5898 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6358 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6358] = 26
                                        mem[_6358 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5899 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5899] = 26
                                        mem[_5899 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6359 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6359] = 26
                                        mem[_6359 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6356 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6356] = 26
                                    mem[_6356 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6938 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6938] = 26
                                    mem[_6938 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6357 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6357] = 26
                                    mem[_6357 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6939 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6939] = 26
                                    mem[_6939 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                                mem[_4024 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                                mem[_4017] = _4024
                                mem[_4017 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4017 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4017 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4017 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _4094 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4094] = 30
                                    mem[_4094 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _4132 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4132 + 68] = mem[idx + _4094 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4132 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4132 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4307 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4307] = 26
                                    mem[_4307 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4402 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4402 + 68] = mem[idx + _4307 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4402 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4402 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5657 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5657] = 26
                                                mem[_5657 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5969 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5969] = 26
                                                mem[_5969 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5658 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5658] = 26
                                                mem[_5658 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5970 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5970] = 26
                                                mem[_5970 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5967 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5967] = 26
                                            mem[_5967 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6464 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6464] = 26
                                            mem[_6464 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5968 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5968] = 26
                                            mem[_5968 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6465 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6465] = 26
                                            mem[_6465 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _4269 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4269] = 30
                                mem[_4269 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _4357 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4357 + 68] = mem[idx + _4269 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4357 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4357 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4612 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4612] = 26
                                mem[_4612 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4703 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4703 + 68] = mem[idx + _4612 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4703 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4703 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6030 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6030] = 26
                                            mem[_6030 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6574 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6574] = 26
                                            mem[_6574 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6031 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6031] = 26
                                            mem[_6031 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6575 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6575] = 26
                                            mem[_6575 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6572 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6572] = 26
                                        mem[_6572 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7152 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7152] = 26
                                        mem[_7152 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6573 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6573] = 26
                                        mem[_6573 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7153 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7153] = 26
                                        mem[_7153 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                            else:
                                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_4024 + 32] = sub_2c534595[address(arg1)][idx].field_0
                                t = _4024 + 32
                                u = sha3(mem[0])
                                while _4024 + (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_4017] = _4024
                                mem[_4017 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4017 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4017 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4017 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _8216 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8216] = 30
                                    mem[_8216 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _8316 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _8316 + 68] = mem[idx + _8216 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8316 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8316 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _8376 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8376] = 26
                                    mem[_8376 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _8400 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _8400 + 68] = mem[idx + _8376 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8400 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8400 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8832 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8832] = 26
                                                mem[_8832 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8936 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8936] = 26
                                                mem[_8936 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8833 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8833] = 26
                                                mem[_8833 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8937 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8937] = 26
                                                mem[_8937 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8934 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8934] = 26
                                            mem[_8934 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9090 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9090] = 26
                                            mem[_9090 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8935 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8935] = 26
                                            mem[_8935 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9091 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9091] = 26
                                            mem[_9091 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _8359 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8359] = 30
                                mem[_8359 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _8388 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8388 + 68] = mem[idx + _8359 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8388 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8388 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _8479 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8479] = 26
                                mem[_8479 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8496 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8496 + 68] = mem[idx + _8479 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8496 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8496 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8970 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8970] = 26
                                            mem[_8970 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9166 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9166] = 26
                                            mem[_9166 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8971 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8971] = 26
                                            mem[_8971 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9167 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9167] = 26
                                            mem[_9167 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9164 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9164] = 26
                                        mem[_9164 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9346 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9346] = 26
                                        mem[_9346 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9165 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9165] = 26
                                        mem[_9165 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9347 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9347] = 26
                                        mem[_9347 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                    else:
                        if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                            revert with 0, 34
                        if not sub_2c534595[address(arg1)][idx].field_1:
                            mem[_4017] = _4024
                            mem[_4017 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4017 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4017 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4017 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4076 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4076] = 30
                                mem[_4076 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4110 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4110 + 68] = mem[idx + _4076 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4110 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4110 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4270 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4270] = 26
                                mem[_4270 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4358 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4358 + 68] = mem[idx + _4270 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4358 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4358 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5624 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5624] = 26
                                            mem[_5624 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5904 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5904] = 26
                                            mem[_5904 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5625 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5625] = 26
                                            mem[_5625 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5905 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5905] = 26
                                            mem[_5905 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5902 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5902] = 26
                                        mem[_5902 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6364 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6364] = 26
                                        mem[_6364 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5903 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5903] = 26
                                        mem[_5903 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6365 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6365] = 26
                                        mem[_6365 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4235 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4235] = 30
                            mem[_4235 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4308 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4308 + 68] = mem[idx + _4235 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4308 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4308 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4577 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4577] = 26
                            mem[_4577 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4653 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4653 + 68] = mem[idx + _4577 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4653 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4653 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5971 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5971] = 26
                                        mem[_5971 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6474 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6474] = 26
                                        mem[_6474 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5972 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5972] = 26
                                        mem[_5972 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6475 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6475] = 26
                                        mem[_6475 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6472 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6472] = 26
                                    mem[_6472 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7050 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7050] = 26
                                    mem[_7050 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6473 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6473] = 26
                                    mem[_6473 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7051 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7051] = 26
                                    mem[_7051 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                                mem[_4024 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                                mem[_4017] = _4024
                                mem[_4017 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4017 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4017 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4017 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _4112 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4112] = 30
                                    mem[_4112 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _4153 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4153 + 68] = mem[idx + _4112 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4153 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4153 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4359 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4359] = 26
                                    mem[_4359 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4452 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4452 + 68] = mem[idx + _4359 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4452 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4452 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5694 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5694] = 26
                                                mem[_5694 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _6037 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_6037] = 26
                                                mem[_6037 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5695 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5695] = 26
                                                mem[_5695 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _6038 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_6038] = 26
                                                mem[_6038 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _6035 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6035] = 26
                                            mem[_6035 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6578 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6578] = 26
                                            mem[_6578 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _6036 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6036] = 26
                                            mem[_6036 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6579 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6579] = 26
                                            mem[_6579 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _4311 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4311] = 30
                                mem[_4311 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _4408 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4408 + 68] = mem[idx + _4311 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4408 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4408 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4655 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4655] = 26
                                mem[_4655 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4758 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4758 + 68] = mem[idx + _4655 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4758 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4758 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6102 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6102] = 26
                                            mem[_6102 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6676 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6676] = 26
                                            mem[_6676 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6103 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6103] = 26
                                            mem[_6103 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6677 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6677] = 26
                                            mem[_6677 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6674 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6674] = 26
                                        mem[_6674 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7264 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7264] = 26
                                        mem[_7264 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6675 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6675] = 26
                                        mem[_6675 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7265 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7265] = 26
                                        mem[_7265 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                            else:
                                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_4024 + 32] = sub_2c534595[address(arg1)][idx].field_0
                                t = _4024 + 32
                                u = sha3(mem[0])
                                while _4024 + sub_2c534595[address(arg1)][idx].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_4017] = _4024
                                mem[_4017 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4017 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4017 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4017 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _8233 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8233] = 30
                                    mem[_8233 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _8317 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _8317 + 68] = mem[idx + _8233 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8317 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8317 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _8377 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8377] = 26
                                    mem[_8377 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _8401 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _8401 + 68] = mem[idx + _8377 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8401 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8401 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8835 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8835] = 26
                                                mem[_8835 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8940 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8940] = 26
                                                mem[_8940 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8836 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8836] = 26
                                                mem[_8836 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8941 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8941] = 26
                                                mem[_8941 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8938 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8938] = 26
                                            mem[_8938 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9096 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9096] = 26
                                            mem[_9096 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8939 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8939] = 26
                                            mem[_8939 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9097 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9097] = 26
                                            mem[_9097 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _8361 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8361] = 30
                                mem[_8361 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _8389 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8389 + 68] = mem[idx + _8361 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8389 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8389 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _8481 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8481] = 26
                                mem[_8481 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8497 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8497 + 68] = mem[idx + _8481 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8497 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8497 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8972 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8972] = 26
                                            mem[_8972 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9172 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9172] = 26
                                            mem[_9172 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8973 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8973] = 26
                                            mem[_8973 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9173 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9173] = 26
                                            mem[_9173 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9170 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9170] = 26
                                        mem[_9170 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9354 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9354] = 26
                                        mem[_9354 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9171 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9171] = 26
                                        mem[_9171 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9355 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9355] = 26
                                        mem[_9355 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                if idx >= sub_2c534595[address(arg1)].field_0:
                    revert with 0, 50
                sub_2c534595[address(arg1)][idx].field_768 = 0
                mem[0] = sha3(address(arg1), 10)
                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768
                continue 
        else:
            if address(stor0.field_0) != msg.sender:
                revert with 0, 'NodeManagerV2: NOT AUTHORIZED'
            mem[0] = address(arg1)
            mem[32] = 10
            idx = 0
            s = 0
            while idx < sub_2c534595[address(arg1)].field_0:
                mem[0] = sha3(address(arg1), 10)
                if sub_2c534595[address(arg1)][idx].field_1024 - uint32(arg2):
                    if not idx + 1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s
                    continue 
                if idx >= sub_2c534595[address(arg1)].field_0:
                    revert with 0, 50
                mem[0] = sha3(address(arg1), 10)
                _4019 = mem[64]
                mem[64] = mem[64] + 160
                if sub_2c534595[address(arg1)][idx].field_0:
                    if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                        revert with 0, 34
                    _4022 = mem[64]
                    mem[64] = mem[64] + ceil32(uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) + 32
                    mem[_4022] = uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5
                    if sub_2c534595[address(arg1)][idx].field_0:
                        if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                            revert with 0, 34
                        if not Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                            mem[_4019] = _4022
                            mem[_4019 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4019 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4019 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4019 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4052 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4052] = 30
                                mem[_4052 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4078 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4078 + 68] = mem[idx + _4052 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4078 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4078 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4205 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4205] = 26
                                mem[_4205 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4272 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4272 + 68] = mem[idx + _4205 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4272 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4272 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5558 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5558] = 26
                                            mem[_5558 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5790 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5790] = 26
                                            mem[_5790 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5559 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5559] = 26
                                            mem[_5559 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5791 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5791] = 26
                                            mem[_5791 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5788 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5788] = 26
                                        mem[_5788 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6178 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6178] = 26
                                        mem[_6178 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5789 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5789] = 26
                                        mem[_5789 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6179 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6179] = 26
                                        mem[_6179 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4178 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4178] = 30
                            mem[_4178 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4237 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4237 + 68] = mem[idx + _4178 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4237 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4237 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4498 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4498] = 26
                            mem[_4498 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4581 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4581 + 68] = mem[idx + _4498 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4581 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4581 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5845 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5845] = 26
                                        mem[_5845 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6272 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6272] = 26
                                        mem[_6272 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5846 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5846] = 26
                                        mem[_5846 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6273 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6273] = 26
                                        mem[_6273 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6270 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6270] = 26
                                    mem[_6270 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6856 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6856] = 26
                                    mem[_6856 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6271 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6271] = 26
                                    mem[_6271 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6857 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6857] = 26
                                    mem[_6857 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                                mem[_4022 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                                mem[_4019] = _4022
                                mem[_4019 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4019 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4019 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4019 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _4080 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4080] = 30
                                    mem[_4080 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _4115 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4115 + 68] = mem[idx + _4080 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4115 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4115 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4273 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4273] = 26
                                    mem[_4273 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4362 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4362 + 68] = mem[idx + _4273 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4362 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4362 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5629 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5629] = 26
                                                mem[_5629 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5914 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5914] = 26
                                                mem[_5914 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5630 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5630] = 26
                                                mem[_5630 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5915 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5915] = 26
                                                mem[_5915 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5912 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5912] = 26
                                            mem[_5912 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6374 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6374] = 26
                                            mem[_6374 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5913 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5913] = 26
                                            mem[_5913 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6375 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6375] = 26
                                            mem[_6375 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _4240 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4240] = 30
                                mem[_4240 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _4317 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4317 + 68] = mem[idx + _4240 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4317 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4317 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4583 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4583] = 26
                                mem[_4583 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4661 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4661 + 68] = mem[idx + _4583 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4661 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4661 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5977 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5977] = 26
                                            mem[_5977 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6488 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6488] = 26
                                            mem[_6488 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5978 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5978] = 26
                                            mem[_5978 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6489 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6489] = 26
                                            mem[_6489 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6486 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6486] = 26
                                        mem[_6486 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7062 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7062] = 26
                                        mem[_7062 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6487 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6487] = 26
                                        mem[_6487 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7063 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7063] = 26
                                        mem[_7063 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                            else:
                                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_4022 + 32] = sub_2c534595[address(arg1)][idx].field_0
                                t = _4022 + 32
                                u = sha3(mem[0])
                                while _4022 + (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_4019] = _4022
                                mem[_4019 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4019 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4019 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4019 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _8250 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8250] = 30
                                    mem[_8250 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _8318 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _8318 + 68] = mem[idx + _8250 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8318 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8318 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _8378 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8378] = 26
                                    mem[_8378 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _8402 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _8402 + 68] = mem[idx + _8378 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8402 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8402 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8838 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8838] = 26
                                                mem[_8838 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8944 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8944] = 26
                                                mem[_8944 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8839 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8839] = 26
                                                mem[_8839 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8945 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8945] = 26
                                                mem[_8945 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8942 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8942] = 26
                                            mem[_8942 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9102 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9102] = 26
                                            mem[_9102 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8943 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8943] = 26
                                            mem[_8943 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9103 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9103] = 26
                                            mem[_9103 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _8363 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8363] = 30
                                mem[_8363 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _8390 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8390 + 68] = mem[idx + _8363 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8390 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8390 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _8483 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8483] = 26
                                mem[_8483 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8498 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8498 + 68] = mem[idx + _8483 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8498 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8498 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8974 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8974] = 26
                                            mem[_8974 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9178 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9178] = 26
                                            mem[_9178 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8975 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8975] = 26
                                            mem[_8975 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9179 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9179] = 26
                                            mem[_9179 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9176 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9176] = 26
                                        mem[_9176 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9362 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9362] = 26
                                        mem[_9362 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9177 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9177] = 26
                                        mem[_9177 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9363 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9363] = 26
                                        mem[_9363 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                    else:
                        if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                            revert with 0, 34
                        if not sub_2c534595[address(arg1)][idx].field_1:
                            mem[_4019] = _4022
                            mem[_4019 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4019 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4019 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4019 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4064 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4064] = 30
                                mem[_4064 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4095 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4095 + 68] = mem[idx + _4064 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4095 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4095 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4241 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4241] = 26
                                mem[_4241 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4318 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4318 + 68] = mem[idx + _4241 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4318 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4318 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5594 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5594] = 26
                                            mem[_5594 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5851 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5851] = 26
                                            mem[_5851 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5595 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5595] = 26
                                            mem[_5595 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5852 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5852] = 26
                                            mem[_5852 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5849 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5849] = 26
                                        mem[_5849 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6278 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6278] = 26
                                        mem[_6278 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5850 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5850] = 26
                                        mem[_5850 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6279 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6279] = 26
                                        mem[_6279 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4208 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4208] = 30
                            mem[_4208 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4274 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4274 + 68] = mem[idx + _4208 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4274 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4274 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4545 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4545] = 26
                            mem[_4545 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4618 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4618 + 68] = mem[idx + _4545 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4618 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4618 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5916 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5916] = 26
                                        mem[_5916 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6384 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6384] = 26
                                        mem[_6384 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5917 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5917] = 26
                                        mem[_5917 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6385 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6385] = 26
                                        mem[_6385 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6382 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6382] = 26
                                    mem[_6382 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6962 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6962] = 26
                                    mem[_6962 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6383 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6383] = 26
                                    mem[_6383 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6963 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6963] = 26
                                    mem[_6963 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                                mem[_4022 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                                mem[_4019] = _4022
                                mem[_4019 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4019 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4019 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4019 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _4097 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4097] = 30
                                    mem[_4097 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _4136 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4136 + 68] = mem[idx + _4097 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4136 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4136 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4319 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4319] = 26
                                    mem[_4319 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4415 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4415 + 68] = mem[idx + _4319 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4415 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4415 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5664 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5664] = 26
                                                mem[_5664 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5984 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5984] = 26
                                                mem[_5984 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5665 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5665] = 26
                                                mem[_5665 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5985 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5985] = 26
                                                mem[_5985 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5982 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5982] = 26
                                            mem[_5982 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6492 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6492] = 26
                                            mem[_6492 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5983 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5983] = 26
                                            mem[_5983 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6493 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6493] = 26
                                            mem[_6493 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _4277 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4277] = 30
                                mem[_4277 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _4368 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4368 + 68] = mem[idx + _4277 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4368 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4368 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4620 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4620] = 26
                                mem[_4620 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4715 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4715 + 68] = mem[idx + _4620 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4715 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4715 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6047 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6047] = 26
                                            mem[_6047 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6598 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6598] = 26
                                            mem[_6598 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6048 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6048] = 26
                                            mem[_6048 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6599 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6599] = 26
                                            mem[_6599 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6596 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6596] = 26
                                        mem[_6596 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7178 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7178] = 26
                                        mem[_7178 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6597 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6597] = 26
                                        mem[_6597 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7179 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7179] = 26
                                        mem[_7179 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                            else:
                                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_4022 + 32] = sub_2c534595[address(arg1)][idx].field_0
                                t = _4022 + 32
                                u = sha3(mem[0])
                                while _4022 + sub_2c534595[address(arg1)][idx].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_4019] = _4022
                                mem[_4019 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4019 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4019 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4019 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _8267 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8267] = 30
                                    mem[_8267 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _8319 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _8319 + 68] = mem[idx + _8267 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8319 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8319 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _8379 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8379] = 26
                                    mem[_8379 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _8403 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _8403 + 68] = mem[idx + _8379 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8403 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8403 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8841 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8841] = 26
                                                mem[_8841 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8948 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8948] = 26
                                                mem[_8948 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8842 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8842] = 26
                                                mem[_8842 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8949 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8949] = 26
                                                mem[_8949 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8946 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8946] = 26
                                            mem[_8946 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9108 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9108] = 26
                                            mem[_9108 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8947 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8947] = 26
                                            mem[_8947 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9109 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9109] = 26
                                            mem[_9109 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _8365 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8365] = 30
                                mem[_8365 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _8391 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8391 + 68] = mem[idx + _8365 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8391 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8391 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _8485 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8485] = 26
                                mem[_8485 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8499 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8499 + 68] = mem[idx + _8485 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8499 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8499 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8976 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8976] = 26
                                            mem[_8976 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9184 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9184] = 26
                                            mem[_9184 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8977 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8977] = 26
                                            mem[_8977 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9185 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9185] = 26
                                            mem[_9185 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9182 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9182] = 26
                                        mem[_9182 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9370 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9370] = 26
                                        mem[_9370 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9183 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9183] = 26
                                        mem[_9183 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9371 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9371] = 26
                                        mem[_9371 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                else:
                    if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                        revert with 0, 34
                    _4025 = mem[64]
                    mem[64] = mem[64] + ceil32(sub_2c534595[address(arg1)][idx].field_1) + 32
                    mem[_4025] = sub_2c534595[address(arg1)][idx].field_1
                    if sub_2c534595[address(arg1)][idx].field_0:
                        if not sub_2c534595[address(arg1)][idx].field_0 - (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5 < 32):
                            revert with 0, 34
                        if not Mask(256, -1, sub_2c534595[address(arg1)][idx].field_0):
                            mem[_4019] = _4025
                            mem[_4019 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4019 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4019 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4019 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4066 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4066] = 30
                                mem[_4066 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4098 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4098 + 68] = mem[idx + _4066 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4098 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4098 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4243 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4243] = 26
                                mem[_4243 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4320 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4320 + 68] = mem[idx + _4243 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4320 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4320 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5598 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5598] = 26
                                            mem[_5598 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5858 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5858] = 26
                                            mem[_5858 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5599 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5599] = 26
                                            mem[_5599 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5859 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5859] = 26
                                            mem[_5859 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5856 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5856] = 26
                                        mem[_5856 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6286 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6286] = 26
                                        mem[_6286 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5857 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5857] = 26
                                        mem[_5857 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6287 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6287] = 26
                                        mem[_6287 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4211 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4211] = 30
                            mem[_4211 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4278 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4278 + 68] = mem[idx + _4211 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4278 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4278 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4550 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4550] = 26
                            mem[_4550 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4621 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4621 + 68] = mem[idx + _4550 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4621 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4621 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5920 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5920] = 26
                                        mem[_5920 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6394 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6394] = 26
                                        mem[_6394 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5921 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5921] = 26
                                        mem[_5921 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6395 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6395] = 26
                                        mem[_6395 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6392 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6392] = 26
                                    mem[_6392 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6972 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6972] = 26
                                    mem[_6972 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6393 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6393] = 26
                                    mem[_6393 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _6973 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6973] = 26
                                    mem[_6973 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            if 31 >= uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5:
                                mem[_4025 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                                mem[_4019] = _4025
                                mem[_4019 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4019 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4019 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4019 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _4100 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4100] = 30
                                    mem[_4100 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _4139 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4139 + 68] = mem[idx + _4100 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4139 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4139 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4321 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4321] = 26
                                    mem[_4321 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4418 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4418 + 68] = mem[idx + _4321 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4418 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4418 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5668 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5668] = 26
                                                mem[_5668 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5991 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5991] = 26
                                                mem[_5991 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5669 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5669] = 26
                                                mem[_5669 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _5992 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5992] = 26
                                                mem[_5992 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5989 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5989] = 26
                                            mem[_5989 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6500 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6500] = 26
                                            mem[_6500 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _5990 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5990] = 26
                                            mem[_5990 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6501 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6501] = 26
                                            mem[_6501 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _4281 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4281] = 30
                                mem[_4281 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _4374 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4374 + 68] = mem[idx + _4281 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4374 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4374 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4623 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4623] = 26
                                mem[_4623 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4721 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4721 + 68] = mem[idx + _4623 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4721 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4721 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6051 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6051] = 26
                                            mem[_6051 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6608 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6608] = 26
                                            mem[_6608 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6052 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6052] = 26
                                            mem[_6052 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6609 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6609] = 26
                                            mem[_6609 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6606 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6606] = 26
                                        mem[_6606 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7188 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7188] = 26
                                        mem[_7188 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6607 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6607] = 26
                                        mem[_6607 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7189 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7189] = 26
                                        mem[_7189 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                            else:
                                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_4025 + 32] = sub_2c534595[address(arg1)][idx].field_0
                                t = _4025 + 32
                                u = sha3(mem[0])
                                while _4025 + (uint255(sub_2c534595[address(arg1)][idx].field_0) * 0.5) > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_4019] = _4025
                                mem[_4019 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4019 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4019 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4019 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _8284 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8284] = 30
                                    mem[_8284 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _8320 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _8320 + 68] = mem[idx + _8284 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8320 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8320 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _8380 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8380] = 26
                                    mem[_8380 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _8404 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _8404 + 68] = mem[idx + _8380 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8404 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8404 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8844 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8844] = 26
                                                mem[_8844 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8952 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8952] = 26
                                                mem[_8952 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8845 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8845] = 26
                                                mem[_8845 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8953 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8953] = 26
                                                mem[_8953 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8950 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8950] = 26
                                            mem[_8950 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9114 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9114] = 26
                                            mem[_9114 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8951 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8951] = 26
                                            mem[_8951 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9115 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9115] = 26
                                            mem[_9115 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _8367 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8367] = 30
                                mem[_8367 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _8392 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8392 + 68] = mem[idx + _8367 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8392 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8392 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _8487 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8487] = 26
                                mem[_8487 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8500 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8500 + 68] = mem[idx + _8487 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8500 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8500 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8978 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8978] = 26
                                            mem[_8978 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9190 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9190] = 26
                                            mem[_9190 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8979 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8979] = 26
                                            mem[_8979 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9191 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9191] = 26
                                            mem[_9191 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9188 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9188] = 26
                                        mem[_9188 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9378 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9378] = 26
                                        mem[_9378 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9189 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9189] = 26
                                        mem[_9189 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9379 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9379] = 26
                                        mem[_9379 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                    else:
                        if not sub_2c534595[address(arg1)][idx].field_0 - (sub_2c534595[address(arg1)][idx].field_1 < 32):
                            revert with 0, 34
                        if not sub_2c534595[address(arg1)][idx].field_1:
                            mem[_4019] = _4025
                            mem[_4019 + 32] = sub_2c534595[address(arg1)][idx].field_256
                            mem[_4019 + 64] = sub_2c534595[address(arg1)][idx].field_512
                            mem[_4019 + 96] = sub_2c534595[address(arg1)][idx].field_768
                            mem[_4019 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                            if -sub_2c534595[address(arg1)][idx].field_512:
                                _4081 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4081] = 30
                                mem[_4081 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                    _4116 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4116 + 68] = mem[idx + _4081 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4116 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4116 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                    revert with 0, 17
                                _4282 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4282] = 26
                                mem[_4282 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4375 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4375 + 68] = mem[idx + _4282 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4375 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4375 + -mem[64] + 100
                                if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                    revert with 0, 17
                                if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5636 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5636] = 26
                                            mem[_5636 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5926 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5926] = 26
                                            mem[_5926 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _5637 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5637] = 26
                                            mem[_5637 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _5927 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_5927] = 26
                                            mem[_5927 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5924 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5924] = 26
                                        mem[_5924 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6400 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6400] = 26
                                        mem[_6400 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                        _5925 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5925] = 26
                                        mem[_5925 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6401 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6401] = 26
                                        mem[_6401 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            _4246 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4246] = 30
                            mem[_4246 + 32] = 'SafeMath: subtraction overflow'
                            if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                _4322 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _4322 + 68] = mem[idx + _4246 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4322 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _4322 + -mem[64] + 100
                            if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                revert with 0, 17
                            _4589 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4589] = 26
                            mem[_4589 + 32] = 'SafeMath: division by zero'
                            if not claimTime:
                                _4668 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4668 + 68] = mem[idx + _4589 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4668 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4668 + -mem[64] + 100
                            if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                revert with 0, 17
                            if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                revert with 0, 'SafeMath: addition overflow'
                            if not -rewardPerNode:
                                if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5993 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5993] = 26
                                        mem[_5993 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6510 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6510] = 26
                                        mem[_6510 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                        _5994 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_5994] = 26
                                        mem[_5994 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _6511 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6511] = 26
                                        mem[_6511 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                sub_2c534595[address(arg1)][idx].field_768 = 0
                                mem[0] = sha3(address(arg1), 10)
                                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                if not idx + 1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + sub_2c534595[address(arg1)][idx].field_768
                                continue 
                            if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                revert with 0, 17
                            if not rewardPerNode:
                                revert with 0, 18
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                revert with 0, 17
                            if idx >= sub_2c534595[address(arg1)].field_0:
                                revert with 0, 50
                            mem[0] = sha3(address(arg1), 10)
                            if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                revert with 0, 17
                            if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6508 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6508] = 26
                                    mem[_6508 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7086 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7086] = 26
                                    mem[_7086 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                        revert with 0, 17
                            else:
                                if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                    _6509 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_6509] = 26
                                    mem[_6509 + 32] = 'SafeMath: division by zero'
                                else:
                                    if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 18
                                    if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _7087 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_7087] = 26
                                    mem[_7087 + 32] = 'SafeMath: division by zero'
                                    if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                        revert with 0, 17
                        else:
                            if 31 >= sub_2c534595[address(arg1)][idx].field_1:
                                mem[_4025 + 32] = 256 * sub_2c534595[address(arg1)][idx].field_8
                                mem[_4019] = _4025
                                mem[_4019 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4019 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4019 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4019 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _4118 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4118] = 30
                                    mem[_4118 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _4160 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _4160 + 68] = mem[idx + _4118 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4160 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4160 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _4376 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_4376] = 26
                                    mem[_4376 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _4466 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _4466 + 68] = mem[idx + _4376 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_4466 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _4466 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5706 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5706] = 26
                                                mem[_5706 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _6058 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_6058] = 26
                                                mem[_6058 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _5707 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_5707] = 26
                                                mem[_5707 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _6059 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_6059] = 26
                                                mem[_6059 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _6056 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6056] = 26
                                            mem[_6056 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6612 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6612] = 26
                                            mem[_6612 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _6057 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6057] = 26
                                            mem[_6057 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6613 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6613] = 26
                                            mem[_6613 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _4325 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4325] = 30
                                mem[_4325 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _4424 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _4424 + 68] = mem[idx + _4325 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4424 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4424 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _4670 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_4670] = 26
                                mem[_4670 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _4775 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _4775 + 68] = mem[idx + _4670 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_4775 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _4775 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6124 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6124] = 26
                                            mem[_6124 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6706 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6706] = 26
                                            mem[_6706 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _6125 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6125] = 26
                                            mem[_6125 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _6707 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_6707] = 26
                                            mem[_6707 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6704 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6704] = 26
                                        mem[_6704 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7298 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7298] = 26
                                        mem[_7298 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _6705 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_6705] = 26
                                        mem[_6705 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _7299 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7299] = 26
                                        mem[_7299 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                            else:
                                mem[0] = (5 * idx) + sha3(sha3(address(arg1), 10))
                                mem[_4025 + 32] = sub_2c534595[address(arg1)][idx].field_0
                                t = _4025 + 32
                                u = sha3(mem[0])
                                while _4025 + sub_2c534595[address(arg1)][idx].field_1 > t:
                                    mem[t + 32] = uint256(stor1[u])
                                    t = t + 32
                                    u = u + 1
                                    continue 
                                mem[_4019] = _4025
                                mem[_4019 + 32] = sub_2c534595[address(arg1)][idx].field_256
                                mem[_4019 + 64] = sub_2c534595[address(arg1)][idx].field_512
                                mem[_4019 + 96] = sub_2c534595[address(arg1)][idx].field_768
                                mem[_4019 + 128] = sub_2c534595[address(arg1)][idx].field_1024
                                if -sub_2c534595[address(arg1)][idx].field_512:
                                    _8301 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8301] = 30
                                    mem[_8301 + 32] = 'SafeMath: subtraction overflow'
                                    if sub_2c534595[address(arg1)][idx].field_512 > block.timestamp:
                                        _8321 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _8321 + 68] = mem[idx + _8301 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8321 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8321 + -mem[64] + 100
                                    if block.timestamp < sub_2c534595[address(arg1)][idx].field_512:
                                        revert with 0, 17
                                    _8381 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_8381] = 26
                                    mem[_8381 + 32] = 'SafeMath: division by zero'
                                    if not claimTime:
                                        _8405 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _8405 + 68] = mem[idx + _8381 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_8405 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _8405 + -mem[64] + 100
                                    if 0 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime):
                                        revert with 0, 17
                                    if block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not -rewardPerNode:
                                        if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s > !sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        mem[0] = sha3(address(arg1), 10)
                                        if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                            revert with 0, 17
                                        if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8847 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8847] = 26
                                                mem[_8847 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8956 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8956] = 26
                                                mem[_8956 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                    revert with 0, 17
                                        else:
                                            if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                                _8848 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8848] = 26
                                                mem[_8848 + 32] = 'SafeMath: division by zero'
                                            else:
                                                if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 17
                                                if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                    revert with 0, 18
                                                if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _8957 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_8957] = 26
                                                mem[_8957 + 32] = 'SafeMath: division by zero'
                                                if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                    revert with 0, 17
                                        if idx >= sub_2c534595[address(arg1)].field_0:
                                            revert with 0, 50
                                        sub_2c534595[address(arg1)][idx].field_768 = 0
                                        mem[0] = sha3(address(arg1), 10)
                                        sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                        if not idx + 1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        s = s + sub_2c534595[address(arg1)][idx].field_768
                                        continue 
                                    if rewardPerNode and block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > -1 / rewardPerNode:
                                        revert with 0, 17
                                    if not rewardPerNode:
                                        revert with 0, 18
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime / rewardPerNode != block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 < rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !((rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768):
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8954 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8954] = 26
                                            mem[_8954 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9120 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9120] = 26
                                            mem[_9120 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) - sub_2c534595[address(arg1)][idx].field_768:
                                            _8955 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8955] = 26
                                            mem[_8955 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9121 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9121] = 26
                                            mem[_9121 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + (rewardPerNode * block.timestamp - sub_2c534595[address(arg1)][idx].field_512 / claimTime) + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                _8369 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8369] = 30
                                mem[_8369 + 32] = 'SafeMath: subtraction overflow'
                                if sub_2c534595[address(arg1)][idx].field_256 > block.timestamp:
                                    _8393 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _8393 + 68] = mem[idx + _8369 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8393 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8393 + -mem[64] + 100
                                if block.timestamp < sub_2c534595[address(arg1)][idx].field_256:
                                    revert with 0, 17
                                _8489 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_8489] = 26
                                mem[_8489 + 32] = 'SafeMath: division by zero'
                                if not claimTime:
                                    _8501 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _8501 + 68] = mem[idx + _8489 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_8501 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _8501 + -mem[64] + 100
                                if 1 > !(block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime):
                                    revert with 0, 17
                                if (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 < 1:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -rewardPerNode:
                                    if 0 > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s > !sub_2c534595[address(arg1)][idx].field_768:
                                        revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    mem[0] = sha3(address(arg1), 10)
                                    if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                        revert with 0, 17
                                    if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8980 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8980] = 26
                                            mem[_8980 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9196 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9196] = 26
                                            mem[_9196 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                                revert with 0, 17
                                    else:
                                        if not -s - sub_2c534595[address(arg1)][idx].field_768:
                                            _8981 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_8981] = 26
                                            mem[_8981 + 32] = 'SafeMath: division by zero'
                                        else:
                                            if s + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 17
                                            if not s + sub_2c534595[address(arg1)][idx].field_768:
                                                revert with 0, 18
                                            if (s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _9197 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_9197] = 26
                                            mem[_9197 + 32] = 'SafeMath: division by zero'
                                            if 0 > !((s * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                                revert with 0, 17
                                    if idx >= sub_2c534595[address(arg1)].field_0:
                                        revert with 0, 50
                                    sub_2c534595[address(arg1)][idx].field_768 = 0
                                    mem[0] = sha3(address(arg1), 10)
                                    sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                                    if not idx + 1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s + sub_2c534595[address(arg1)][idx].field_768
                                    continue 
                                if rewardPerNode and (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1 > -1 / rewardPerNode:
                                    revert with 0, 17
                                if not rewardPerNode:
                                    revert with 0, 18
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) / rewardPerNode != (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime) + 1:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) > !sub_2c534595[address(arg1)][idx].field_768:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_768 < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s > !(rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768):
                                    revert with 0, 17
                                if idx >= sub_2c534595[address(arg1)].field_0:
                                    revert with 0, 50
                                mem[0] = sha3(address(arg1), 10)
                                if sub_2c534595[address(arg1)][idx].field_512 > !claimDuration:
                                    revert with 0, 17
                                if sub_2c534595[address(arg1)][idx].field_512 + claimDuration > block.timestamp:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9194 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9194] = 26
                                        mem[_9194 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_af89f87c > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_af89f87c:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9386 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9386] = 26
                                        mem[_9386 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_af89f87c) + (rewardPerNode * sub_af89f87c) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_af89f87c) + (sub_2c534595[address(arg1)][idx].field_768 * sub_af89f87c) / 100):
                                            revert with 0, 17
                                else:
                                    if not -s - rewardPerNode - (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) - sub_2c534595[address(arg1)][idx].field_768:
                                        _9195 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9195] = 26
                                        mem[_9195 + 32] = 'SafeMath: division by zero'
                                    else:
                                        if s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 and sub_b137b854 > -1 / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 17
                                        if not s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768:
                                            revert with 0, 18
                                        if (s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768 != sub_b137b854:
                                            revert with 0, 'SafeMath: multiplication overflow'
                                        _9387 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_9387] = 26
                                        mem[_9387 + 32] = 'SafeMath: division by zero'
                                        if 0 > !((s * sub_b137b854) + (rewardPerNode * sub_b137b854) + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode * sub_b137b854) + (sub_2c534595[address(arg1)][idx].field_768 * sub_b137b854) / 100):
                                            revert with 0, 17
                if idx >= sub_2c534595[address(arg1)].field_0:
                    revert with 0, 50
                sub_2c534595[address(arg1)][idx].field_768 = 0
                mem[0] = sha3(address(arg1), 10)
                sub_2c534595[address(arg1)][idx].field_512 = block.timestamp
                if not idx + 1:
                    revert with 0, 17
                idx = idx + 1
                s = s + rewardPerNode + (block.timestamp - sub_2c534595[address(arg1)][idx].field_256 / claimTime * rewardPerNode) + sub_2c534595[address(arg1)][idx].field_768
                continue 
    return s, 0
}



}

contract main {




// =====================  Runtime code  =====================


function _fallback() payable {
    revert
}

function tokenURI(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if not chainid:
        mem[96] = 1
        mem[128] = 0x3000000000000000000000000000000000000000000000000000000000000000
        if not arg1:
            mem[256] = 'https://metadata.duo.cash/'
            mem[282] = 0x3000000000000000000000000000000000000000000000000000000000000000
            mem[283] = 0x2f00000000000000000000000000000000000000000000000000000000000000
            mem[284] = 0x3000000000000000000000000000000000000000000000000000000000000000
            mem[285] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            mem[290] = 32
            mem[322] = mem[224]
            mem[354 len ceil32(mem[224])] = mem[256 len ceil32(mem[224])]
            if ceil32(mem[224]) > mem[224]:
                mem[mem[224] + 354] = 0
            return Array(len=mem[224], data=mem[354 len ceil32(mem[224])])
        s = 0
        idx = arg1
        while idx:
            if s == -1:
                revert with 0, 17
            s = s + 1
            idx = idx / 10
            continue 
        if s > test266151307():
            revert with 0, 65
        mem[160] = s
        mem[64] = ceil32(s) + 192
        if not s:
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 0, 17
                if 48 > !(idx % 10):
                    revert with 0, 17
                if t - 1 >= mem[160]:
                    revert with 0, 50
                mem[t + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            _197 = mem[64]
            mem[mem[64] + 32] = 'https://metadata.duo.cash/'
            _199 = mem[96]
            mem[mem[64] + 58 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
            mem[mem[64] + mem[96] + 58] = 0x2f00000000000000000000000000000000000000000000000000000000000000
            if ceil32(mem[96]) <= mem[96]:
                _363 = mem[160]
                mem[_197 + _199 + 59 len ceil32(mem[160])] = mem[192 len ceil32(mem[160])]
                mem[_363 + _197 + _199 + 59] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_363) <= _363:
                    _629 = mem[64]
                    mem[64] = _363 + _197 + _199 + 64
                    mem[_363 + _197 + _199 + 64] = 32
                    _661 = mem[_629]
                    mem[_363 + _197 + _199 + 96] = mem[_629]
                    mem[_363 + _197 + _199 + 128 len ceil32(_661)] = mem[_629 + 32 len ceil32(_661)]
                    if ceil32(_661) > _661:
                        mem[_363 + _197 + _199 + _661 + 128] = 0
                    return 32, mem[_363 + _197 + _199 + 96 len ceil32(_661) + 32]
                _642 = mem[64]
                mem[64] = _363 + _197 + _199 + 64
                mem[_363 + _197 + _199 + 64] = 32
                _673 = mem[_642]
                mem[_363 + _197 + _199 + 96] = mem[_642]
                mem[_363 + _197 + _199 + 128 len ceil32(_673)] = mem[_642 + 32 len ceil32(_673)]
                if ceil32(_673) > _673:
                    mem[_363 + _197 + _199 + _673 + 128] = 0
                return 32, mem[_363 + _197 + _199 + 96 len ceil32(_673) + 32]
            _367 = mem[160]
            mem[_197 + _199 + 59 len ceil32(mem[160])] = mem[192 len ceil32(mem[160])]
            mem[_367 + _197 + _199 + 59] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_367) <= _367:
                _630 = mem[64]
                mem[64] = _367 + _197 + _199 + 64
                mem[_367 + _197 + _199 + 64] = 32
                _663 = mem[_630]
                mem[_367 + _197 + _199 + 96] = mem[_630]
                mem[_367 + _197 + _199 + 128 len ceil32(_663)] = mem[_630 + 32 len ceil32(_663)]
                if ceil32(_663) > _663:
                    mem[_367 + _197 + _199 + _663 + 128] = 0
                return 32, mem[_367 + _197 + _199 + 96 len ceil32(_663) + 32]
            _644 = mem[64]
            mem[64] = _367 + _197 + _199 + 64
            mem[_367 + _197 + _199 + 64] = 32
            _674 = mem[_644]
            mem[_367 + _197 + _199 + 96] = mem[_644]
            mem[_367 + _197 + _199 + 128 len ceil32(_674)] = mem[_644 + 32 len ceil32(_674)]
            if ceil32(_674) > _674:
                mem[_367 + _197 + _199 + _674 + 128] = 0
            return 32, mem[_367 + _197 + _199 + 96 len ceil32(_674) + 32]
        mem[192 len s] = call.data[calldata.size len s]
        t = s
        idx = arg1
        while idx:
            if t < 1:
                revert with 0, 17
            if 48 > !(idx % 10):
                revert with 0, 17
            if t - 1 >= mem[160]:
                revert with 0, 50
            mem[t + 191 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        _198 = mem[64]
        mem[mem[64] + 32] = 'https://metadata.duo.cash/'
        _200 = mem[96]
        mem[mem[64] + 58 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
        mem[mem[64] + mem[96] + 58] = 0x2f00000000000000000000000000000000000000000000000000000000000000
        if ceil32(mem[96]) <= mem[96]:
            _364 = mem[160]
            mem[_198 + _200 + 59 len ceil32(mem[160])] = mem[192 len ceil32(mem[160])]
            mem[_364 + _198 + _200 + 59] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_364) <= _364:
                _631 = mem[64]
                mem[64] = _364 + _198 + _200 + 64
                mem[_364 + _198 + _200 + 64] = 32
                _665 = mem[_631]
                mem[_364 + _198 + _200 + 96] = mem[_631]
                mem[_364 + _198 + _200 + 128 len ceil32(_665)] = mem[_631 + 32 len ceil32(_665)]
                if ceil32(_665) > _665:
                    mem[_364 + _198 + _200 + _665 + 128] = 0
                return 32, mem[_364 + _198 + _200 + 96 len ceil32(_665) + 32]
            _646 = mem[64]
            mem[64] = _364 + _198 + _200 + 64
            mem[_364 + _198 + _200 + 64] = 32
            _675 = mem[_646]
            mem[_364 + _198 + _200 + 96] = mem[_646]
            mem[_364 + _198 + _200 + 128 len ceil32(_675)] = mem[_646 + 32 len ceil32(_675)]
            if ceil32(_675) > _675:
                mem[_364 + _198 + _200 + _675 + 128] = 0
            return 32, mem[_364 + _198 + _200 + 96 len ceil32(_675) + 32]
        _368 = mem[160]
        mem[_198 + _200 + 59 len ceil32(mem[160])] = mem[192 len ceil32(mem[160])]
        mem[_368 + _198 + _200 + 59] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
        if ceil32(_368) <= _368:
            _632 = mem[64]
            mem[64] = _368 + _198 + _200 + 64
            mem[_368 + _198 + _200 + 64] = 32
            _667 = mem[_632]
            mem[_368 + _198 + _200 + 96] = mem[_632]
            mem[_368 + _198 + _200 + 128 len ceil32(_667)] = mem[_632 + 32 len ceil32(_667)]
            if ceil32(_667) > _667:
                mem[_368 + _198 + _200 + _667 + 128] = 0
            return 32, mem[_368 + _198 + _200 + 96 len ceil32(_667) + 32]
        _648 = mem[64]
        mem[64] = _368 + _198 + _200 + 64
        mem[_368 + _198 + _200 + 64] = 32
        _676 = mem[_648]
        mem[_368 + _198 + _200 + 96] = mem[_648]
        mem[_368 + _198 + _200 + 128 len ceil32(_676)] = mem[_648 + 32 len ceil32(_676)]
        if ceil32(_676) > _676:
            mem[_368 + _198 + _200 + _676 + 128] = 0
        return 32, mem[_368 + _198 + _200 + 96 len ceil32(_676) + 32]
    s = 0
    idx = chainid
    while idx:
        if s == -1:
            revert with 0, 17
        s = s + 1
        idx = idx / 10
        continue 
    if s > test266151307():
        revert with 0, 65
    mem[96] = s
    mem[64] = ceil32(s) + 128
    if not s:
        t = s
        idx = chainid
        while idx:
            if t < 1:
                revert with 0, 17
            if 48 > !(idx % 10):
                revert with 0, 17
            if t - 1 >= mem[96]:
                revert with 0, 50
            mem[t + 127 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        if not arg1:
            _201 = mem[64]
            mem[64] = mem[64] + 64
            mem[_201] = 1
            mem[_201 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
            _205 = mem[64]
            mem[mem[64] + 32] = 'https://metadata.duo.cash/'
            _211 = mem[96]
            mem[mem[64] + 58 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
            mem[mem[64] + mem[96] + 58] = 0x2f00000000000000000000000000000000000000000000000000000000000000
            mem[_205 + _211 + 59] = 0x3000000000000000000000000000000000000000000000000000000000000000
            mem[_205 + _211 + 60] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(mem[96]) <= mem[96]:
                _634 = mem[64]
                mem[64] = _205 + _211 + 65
                mem[_205 + _211 + 65] = 32
                _669 = mem[_634]
                mem[_205 + _211 + 97] = mem[_634]
                mem[_205 + _211 + 129 len ceil32(_669)] = mem[_634 + 32 len ceil32(_669)]
                if ceil32(_669) > _669:
                    mem[_205 + _211 + _669 + 129] = 0
                return 32, mem[_205 + _211 + 97 len ceil32(_669) + 32]
            _636 = mem[64]
            mem[64] = _205 + _211 + 65
            mem[_205 + _211 + 65] = 32
            _670 = mem[_636]
            mem[_205 + _211 + 97] = mem[_636]
            mem[_205 + _211 + 129 len ceil32(_670)] = mem[_636 + 32 len ceil32(_670)]
            if ceil32(_670) > _670:
                mem[_205 + _211 + _670 + 129] = 0
            return 32, mem[_205 + _211 + 97 len ceil32(_670) + 32]
        s = 0
        idx = arg1
        while idx:
            if s == -1:
                revert with 0, 17
            s = s + 1
            idx = idx / 10
            continue 
        if s > test266151307():
            revert with 0, 65
        _359 = mem[64]
        mem[mem[64]] = s
        mem[64] = mem[64] + ceil32(s) + 32
        if not s:
            t = s
            idx = arg1
            while idx:
                if t < 1:
                    revert with 0, 17
                if 48 > !(idx % 10):
                    revert with 0, 17
                if t - 1 >= mem[_359]:
                    revert with 0, 50
                mem[t + _359 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
                t = t - 1
                idx = idx / 10
                continue 
            _617 = mem[64]
            mem[mem[64] + 32] = 'https://metadata.duo.cash/'
            _621 = mem[96]
            mem[mem[64] + 58 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
            mem[mem[64] + mem[96] + 58] = 0x2f00000000000000000000000000000000000000000000000000000000000000
            if ceil32(mem[96]) <= mem[96]:
                _861 = mem[_359]
                mem[_617 + _621 + 59 len ceil32(mem[_359])] = mem[_359 + 32 len ceil32(mem[_359])]
                mem[_861 + _617 + _621 + 59] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
                if ceil32(_861) <= _861:
                    _1013 = mem[64]
                    mem[64] = _861 + _617 + _621 + 64
                    mem[_861 + _617 + _621 + 64] = 32
                    _1037 = mem[_1013]
                    mem[_861 + _617 + _621 + 96] = mem[_1013]
                    mem[_861 + _617 + _621 + 128 len ceil32(_1037)] = mem[_1013 + 32 len ceil32(_1037)]
                    if ceil32(_1037) > _1037:
                        mem[_861 + _617 + _621 + _1037 + 128] = 0
                    return 32, mem[_861 + _617 + _621 + 96 len ceil32(_1037) + 32]
                _1022 = mem[64]
                mem[64] = _861 + _617 + _621 + 64
                mem[_861 + _617 + _621 + 64] = 32
                _1053 = mem[_1022]
                mem[_861 + _617 + _621 + 96] = mem[_1022]
                mem[_861 + _617 + _621 + 128 len ceil32(_1053)] = mem[_1022 + 32 len ceil32(_1053)]
                if ceil32(_1053) > _1053:
                    mem[_861 + _617 + _621 + _1053 + 128] = 0
                return 32, mem[_861 + _617 + _621 + 96 len ceil32(_1053) + 32]
            _865 = mem[_359]
            mem[_617 + _621 + 59 len ceil32(mem[_359])] = mem[_359 + 32 len ceil32(mem[_359])]
            mem[_865 + _617 + _621 + 59] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_865) <= _865:
                _1014 = mem[64]
                mem[64] = _865 + _617 + _621 + 64
                mem[_865 + _617 + _621 + 64] = 32
                _1039 = mem[_1014]
                mem[_865 + _617 + _621 + 96] = mem[_1014]
                mem[_865 + _617 + _621 + 128 len ceil32(_1039)] = mem[_1014 + 32 len ceil32(_1039)]
                if ceil32(_1039) > _1039:
                    mem[_865 + _617 + _621 + _1039 + 128] = 0
                return 32, mem[_865 + _617 + _621 + 96 len ceil32(_1039) + 32]
            _1024 = mem[64]
            mem[64] = _865 + _617 + _621 + 64
            mem[_865 + _617 + _621 + 64] = 32
            _1054 = mem[_1024]
            mem[_865 + _617 + _621 + 96] = mem[_1024]
            mem[_865 + _617 + _621 + 128 len ceil32(_1054)] = mem[_1024 + 32 len ceil32(_1054)]
            if ceil32(_1054) > _1054:
                mem[_865 + _617 + _621 + _1054 + 128] = 0
            return 32, mem[_865 + _617 + _621 + 96 len ceil32(_1054) + 32]
        mem[_359 + 32 len s] = call.data[calldata.size len s]
        t = s
        idx = arg1
        while idx:
            if t < 1:
                revert with 0, 17
            if 48 > !(idx % 10):
                revert with 0, 17
            if t - 1 >= mem[_359]:
                revert with 0, 50
            mem[t + _359 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        _618 = mem[64]
        mem[mem[64] + 32] = 'https://metadata.duo.cash/'
        _622 = mem[96]
        mem[mem[64] + 58 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
        mem[mem[64] + mem[96] + 58] = 0x2f00000000000000000000000000000000000000000000000000000000000000
        if ceil32(mem[96]) <= mem[96]:
            _862 = mem[_359]
            mem[_618 + _622 + 59 len ceil32(mem[_359])] = mem[_359 + 32 len ceil32(mem[_359])]
            mem[_862 + _618 + _622 + 59] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_862) <= _862:
                _1015 = mem[64]
                mem[64] = _862 + _618 + _622 + 64
                mem[_862 + _618 + _622 + 64] = 32
                _1041 = mem[_1015]
                mem[_862 + _618 + _622 + 96] = mem[_1015]
                mem[_862 + _618 + _622 + 128 len ceil32(_1041)] = mem[_1015 + 32 len ceil32(_1041)]
                if ceil32(_1041) > _1041:
                    mem[_862 + _618 + _622 + _1041 + 128] = 0
                return 32, mem[_862 + _618 + _622 + 96 len ceil32(_1041) + 32]
            _1026 = mem[64]
            mem[64] = _862 + _618 + _622 + 64
            mem[_862 + _618 + _622 + 64] = 32
            _1055 = mem[_1026]
            mem[_862 + _618 + _622 + 96] = mem[_1026]
            mem[_862 + _618 + _622 + 128 len ceil32(_1055)] = mem[_1026 + 32 len ceil32(_1055)]
            if ceil32(_1055) > _1055:
                mem[_862 + _618 + _622 + _1055 + 128] = 0
            return 32, mem[_862 + _618 + _622 + 96 len ceil32(_1055) + 32]
        _866 = mem[_359]
        mem[_618 + _622 + 59 len ceil32(mem[_359])] = mem[_359 + 32 len ceil32(mem[_359])]
        mem[_866 + _618 + _622 + 59] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
        if ceil32(_866) <= _866:
            _1016 = mem[64]
            mem[64] = _866 + _618 + _622 + 64
            mem[_866 + _618 + _622 + 64] = 32
            _1043 = mem[_1016]
            mem[_866 + _618 + _622 + 96] = mem[_1016]
            mem[_866 + _618 + _622 + 128 len ceil32(_1043)] = mem[_1016 + 32 len ceil32(_1043)]
            if ceil32(_1043) > _1043:
                mem[_866 + _618 + _622 + _1043 + 128] = 0
            return 32, mem[_866 + _618 + _622 + 96 len ceil32(_1043) + 32]
        _1028 = mem[64]
        mem[64] = _866 + _618 + _622 + 64
        mem[_866 + _618 + _622 + 64] = 32
        _1056 = mem[_1028]
        mem[_866 + _618 + _622 + 96] = mem[_1028]
        mem[_866 + _618 + _622 + 128 len ceil32(_1056)] = mem[_1028 + 32 len ceil32(_1056)]
        if ceil32(_1056) > _1056:
            mem[_866 + _618 + _622 + _1056 + 128] = 0
        return 32, mem[_866 + _618 + _622 + 96 len ceil32(_1056) + 32]
    mem[128 len s] = call.data[calldata.size len s]
    t = s
    idx = chainid
    while idx:
        if t < 1:
            revert with 0, 17
        if 48 > !(idx % 10):
            revert with 0, 17
        if t - 1 >= mem[96]:
            revert with 0, 50
        mem[t + 127 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
        t = t - 1
        idx = idx / 10
        continue 
    if not arg1:
        _202 = mem[64]
        mem[64] = mem[64] + 64
        mem[_202] = 1
        mem[_202 + 32] = 0x3000000000000000000000000000000000000000000000000000000000000000
        _206 = mem[64]
        mem[mem[64] + 32] = 'https://metadata.duo.cash/'
        _212 = mem[96]
        mem[mem[64] + 58 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
        mem[mem[64] + mem[96] + 58] = 0x2f00000000000000000000000000000000000000000000000000000000000000
        mem[_206 + _212 + 59] = 0x3000000000000000000000000000000000000000000000000000000000000000
        mem[_206 + _212 + 60] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
        if ceil32(mem[96]) <= mem[96]:
            _638 = mem[64]
            mem[64] = _206 + _212 + 65
            mem[_206 + _212 + 65] = 32
            _671 = mem[_638]
            mem[_206 + _212 + 97] = mem[_638]
            mem[_206 + _212 + 129 len ceil32(_671)] = mem[_638 + 32 len ceil32(_671)]
            if ceil32(_671) > _671:
                mem[_206 + _212 + _671 + 129] = 0
            return 32, mem[_206 + _212 + 97 len ceil32(_671) + 32]
        _640 = mem[64]
        mem[64] = _206 + _212 + 65
        mem[_206 + _212 + 65] = 32
        _672 = mem[_640]
        mem[_206 + _212 + 97] = mem[_640]
        mem[_206 + _212 + 129 len ceil32(_672)] = mem[_640 + 32 len ceil32(_672)]
        if ceil32(_672) > _672:
            mem[_206 + _212 + _672 + 129] = 0
        return 32, mem[_206 + _212 + 97 len ceil32(_672) + 32]
    s = 0
    idx = arg1
    while idx:
        if s == -1:
            revert with 0, 17
        s = s + 1
        idx = idx / 10
        continue 
    if s > test266151307():
        revert with 0, 65
    _360 = mem[64]
    mem[mem[64]] = s
    mem[64] = mem[64] + ceil32(s) + 32
    if not s:
        t = s
        idx = arg1
        while idx:
            if t < 1:
                revert with 0, 17
            if 48 > !(idx % 10):
                revert with 0, 17
            if t - 1 >= mem[_360]:
                revert with 0, 50
            mem[t + _360 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
            t = t - 1
            idx = idx / 10
            continue 
        _619 = mem[64]
        mem[mem[64] + 32] = 'https://metadata.duo.cash/'
        _623 = mem[96]
        mem[mem[64] + 58 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
        mem[mem[64] + mem[96] + 58] = 0x2f00000000000000000000000000000000000000000000000000000000000000
        if ceil32(mem[96]) <= mem[96]:
            _863 = mem[_360]
            mem[_619 + _623 + 59 len ceil32(mem[_360])] = mem[_360 + 32 len ceil32(mem[_360])]
            mem[_863 + _619 + _623 + 59] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
            if ceil32(_863) <= _863:
                _1017 = mem[64]
                mem[64] = _863 + _619 + _623 + 64
                mem[_863 + _619 + _623 + 64] = 32
                _1045 = mem[_1017]
                mem[_863 + _619 + _623 + 96] = mem[_1017]
                mem[_863 + _619 + _623 + 128 len ceil32(_1045)] = mem[_1017 + 32 len ceil32(_1045)]
                if ceil32(_1045) > _1045:
                    mem[_863 + _619 + _623 + _1045 + 128] = 0
                return 32, mem[_863 + _619 + _623 + 96 len ceil32(_1045) + 32]
            _1030 = mem[64]
            mem[64] = _863 + _619 + _623 + 64
            mem[_863 + _619 + _623 + 64] = 32
            _1057 = mem[_1030]
            mem[_863 + _619 + _623 + 96] = mem[_1030]
            mem[_863 + _619 + _623 + 128 len ceil32(_1057)] = mem[_1030 + 32 len ceil32(_1057)]
            if ceil32(_1057) > _1057:
                mem[_863 + _619 + _623 + _1057 + 128] = 0
            return 32, mem[_863 + _619 + _623 + 96 len ceil32(_1057) + 32]
        _871 = mem[_360]
        mem[_619 + _623 + 59 len ceil32(mem[_360])] = mem[_360 + 32 len ceil32(mem[_360])]
        mem[_871 + _619 + _623 + 59] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
        if ceil32(_871) <= _871:
            _1018 = mem[64]
            mem[64] = _871 + _619 + _623 + 64
            mem[_871 + _619 + _623 + 64] = 32
            _1047 = mem[_1018]
            mem[_871 + _619 + _623 + 96] = mem[_1018]
            mem[_871 + _619 + _623 + 128 len ceil32(_1047)] = mem[_1018 + 32 len ceil32(_1047)]
            if ceil32(_1047) > _1047:
                mem[_871 + _619 + _623 + _1047 + 128] = 0
            return 32, mem[_871 + _619 + _623 + 96 len ceil32(_1047) + 32]
        _1032 = mem[64]
        mem[64] = _871 + _619 + _623 + 64
        mem[_871 + _619 + _623 + 64] = 32
        _1058 = mem[_1032]
        mem[_871 + _619 + _623 + 96] = mem[_1032]
        mem[_871 + _619 + _623 + 128 len ceil32(_1058)] = mem[_1032 + 32 len ceil32(_1058)]
        if ceil32(_1058) > _1058:
            mem[_871 + _619 + _623 + _1058 + 128] = 0
        return 32, mem[_871 + _619 + _623 + 96 len ceil32(_1058) + 32]
    mem[_360 + 32 len s] = call.data[calldata.size len s]
    t = s
    idx = arg1
    while idx:
        if t < 1:
            revert with 0, 17
        if 48 > !(idx % 10):
            revert with 0, 17
        if t - 1 >= mem[_360]:
            revert with 0, 50
        mem[t + _360 + 31 len 8] = Mask(8, -(('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) + 256, 0) << (('mask_shl', 8, 0, 245, ('add', 48, ('mod', ('var', 0), 10))), 0) - 256
        t = t - 1
        idx = idx / 10
        continue 
    _620 = mem[64]
    mem[mem[64] + 32] = 'https://metadata.duo.cash/'
    _624 = mem[96]
    mem[mem[64] + 58 len ceil32(mem[96])] = mem[128 len ceil32(mem[96])]
    mem[mem[64] + mem[96] + 58] = 0x2f00000000000000000000000000000000000000000000000000000000000000
    if ceil32(mem[96]) <= mem[96]:
        _864 = mem[_360]
        mem[_620 + _624 + 59 len ceil32(mem[_360])] = mem[_360 + 32 len ceil32(mem[_360])]
        mem[_864 + _620 + _624 + 59] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
        if ceil32(_864) <= _864:
            _1019 = mem[64]
            mem[64] = _864 + _620 + _624 + 64
            mem[_864 + _620 + _624 + 64] = 32
            _1049 = mem[_1019]
            mem[_864 + _620 + _624 + 96] = mem[_1019]
            mem[_864 + _620 + _624 + 128 len ceil32(_1049)] = mem[_1019 + 32 len ceil32(_1049)]
            if ceil32(_1049) > _1049:
                mem[_864 + _620 + _624 + _1049 + 128] = 0
            return 32, mem[_864 + _620 + _624 + 96 len ceil32(_1049) + 32]
        _1034 = mem[64]
        mem[64] = _864 + _620 + _624 + 64
        mem[_864 + _620 + _624 + 64] = 32
        _1059 = mem[_1034]
        mem[_864 + _620 + _624 + 96] = mem[_1034]
        mem[_864 + _620 + _624 + 128 len ceil32(_1059)] = mem[_1034 + 32 len ceil32(_1059)]
        if ceil32(_1059) > _1059:
            mem[_864 + _620 + _624 + _1059 + 128] = 0
        return 32, mem[_864 + _620 + _624 + 96 len ceil32(_1059) + 32]
    _872 = mem[_360]
    mem[_620 + _624 + 59 len ceil32(mem[_360])] = mem[_360 + 32 len ceil32(mem[_360])]
    mem[_872 + _620 + _624 + 59] = 0x2e6a736f6e000000000000000000000000000000000000000000000000000000
    if ceil32(_872) <= _872:
        _1020 = mem[64]
        mem[64] = _872 + _620 + _624 + 64
        mem[_872 + _620 + _624 + 64] = 32
        _1051 = mem[_1020]
        mem[_872 + _620 + _624 + 96] = mem[_1020]
        mem[_872 + _620 + _624 + 128 len ceil32(_1051)] = mem[_1020 + 32 len ceil32(_1051)]
        if ceil32(_1051) > _1051:
            mem[_872 + _620 + _624 + _1051 + 128] = 0
        return 32, mem[_872 + _620 + _624 + 96 len ceil32(_1051) + 32]
    _1036 = mem[64]
    mem[64] = _872 + _620 + _624 + 64
    mem[_872 + _620 + _624 + 64] = 32
    _1060 = mem[_1036]
    mem[_872 + _620 + _624 + 96] = mem[_1036]
    mem[_872 + _620 + _624 + 128 len ceil32(_1060)] = mem[_1036 + 32 len ceil32(_1060)]
    if ceil32(_1060) > _1060:
        mem[_872 + _620 + _624 + _1060 + 128] = 0
    return 32, mem[_872 + _620 + _624 + 96 len ceil32(_1060) + 32]
}



}

contract main {




// =====================  Runtime code  =====================


#
#  - sub_2463f886(?)
#  - sub_c0583f54(?)
#
const CANNOT_TRANSFER_TO_ZERO_ADDRESS = '', 0

const NOT_CURRENT_OWNER = '', 0


mapping of uint8 stor0;
mapping of address ownerOf;
mapping of address approved;
mapping of uint256 balanceOf;
mapping of uint8 stor4;
array of struct stor5;
array of struct stor6;
mapping of struct stor7;
address owner;
uint256 stor9;
uint8 stor10;
address stor10; offset 8
uint256 stor11;
uint256 stor12;
address stor13;
uint8 stor14; offset 160
uint128 stor14; offset 160
address stor14;
mapping of uint8 stor15;
mapping of uint256 stor16;
uint256 stor17;
uint256 stor18;
uint256 stor19;
uint256 sub_ee218db4;
address stor21;
uint256 sub_418bc156;
uint256 sub_518b057e;
uint256 sub_5cdedc5a;
uint256 sub_ebe9505f;
uint256 sub_0f58fa4d;
mapping of uint8 stor27;
mapping of uint8 stor28;
uint8 stor29;
uint8 stor29; offset 8
uint256 stor29; offset 16
uint256 stor29; offset 8
array of struct bids;
array of uint256 sub_9f2db3cb;
array of uint256 sub_ebbed411;
array of uint256 sub_3f88d08a;
mapping of uint8 stor35;
array of uint256 sub_07889cc9;
mapping of uint256 sub_17cd4006;
mapping of uint8 stor38;
mapping of uint8 stor39;
array of address sub_b42b22d6;
mapping of uint8 stor41;
mapping of uint32 sub_a370c668;
mapping of uint8 stor43;
mapping of uint256 sub_63873525;
uint256 sub_002e9fb2;
mapping of uint256 sub_c38694a5;
mapping of uint256 sub_95ddf83a;
uint256 stor48;
uint256 sub_fff7744d;
mapping of uint256 sub_ec5fe15c;
uint256 sub_9019abdf;
uint256 sub_9b175d77;
uint256 sub_362f53ca;
mapping of uint256 sub_92f62add;
uint256 sub_44ba33e5;
mapping of uint8 stor99;
array of uint256 stor56459948693323644898937646006184091555812749125396784253147221160512369864388;
array of address stor101964144617176178944956896727109546813812234501443366685622805217804010617525;

function sub_002e9fb2(?) {
    return sub_002e9fb2
}

function supportsInterface(bytes4 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == Mask(32, 224, arg1)
    return bool(stor0[Mask(32, 224, arg1)])
}

function sub_07889cc9(?) {
    require calldata.size - 4 >= 32
    require arg1 < sub_07889cc9.length
    return sub_07889cc9[arg1]
}

function getApproved(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0, '', 0
    return approved[arg1]
}

function sub_0f58fa4d(?) {
    return sub_0f58fa4d
}

function sub_1268cc3c(?) {
    return sub_07889cc9.length
}

function sub_17cd4006(?) {
    require calldata.size - 4 >= 32
    return sub_17cd4006[arg1]
}

function sub_2c1fdecd(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    return bool(stor35[arg1][arg2])
}

function sub_2dfe0382(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return bool(stor39[arg1])
}

function sub_362f53ca(?) {
    return sub_362f53ca
}

function sub_3f88d08a(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_3f88d08a[address(arg1)]
}

function sub_418bc156(?) {
    return sub_418bc156
}

function sub_44ba33e5(?) {
    return sub_44ba33e5
}

function sub_518b057e(?) {
    return sub_518b057e
}

function categories(string arg1) {
    require calldata.size - 4 >= 32
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    require arg1 + arg1.length + 36 <= calldata.size
    return bool(stor41[arg1[all]])
}

function sub_5cdedc5a(?) {
    return sub_5cdedc5a
}

function ownerOf(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0, '', 0
    return ownerOf[arg1]
}

function sub_63873525(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_63873525[arg1]
}

function balanceOf(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if not arg1:
        revert with 0, '', 0
    return balanceOf[address(arg1)]
}

function sub_72aaad5e(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 < sub_3f88d08a[arg1]
    return sub_3f88d08a[arg1][arg2]
}

function bids(uint256 arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg2 < uint256(bids[arg1].field_0)
    return address(bids[arg1][arg2].field_0), uint256(bids[arg1][arg2].field_256)
}

function owner() {
    return owner
}

function sub_9019abdf(?) {
    return sub_9019abdf
}

function sub_92f62add(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    return sub_92f62add[arg1][arg2]
}

function sub_95ddf83a(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_95ddf83a[arg1]
}

function sub_9b175d77(?) {
    return sub_9b175d77
}

function sub_9f2db3cb(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_9f2db3cb[address(arg1)]
}

function sub_a370c668(?) {
    require calldata.size - 4 >= 32
    return sub_a370c668[arg1]
}

function sub_b42b22d6(?) {
    require calldata.size - 4 >= 32
    require arg1 < sub_b42b22d6.length
    return sub_b42b22d6[arg1]
}

function sub_c38694a5(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_c38694a5[arg1]
}

function isStaff(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor38[arg1])
}

function sub_cc182f1c(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 < sub_9f2db3cb[arg1]
    return sub_9f2db3cb[arg1][arg2]
}

function isApprovedForAll(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return bool(stor4[address(arg1)][address(arg2)])
}

function sub_ebbed411(?) {
    require calldata.size - 4 >= 64
    require arg2 == address(arg2)
    return sub_ebbed411[address(arg2)][arg1]
}

function sub_ebe9505f(?) {
    return sub_ebe9505f
}

function sub_ec5fe15c(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    return sub_ec5fe15c[arg1][arg2]
}

function sub_ee218db4(?) {
    return sub_ee218db4
}

function sub_fdfdbd2f(?) {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg3 < sub_ebbed411[arg1][arg2]
    return sub_ebbed411[arg1][arg2][arg3]
}

function sub_fff7744d(?) {
    return sub_fff7744d
}

function _fallback() payable {
    revert
}

function sub_013869bf(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, '', 0
    stor18 = arg1
}

function setPlatformFee(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, '', 0
    stor17 = arg1
}

function updateDevSplit(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, '', 0
    stor11 = arg1
}

function setDistributionFee(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, '', 0
    stor12 = arg1
}

function sub_126c3073(?) {
    require calldata.size - 4 >= 64
    if owner != msg.sender:
        revert with 0, '', 0
    sub_ebe9505f = arg1
    sub_0f58fa4d = arg2
}

function updateMarketingWallet(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, '', 0
    stor21 = arg1
}

function sub_3c2894b0(?) {
    require calldata.size - 4 >= 96
    if owner != msg.sender:
        revert with 0, '', 0
    sub_418bc156 = arg3
    sub_518b057e = arg2
    sub_5cdedc5a = arg1
}

function updateDistrinution(bool arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, '', 0
    Mask(96, 0, stor14.field_160) = Mask(96, 0, arg1)
}

function updateStaff(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, '', 0
    stor38[address(arg1)] = uint8(arg2)
}

function setTrading(bool arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        if not stor38[msg.sender]:
            revert with 0, 'Staff only'
    uint8(stor10.field_0) = uint8(arg1)
}

function setApprovalForAll(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    stor4[msg.sender][address(arg1)] = uint8(arg2)
    emit ApprovalForAll(arg2, msg.sender, arg1);
}

function sub_a768a98a(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    if owner != msg.sender:
        revert with 0, '', 0
    stor13 = address(arg1)
    address(stor14.field_0) = address(arg2)
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, '', 0
    if not arg1:
        revert with 0, '', 0
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function sub_1fe8845b(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == bool(arg2)
    if owner != msg.sender:
        if not stor38[msg.sender]:
            revert with 0, 'Staff only'
    stor28[address(arg1)] = uint8(bool(arg2))
}

function sub_82277c64(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == bool(arg2)
    if owner != msg.sender:
        if not stor38[msg.sender]:
            revert with 0, 'Staff only'
    stor27[address(arg1)] = uint8(bool(arg2))
}

function sub_070baa78(?) {
    require calldata.size - 4 >= 32
    if stor43[msg.sender][arg1]:
        revert with 0, 'Already flagged this sale'
    stor43[msg.sender][arg1] = 1
    if sub_a370c668[arg1] > 4294967294:
        revert with 0, 17
    sub_a370c668[arg1] = uint32(sub_a370c668[arg1] + 1)
}

function sub_09050010(?) {
    require calldata.size - 4 >= 32
    if uint256(stor30[arg1].field_1280):
        return block.timestamp >= uint256(stor30[arg1].field_1280)
    if uint256(stor30[arg1].field_3072) > !sub_418bc156:
        revert with 0, 17
    return block.timestamp >= uint256(stor30[arg1].field_3072) + sub_418bc156
}

function sub_3c52a061(?) {
    require calldata.size - 4 >= 64
    require arg1 == bool(arg1)
    require arg2 == bool(arg2)
    if owner != msg.sender:
        if not stor38[msg.sender]:
            revert with 0, 'Staff only'
    uint8(stor29.field_0) = uint8(bool(arg1))
    Mask(248, 0, stor29.field_8) = Mask(248, 0, bool(arg2))
    Mask(240, 0, stor29.field_16) = Mask(240, 16, bool(arg1)) >> 16
}

function approve(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if ownerOf[arg2] != msg.sender:
        if not stor4[stor1[arg2]][msg.sender]:
            revert with 0, '', 0
    if not ownerOf[arg2]:
        revert with 0, '', 0
    if ownerOf[arg2] == arg1:
        revert with 0, '', 0
    approved[arg2] = arg1
    emit Approval(ownerOf[arg2], arg1, arg2);
}

function sub_bca726d6(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    if not sub_ebbed411[address(arg1)][arg2]:
        return 0
    if sub_ebbed411[address(arg1)][arg2] < 1:
        revert with 0, 17
    if sub_ebbed411[address(arg1)][arg2] - 1 >= sub_ebbed411[address(arg1)][arg2]:
        revert with 0, 50
    return sub_ebbed411[address(arg1)][arg2][sub_ebbed411[address(arg1)][arg2]]
}

function sub_6845d6aa(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, '', 0
    stor16[address(arg1)] = arg2
    require ext_code.size(address(stor14.field_0))
    call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
         gas gas_remaining wei
        args address(arg1), arg2
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function onERC721Received(address arg1, address arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if not stor35[msg.sender][arg3]:
        revert with 0, 'Send tokens through createSale'
    return 0x150b7a0200000000000000000000000000000000000000000000000000000000
}

function sub_0ca38955(?) {
    require calldata.size - 4 >= 32
    require arg1 == bool(arg1)
    if owner != msg.sender:
        revert with 0, '', 0
    if not arg1:
        require ext_code.size(stor13)
        call stor13.startDistribution() with:
             gas gas_remaining wei
    else:
        require ext_code.size(address(stor14.field_0))
        call address(stor14.field_0).startDistribution() with:
             gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function claim() {
    require ext_code.size(address(stor14.field_0))
    staticcall address(stor14.field_0).getUnpaidRewards(address rg1) with:
            gas gas_remaining wei
           args msg.sender
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] > 0:
        require ext_code.size(address(stor14.field_0))
        call address(stor14.field_0).claim(address rg1) with:
             gas gas_remaining wei
            args msg.sender
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
}

function sub_284b28b4(?) {
    require calldata.size - 4 >= 32
    if not uint256(bids[arg1].field_0):
        return 0
    idx = 0
    s = 0
    while idx < uint256(bids[arg1].field_0):
        if idx >= uint256(bids[arg1].field_0):
            revert with 0, 50
        if address(bids[arg1][idx].field_0) != address(stor30[arg1].field_2048):
            if idx == -1:
                revert with 0, 17
            mem[0] = arg1
            mem[32] = 31
            idx = idx + 1
            s = s
            continue 
        if s > -2:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        mem[0] = arg1
        mem[32] = 31
        idx = idx + 1
        s = s + 1
        continue 
    return s
}

function myDistribution(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require ext_code.size(address(stor14.field_0))
    staticcall address(stor14.field_0).getUnpaidRewards(address rg1) with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_code.size(address(stor14.field_0))
    staticcall address(stor14.field_0).getPaidRewards(address rg1) with:
            gas gas_remaining wei
           args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    return ext_call.return_data[0], ext_call.return_data[0]
}

function transferFrom(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if ownerOf[arg3] != msg.sender:
        if approved[arg3] != msg.sender:
            if not stor4[stor1[arg3]][msg.sender]:
                revert with 0, '', 0
    if not ownerOf[arg3]:
        revert with 0, '', 0
    if ownerOf[arg3] != arg1:
        revert with 0, '', 0
    if not arg2:
        revert with 0, '', 0
    approved[arg3] = 0
    if ownerOf[arg3] != ownerOf[arg3]:
        revert with 0, '', 0
    if balanceOf[stor1[arg3]] < 1:
        revert with 0, 17
    balanceOf[stor1[arg3]]--
    ownerOf[arg3] = 0
    if ownerOf[arg3]:
        revert with 0, '', 0
    ownerOf[arg3] = arg2
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    emit Transfer(ownerOf[arg3], arg2, arg3);
}

function sub_24d91d16(?) {
    require calldata.size - 4 >= 64
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    if arg1.length > test266151307():
        revert with 0, 65
    if ceil32(ceil32(arg1.length)) + 97 < 96 or ceil32(ceil32(arg1.length)) + 97 > test266151307():
        revert with 0, 65
    require arg1 + arg1.length + 36 <= calldata.size
    require arg2 == bool(arg2)
    if owner != msg.sender:
        revert with 0, '', 0
    uint8(stor[Mask(8 * -ceil32(arg1.length) + arg1.length + 32, 0, 41)][Mask(8 * ceil32(arg1.length), -(8 * ceil32(arg1.length)) + 256, arg1[all], Mask(8 * ceil32(arg1.length) - arg1.length, -(8 * ceil32(arg1.length) + -ceil32(ceil32(arg1.length)) + 31) + 256, 6) >> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff08 + (8 * -ceil32(arg1.length)) + (8 * ceil32(ceil32(arg1.length))) + 256) << (8 * ceil32(arg1.length)) - 256]) = uint8(bool(arg2))
}

function sub_2406f50d(?) {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg2 == bool(arg2)
    require arg3 == bool(arg3)
    if owner != msg.sender:
        revert with 0, '', 0
    if not arg2:
        if arg3:
            require ext_code.size(stor13)
            call stor13.migrate(address rg1) with:
                 gas gas_remaining wei
                args address(arg1)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
        stor13 = address(arg1)
    else:
        if arg3:
            require ext_code.size(address(stor14.field_0))
            call address(stor14.field_0).migrate(address rg1) with:
                 gas gas_remaining wei
                args address(arg1)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
        address(stor14.field_0) = address(arg1)
}

function getPaid() {
    if owner != msg.sender:
        revert with 0, '', 0
    if eth.balance(this.address) < sub_ee218db4:
        revert with 0, 17
    if eth.balance(this.address) - sub_ee218db4:
        if eth.balance(this.address) - sub_ee218db4 and stor11 > -1 / eth.balance(this.address) - sub_ee218db4:
            revert with 0, 17
        call address(stor10.field_8) with:
           value (eth.balance(this.address) * stor11) - (sub_ee218db4 * stor11) / 100 wei
             gas 2300 * is_zero(value) wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if eth.balance(this.address) - sub_ee218db4 < (eth.balance(this.address) * stor11) - (sub_ee218db4 * stor11) / 100:
            revert with 0, 17
        call stor21 with:
           value eth.balance(this.address) - sub_ee218db4 - ((eth.balance(this.address) * stor11) - (sub_ee218db4 * stor11) / 100) wei
             gas 2300 * is_zero(value) wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
}

function safeTransferFrom(address arg1, address arg2, uint256 arg3) {
    require calldata.size - 4 >= 96
    require arg1 == arg1
    require arg2 == arg2
    if ownerOf[arg3] != msg.sender:
        if approved[arg3] != msg.sender:
            if not stor4[stor1[arg3]][msg.sender]:
                revert with 0, '', 0
    if not ownerOf[arg3]:
        revert with 0, '', 0
    if ownerOf[arg3] != arg1:
        revert with 0, '', 0
    if not arg2:
        revert with 0, '', 0
    approved[arg3] = 0
    if ownerOf[arg3] != ownerOf[arg3]:
        revert with 0, '', 0
    if balanceOf[stor1[arg3]] < 1:
        revert with 0, 17
    balanceOf[stor1[arg3]]--
    ownerOf[arg3] = 0
    if ownerOf[arg3]:
        revert with 0, '', 0
    ownerOf[arg3] = arg2
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    emit Transfer(ownerOf[arg3], arg2, arg3);
    if ext_code.hash(arg2):
        if ext_code.hash(arg2) != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
            require ext_code.size(arg2)
            call arg2.0x150b7a02 with:
                 gas gas_remaining wei
                args msg.sender, address(arg1), arg3, 128, 0
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
            if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                revert with 0, '', 0
}

function safeTransferFrom(address arg1, address arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg2 == arg2
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    if ownerOf[arg3] != msg.sender:
        if approved[arg3] != msg.sender:
            if not stor4[stor1[arg3]][msg.sender]:
                revert with 0, '', 0
    if not ownerOf[arg3]:
        revert with 0, '', 0
    if ownerOf[arg3] != arg1:
        revert with 0, '', 0
    if not arg2:
        revert with 0, '', 0
    approved[arg3] = 0
    if ownerOf[arg3] != ownerOf[arg3]:
        revert with 0, '', 0
    if balanceOf[stor1[arg3]] < 1:
        revert with 0, 17
    balanceOf[stor1[arg3]]--
    ownerOf[arg3] = 0
    if ownerOf[arg3]:
        revert with 0, '', 0
    ownerOf[arg3] = arg2
    if balanceOf[address(arg2)] > -2:
        revert with 0, 17
    balanceOf[address(arg2)]++
    emit Transfer(ownerOf[arg3], arg2, arg3);
    if ext_code.hash(arg2):
        if ext_code.hash(arg2) != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
            require ext_code.size(arg2)
            call arg2.0x150b7a02 with:
                 gas gas_remaining wei
                args msg.sender, address(arg1), arg3, Array(len=arg4.length, data=arg4[all])
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == Mask(32, 224, ext_call.return_data[0])
            if Mask(32, 224, ext_call.return_data[0]) != 0x150b7a0200000000000000000000000000000000000000000000000000000000:
                revert with 0, '', 0
}

function cancelSale(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not stor35[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
        revert with 0, 'No active sale'
    if owner != msg.sender:
        if not stor38[msg.sender]:
            if address(stor30[arg1].field_2048) != msg.sender:
                revert with 0, 'Not token owner'
            if address(stor30[arg1].field_2304):
                revert with 0, 'Sale already active'
    if not uint256(bids[arg1].field_0):
        uint256(stor30[arg1].field_1536) = 1
        stor35[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] = 0
        if sub_07889cc9.length < 1:
            revert with 0, 17
        if sub_07889cc9.length - 1 >= sub_07889cc9.length:
            revert with 0, 50
        if sub_17cd4006[arg1] >= sub_07889cc9.length:
            revert with 0, 50
        sub_07889cc9[stor37[arg1]] = sub_07889cc9[sub_07889cc9.length]
        if sub_07889cc9.length < 1:
            revert with 0, 17
        if sub_07889cc9.length - 1 >= sub_07889cc9.length:
            revert with 0, 50
        sub_17cd4006[stor36[stor36.length]] = sub_17cd4006[arg1]
        if not sub_07889cc9.length:
            revert with 0, 49
        sub_07889cc9[sub_07889cc9.length] = 0
        sub_07889cc9.length--
        require ext_code.size(address(stor30[arg1].field_2560))
        call address(stor30[arg1].field_2560).0x42842e0e with:
             gas gas_remaining wei
            args this.address, address(stor30[arg1].field_2048), uint256(stor30[arg1].field_256)
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    else:
        if uint256(bids[arg1].field_0) < 1:
            revert with 0, 17
        if uint256(bids[arg1].field_0) - 1 >= uint256(bids[arg1].field_0):
            revert with 0, 50
        uint256(stor30[arg1].field_1536) = 1
        stor35[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] = 0
        if sub_07889cc9.length < 1:
            revert with 0, 17
        if sub_07889cc9.length - 1 >= sub_07889cc9.length:
            revert with 0, 50
        if sub_17cd4006[arg1] >= sub_07889cc9.length:
            revert with 0, 50
        sub_07889cc9[stor37[arg1]] = sub_07889cc9[sub_07889cc9.length]
        if sub_07889cc9.length < 1:
            revert with 0, 17
        if sub_07889cc9.length - 1 >= sub_07889cc9.length:
            revert with 0, 50
        sub_17cd4006[stor36[stor36.length]] = sub_17cd4006[arg1]
        if not sub_07889cc9.length:
            revert with 0, 49
        sub_07889cc9[sub_07889cc9.length] = 0
        sub_07889cc9.length--
        require ext_code.size(address(stor30[arg1].field_2560))
        call address(stor30[arg1].field_2560).0x42842e0e with:
             gas gas_remaining wei
            args this.address, address(stor30[arg1].field_2048), uint256(stor30[arg1].field_256)
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) > 0:
            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) and stor18 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                revert with 0, 17
            if not stor19:
                revert with 0, 18
            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor18 / stor19:
                revert with 0, 17
            call address(stor30[arg1].field_2304) with:
               value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor18 / stor19) wei
                 gas 2300 * is_zero(value) wei
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
}

function name() {
    if bool(stor5.length):
        if bool(stor5.length) == uint255(stor5.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor5.length):
            if bool(stor5.length) == uint255(stor5.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor5.length):
                if 31 < uint255(stor5.length) * 0.5:
                    mem[128] = uint256(stor5.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor5.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = uint256(stor5[s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor5.length), data=mem[128 len ceil32(uint255(stor5.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor5.length.field_8)
        else:
            if bool(stor5.length) == stor5.length.field_1 % 128 < 32:
                revert with 0, 34
            if stor5.length.field_1 % 128:
                if 31 < stor5.length.field_1 % 128:
                    mem[128] = uint256(stor5.field_0)
                    idx = 128
                    s = 0
                    while stor5.length.field_1 % 128 + 96 > idx:
                        mem[idx + 32] = uint256(stor5[s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor5.length), data=mem[128 len ceil32(uint255(stor5.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor5.length.field_8)
        mem[ceil32(uint255(stor5.length) * 0.5) + 192 len ceil32(uint255(stor5.length) * 0.5)] = mem[128 len ceil32(uint255(stor5.length) * 0.5)]
        if ceil32(uint255(stor5.length) * 0.5) > uint255(stor5.length) * 0.5:
            mem[(uint255(stor5.length) * 0.5) + ceil32(uint255(stor5.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor5.length), data=mem[128 len ceil32(uint255(stor5.length) * 0.5)], mem[(2 * ceil32(uint255(stor5.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor5.length) * 0.5)]), 
    if bool(stor5.length) == stor5.length.field_1 % 128 < 32:
        revert with 0, 34
    if bool(stor5.length):
        if bool(stor5.length) == uint255(stor5.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor5.length):
            if 31 < uint255(stor5.length) * 0.5:
                mem[128] = uint256(stor5.field_0)
                idx = 128
                s = 0
                while (uint255(stor5.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = uint256(stor5[s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor5.length.field_8)
    else:
        if bool(stor5.length) == stor5.length.field_1 % 128 < 32:
            revert with 0, 34
        if stor5.length.field_1 % 128:
            if 31 < stor5.length.field_1 % 128:
                mem[128] = uint256(stor5.field_0)
                idx = 128
                s = 0
                while stor5.length.field_1 % 128 + 96 > idx:
                    mem[idx + 32] = uint256(stor5[s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor5.length.field_8)
    mem[ceil32(stor5.length.field_1 % 128) + 192 len ceil32(stor5.length.field_1 % 128)] = mem[128 len ceil32(stor5.length.field_1 % 128)]
    if ceil32(stor5.length.field_1 % 128) > stor5.length.field_1 % 128:
        mem[stor5.length.field_1 % 128 + ceil32(stor5.length.field_1 % 128) + 192] = 0
    return Array(len=stor5.length % 128, data=mem[128 len ceil32(stor5.length.field_1 % 128)], mem[(2 * ceil32(stor5.length.field_1 % 128)) + 192 len 2 * ceil32(stor5.length.field_1 % 128)]), 
}

function symbol() {
    if bool(stor6.length):
        if bool(stor6.length) == uint255(stor6.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor6.length):
            if bool(stor6.length) == uint255(stor6.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor6.length):
                if 31 < uint255(stor6.length) * 0.5:
                    mem[128] = uint256(stor6.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor6.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = uint256(stor6[s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor6.length), data=mem[128 len ceil32(uint255(stor6.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor6.length.field_8)
        else:
            if bool(stor6.length) == stor6.length.field_1 % 128 < 32:
                revert with 0, 34
            if stor6.length.field_1 % 128:
                if 31 < stor6.length.field_1 % 128:
                    mem[128] = uint256(stor6.field_0)
                    idx = 128
                    s = 0
                    while stor6.length.field_1 % 128 + 96 > idx:
                        mem[idx + 32] = uint256(stor6[s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor6.length), data=mem[128 len ceil32(uint255(stor6.length) * 0.5)])
                mem[128] = 256 * Mask(248, 0, stor6.length.field_8)
        mem[ceil32(uint255(stor6.length) * 0.5) + 192 len ceil32(uint255(stor6.length) * 0.5)] = mem[128 len ceil32(uint255(stor6.length) * 0.5)]
        if ceil32(uint255(stor6.length) * 0.5) > uint255(stor6.length) * 0.5:
            mem[(uint255(stor6.length) * 0.5) + ceil32(uint255(stor6.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor6.length), data=mem[128 len ceil32(uint255(stor6.length) * 0.5)], mem[(2 * ceil32(uint255(stor6.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor6.length) * 0.5)]), 
    if bool(stor6.length) == stor6.length.field_1 % 128 < 32:
        revert with 0, 34
    if bool(stor6.length):
        if bool(stor6.length) == uint255(stor6.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor6.length):
            if 31 < uint255(stor6.length) * 0.5:
                mem[128] = uint256(stor6.field_0)
                idx = 128
                s = 0
                while (uint255(stor6.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = uint256(stor6[s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor6.length % 128, data=mem[128 len ceil32(stor6.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor6.length.field_8)
    else:
        if bool(stor6.length) == stor6.length.field_1 % 128 < 32:
            revert with 0, 34
        if stor6.length.field_1 % 128:
            if 31 < stor6.length.field_1 % 128:
                mem[128] = uint256(stor6.field_0)
                idx = 128
                s = 0
                while stor6.length.field_1 % 128 + 96 > idx:
                    mem[idx + 32] = uint256(stor6[s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor6.length % 128, data=mem[128 len ceil32(stor6.length.field_1 % 128)])
            mem[128] = 256 * Mask(248, 0, stor6.length.field_8)
    mem[ceil32(stor6.length.field_1 % 128) + 192 len ceil32(stor6.length.field_1 % 128)] = mem[128 len ceil32(stor6.length.field_1 % 128)]
    if ceil32(stor6.length.field_1 % 128) > stor6.length.field_1 % 128:
        mem[stor6.length.field_1 % 128 + ceil32(stor6.length.field_1 % 128) + 192] = 0
    return Array(len=stor6.length % 128, data=mem[128 len ceil32(stor6.length.field_1 % 128)], mem[(2 * ceil32(stor6.length.field_1 % 128)) + 192 len 2 * ceil32(stor6.length.field_1 % 128)]), 
}

function sales(uint256 arg1) {
    require calldata.size - 4 >= 32
    if bool(stor30[arg1].field_2816):
        if bool(stor30[arg1].field_2816) == uint255(uint256(stor30[arg1].field_2816)) * 0.5 < 32:
            revert with 0, 34
        if bool(stor30[arg1].field_2816):
            if bool(stor30[arg1].field_2816) == uint255(uint256(stor30[arg1].field_2816)) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, uint256(stor30[arg1].field_2816)):
                if 31 >= uint255(uint256(stor30[arg1].field_2816)) * 0.5:
                    mem[128] = 256 * Mask(248, 0, stor30[arg1].field_2824)
                else:
                    mem[128] = uint256(stor30[arg1][11].field_0)
                    idx = 128
                    s = 0
                    while (uint255(uint256(stor30[arg1].field_2816)) * 0.5) + 96 > idx:
                        mem[idx + 32] = uint256(stor30[arg1][s + 11].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        else:
            if bool(stor30[arg1].field_2816) == stor30[arg1].field_2817 % 128 < 32:
                revert with 0, 34
            if stor30[arg1].field_2817 % 128:
                if 31 >= stor30[arg1].field_2817 % 128:
                    mem[128] = 256 * Mask(248, 0, stor30[arg1].field_2824)
                else:
                    mem[128] = uint256(stor30[arg1][11].field_0)
                    idx = 128
                    s = 0
                    while stor30[arg1].field_2817 % 128 + 96 > idx:
                        mem[idx + 32] = uint256(stor30[arg1][s + 11].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
        return uint256(stor30[arg1].field_0), 
               uint256(stor30[arg1].field_256),
               uint256(stor30[arg1].field_512),
               uint256(stor30[arg1].field_768),
               uint256(stor30[arg1].field_1024),
               uint256(stor30[arg1].field_1280),
               uint256(stor30[arg1].field_1536),
               uint256(stor30[arg1].field_1792),
               address(stor30[arg1].field_2048),
               address(stor30[arg1].field_2304),
               address(stor30[arg1].field_2560),
               Array(len=2 * Mask(256, -1, uint256(stor30[arg1].field_2816)), data=mem[128 len ceil32(uint255(uint256(stor30[arg1].field_2816)) * 0.5)]),
               uint256(stor30[arg1].field_3072)
    if bool(stor30[arg1].field_2816) == stor30[arg1].field_2817 % 128 < 32:
        revert with 0, 34
    if bool(stor30[arg1].field_2816):
        if bool(stor30[arg1].field_2816) == uint255(uint256(stor30[arg1].field_2816)) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, uint256(stor30[arg1].field_2816)):
            if 31 >= uint255(uint256(stor30[arg1].field_2816)) * 0.5:
                mem[128] = 256 * Mask(248, 0, stor30[arg1].field_2824)
            else:
                mem[128] = uint256(stor30[arg1][11].field_0)
                idx = 128
                s = 0
                while (uint255(uint256(stor30[arg1].field_2816)) * 0.5) + 96 > idx:
                    mem[idx + 32] = uint256(stor30[arg1][s + 11].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
    else:
        if bool(stor30[arg1].field_2816) == stor30[arg1].field_2817 % 128 < 32:
            revert with 0, 34
        if stor30[arg1].field_2817 % 128:
            if 31 >= stor30[arg1].field_2817 % 128:
                mem[128] = 256 * Mask(248, 0, stor30[arg1].field_2824)
            else:
                mem[128] = uint256(stor30[arg1][11].field_0)
                idx = 128
                s = 0
                while stor30[arg1].field_2817 % 128 + 96 > idx:
                    mem[idx + 32] = uint256(stor30[arg1][s + 11].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
    return uint256(stor30[arg1].field_0), 
           uint256(stor30[arg1].field_256),
           uint256(stor30[arg1].field_512),
           uint256(stor30[arg1].field_768),
           uint256(stor30[arg1].field_1024),
           uint256(stor30[arg1].field_1280),
           uint256(stor30[arg1].field_1536),
           uint256(stor30[arg1].field_1792),
           address(stor30[arg1].field_2048),
           address(stor30[arg1].field_2304),
           address(stor30[arg1].field_2560),
           Array(len=stor30[arg1].field_2816 % 128, data=mem[128 len ceil32(stor30[arg1].field_2817 % 128)]),
           uint256(stor30[arg1].field_3072)
}

function tokenURI(uint256 arg1) {
    require calldata.size - 4 >= 32
    if not ownerOf[arg1]:
        revert with 0, '', 0
    if bool(stor7[arg1].field_0):
        if bool(stor7[arg1].field_0) == uint255(uint256(stor7[arg1].field_0)) * 0.5 < 32:
            revert with 0, 34
        if bool(stor7[arg1].field_0):
            if bool(stor7[arg1].field_0) == uint255(uint256(stor7[arg1].field_0)) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, uint256(stor7[arg1].field_0)):
                if 31 < uint255(uint256(stor7[arg1].field_0)) * 0.5:
                    mem[192] = uint256(stor7[arg1].field_0)
                    idx = 192
                    s = 0
                    while (uint255(uint256(stor7[arg1].field_0)) * 0.5) + 160 > idx:
                        mem[idx + 32] = uint256(stor7[arg1][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, uint256(stor7[arg1].field_0)), data=mem[192 len ceil32(uint255(uint256(stor7[arg1].field_0)) * 0.5)]), 
                mem[192] = 256 * Mask(248, 0, stor7[arg1].field_8)
        else:
            if bool(stor7[arg1].field_0) == stor7[arg1].field_1 % 128 < 32:
                revert with 0, 34
            if stor7[arg1].field_1 % 128:
                if 31 < stor7[arg1].field_1 % 128:
                    mem[192] = uint256(stor7[arg1].field_0)
                    idx = 192
                    s = 0
                    while stor7[arg1].field_1 % 128 + 160 > idx:
                        mem[idx + 32] = uint256(stor7[arg1][s].field_256)
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, uint256(stor7[arg1].field_0)), data=mem[192 len ceil32(uint255(uint256(stor7[arg1].field_0)) * 0.5)]), 
                mem[192] = 256 * Mask(248, 0, stor7[arg1].field_8)
        mem[ceil32(uint255(uint256(stor7[arg1].field_0)) * 0.5) + 256 len ceil32(uint255(uint256(stor7[arg1].field_0)) * 0.5)] = mem[192 len ceil32(uint255(uint256(stor7[arg1].field_0)) * 0.5)]
        if ceil32(uint255(uint256(stor7[arg1].field_0)) * 0.5) > uint255(uint256(stor7[arg1].field_0)) * 0.5:
            mem[(uint255(uint256(stor7[arg1].field_0)) * 0.5) + ceil32(uint255(uint256(stor7[arg1].field_0)) * 0.5) + 256] = 0
        return Array(len=2 * Mask(256, -1, uint256(stor7[arg1].field_0)), data=mem[192 len ceil32(uint255(uint256(stor7[arg1].field_0)) * 0.5)], mem[(2 * ceil32(uint255(uint256(stor7[arg1].field_0)) * 0.5)) + 256 len 2 * ceil32(uint255(uint256(stor7[arg1].field_0)) * 0.5)]), 
    if bool(stor7[arg1].field_0) == stor7[arg1].field_1 % 128 < 32:
        revert with 0, 34
    if bool(stor7[arg1].field_0):
        if bool(stor7[arg1].field_0) == uint255(uint256(stor7[arg1].field_0)) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, uint256(stor7[arg1].field_0)):
            if 31 < uint255(uint256(stor7[arg1].field_0)) * 0.5:
                mem[192] = uint256(stor7[arg1].field_0)
                idx = 192
                s = 0
                while (uint255(uint256(stor7[arg1].field_0)) * 0.5) + 160 > idx:
                    mem[idx + 32] = uint256(stor7[arg1][s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor7[arg1].field_0 % 128, data=mem[192 len ceil32(stor7[arg1].field_1 % 128)])
            mem[192] = 256 * Mask(248, 0, stor7[arg1].field_8)
    else:
        if bool(stor7[arg1].field_0) == stor7[arg1].field_1 % 128 < 32:
            revert with 0, 34
        if stor7[arg1].field_1 % 128:
            if 31 < stor7[arg1].field_1 % 128:
                mem[192] = uint256(stor7[arg1].field_0)
                idx = 192
                s = 0
                while stor7[arg1].field_1 % 128 + 160 > idx:
                    mem[idx + 32] = uint256(stor7[arg1][s].field_256)
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor7[arg1].field_0 % 128, data=mem[192 len ceil32(stor7[arg1].field_1 % 128)])
            mem[192] = 256 * Mask(248, 0, stor7[arg1].field_8)
    mem[ceil32(stor7[arg1].field_1 % 128) + 256 len ceil32(stor7[arg1].field_1 % 128)] = mem[192 len ceil32(stor7[arg1].field_1 % 128)]
    if ceil32(stor7[arg1].field_1 % 128) > stor7[arg1].field_1 % 128:
        mem[stor7[arg1].field_1 % 128 + ceil32(stor7[arg1].field_1 % 128) + 256] = 0
    return Array(len=stor7[arg1].field_0 % 128, data=mem[192 len ceil32(stor7[arg1].field_1 % 128)], mem[(2 * ceil32(stor7[arg1].field_1 % 128)) + 256 len 2 * ceil32(stor7[arg1].field_1 % 128)]), 
}

function sub_c1b925e7(?) {
    require calldata.size - 4 >= 32
    if not stor35[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
        if not uint256(bids[arg1].field_0):
            return 0
    if not uint256(bids[arg1].field_0):
        if not uint256(bids[arg1].field_0):
            if uint256(stor30[arg1].field_1280):
                return uint256(stor30[arg1].field_768), 
                       uint256(bids[arg1].field_0),
                       0,
                       uint256(stor30[arg1].field_768) >= uint256(stor30[arg1].field_1024),
                       block.timestamp >= uint256(stor30[arg1].field_1280),
                       1 == uint256(stor30[arg1].field_1536)
            if uint256(stor30[arg1].field_3072) > !sub_418bc156:
                revert with 0, 17
            return uint256(stor30[arg1].field_768), 
                   uint256(bids[arg1].field_0),
                   0,
                   uint256(stor30[arg1].field_768) >= uint256(stor30[arg1].field_1024),
                   block.timestamp >= uint256(stor30[arg1].field_3072) + sub_418bc156,
                   1 == uint256(stor30[arg1].field_1536)
        if uint256(bids[arg1].field_0) < 1:
            revert with 0, 17
        if uint256(bids[arg1].field_0) - 1 >= uint256(bids[arg1].field_0):
            revert with 0, 50
        if uint256(stor30[arg1].field_1280):
            return uint256(stor30[arg1].field_768), 
                   uint256(bids[arg1].field_0),
                   address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0),
                   uint256(stor30[arg1].field_768) >= uint256(stor30[arg1].field_1024),
                   block.timestamp >= uint256(stor30[arg1].field_1280),
                   1 == uint256(stor30[arg1].field_1536)
        if uint256(stor30[arg1].field_3072) > !sub_418bc156:
            revert with 0, 17
        return uint256(stor30[arg1].field_768), 
               uint256(bids[arg1].field_0),
               address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0),
               uint256(stor30[arg1].field_768) >= uint256(stor30[arg1].field_1024),
               block.timestamp >= uint256(stor30[arg1].field_3072) + sub_418bc156,
               1 == uint256(stor30[arg1].field_1536)
    if uint256(bids[arg1].field_0) < 1:
        revert with 0, 17
    if uint256(bids[arg1].field_0) - 1 >= uint256(bids[arg1].field_0):
        revert with 0, 50
    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) <= 0:
        if not uint256(bids[arg1].field_0):
            if uint256(stor30[arg1].field_1280):
                return uint256(stor30[arg1].field_768), 
                       uint256(bids[arg1].field_0),
                       0,
                       uint256(stor30[arg1].field_768) >= uint256(stor30[arg1].field_1024),
                       block.timestamp >= uint256(stor30[arg1].field_1280),
                       1 == uint256(stor30[arg1].field_1536)
            if uint256(stor30[arg1].field_3072) > !sub_418bc156:
                revert with 0, 17
            return uint256(stor30[arg1].field_768), 
                   uint256(bids[arg1].field_0),
                   0,
                   uint256(stor30[arg1].field_768) >= uint256(stor30[arg1].field_1024),
                   block.timestamp >= uint256(stor30[arg1].field_3072) + sub_418bc156,
                   1 == uint256(stor30[arg1].field_1536)
        if uint256(bids[arg1].field_0) < 1:
            revert with 0, 17
        if uint256(bids[arg1].field_0) - 1 >= uint256(bids[arg1].field_0):
            revert with 0, 50
        if uint256(stor30[arg1].field_1280):
            return uint256(stor30[arg1].field_768), 
                   uint256(bids[arg1].field_0),
                   address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0),
                   uint256(stor30[arg1].field_768) >= uint256(stor30[arg1].field_1024),
                   block.timestamp >= uint256(stor30[arg1].field_1280),
                   1 == uint256(stor30[arg1].field_1536)
        if uint256(stor30[arg1].field_3072) > !sub_418bc156:
            revert with 0, 17
        return uint256(stor30[arg1].field_768), 
               uint256(bids[arg1].field_0),
               address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0),
               uint256(stor30[arg1].field_768) >= uint256(stor30[arg1].field_1024),
               block.timestamp >= uint256(stor30[arg1].field_3072) + sub_418bc156,
               1 == uint256(stor30[arg1].field_1536)
    if not uint256(bids[arg1].field_0):
        if not uint256(bids[arg1].field_0):
            if uint256(stor30[arg1].field_1280):
                return 0, 
                       uint256(bids[arg1].field_0),
                       0,
                       0 >= uint256(stor30[arg1].field_1024),
                       block.timestamp >= uint256(stor30[arg1].field_1280),
                       1 == uint256(stor30[arg1].field_1536)
            if uint256(stor30[arg1].field_3072) > !sub_418bc156:
                revert with 0, 17
            return 0, 
                   uint256(bids[arg1].field_0),
                   0,
                   0 >= uint256(stor30[arg1].field_1024),
                   block.timestamp >= uint256(stor30[arg1].field_3072) + sub_418bc156,
                   1 == uint256(stor30[arg1].field_1536)
        if uint256(bids[arg1].field_0) < 1:
            revert with 0, 17
        if uint256(bids[arg1].field_0) - 1 >= uint256(bids[arg1].field_0):
            revert with 0, 50
        if uint256(stor30[arg1].field_1280):
            return 0, 
                   uint256(bids[arg1].field_0),
                   address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0),
                   0 >= uint256(stor30[arg1].field_1024),
                   block.timestamp >= uint256(stor30[arg1].field_1280),
                   1 == uint256(stor30[arg1].field_1536)
        if uint256(stor30[arg1].field_3072) > !sub_418bc156:
            revert with 0, 17
        return 0, 
               uint256(bids[arg1].field_0),
               address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0),
               0 >= uint256(stor30[arg1].field_1024),
               block.timestamp >= uint256(stor30[arg1].field_3072) + sub_418bc156,
               1 == uint256(stor30[arg1].field_1536)
    if uint256(bids[arg1].field_0) < 1:
        revert with 0, 17
    if uint256(bids[arg1].field_0) - 1 >= uint256(bids[arg1].field_0):
        revert with 0, 50
    if not uint256(bids[arg1].field_0):
        if uint256(stor30[arg1].field_1280):
            return uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256), 
                   uint256(bids[arg1].field_0),
                   0,
                   uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) >= uint256(stor30[arg1].field_1024),
                   block.timestamp >= uint256(stor30[arg1].field_1280),
                   1 == uint256(stor30[arg1].field_1536)
        if uint256(stor30[arg1].field_3072) > !sub_418bc156:
            revert with 0, 17
        return uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256), 
               uint256(bids[arg1].field_0),
               0,
               uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) >= uint256(stor30[arg1].field_1024),
               block.timestamp >= uint256(stor30[arg1].field_3072) + sub_418bc156,
               1 == uint256(stor30[arg1].field_1536)
    if uint256(bids[arg1].field_0) < 1:
        revert with 0, 17
    if uint256(bids[arg1].field_0) - 1 >= uint256(bids[arg1].field_0):
        revert with 0, 50
    if uint256(stor30[arg1].field_1280):
        return uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256), 
               uint256(bids[arg1].field_0),
               address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0),
               uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) >= uint256(stor30[arg1].field_1024),
               block.timestamp >= uint256(stor30[arg1].field_1280),
               1 == uint256(stor30[arg1].field_1536)
    if uint256(stor30[arg1].field_3072) > !sub_418bc156:
        revert with 0, 17
    return uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256), 
           uint256(bids[arg1].field_0),
           address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0),
           uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) >= uint256(stor30[arg1].field_1024),
           block.timestamp >= uint256(stor30[arg1].field_3072) + sub_418bc156,
           1 == uint256(stor30[arg1].field_1536)
}

function sub_f47cf5da(?) payable {
    require calldata.size - 4 >= 32
    if not stor35[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
        revert with 0, 'No active sale'
    if not uint256(stor30[arg1].field_1280):
        if msg.value < uint256(stor30[arg1].field_512):
            revert with 0, 'Insufficient amount sent'
        uint256(stor30[arg1].field_1536) = 1
        stor35[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] = 0
        if sub_07889cc9.length < 1:
            revert with 0, 17
        if sub_07889cc9.length - 1 >= sub_07889cc9.length:
            revert with 0, 50
        if sub_17cd4006[arg1] >= sub_07889cc9.length:
            revert with 0, 50
        sub_07889cc9[stor37[arg1]] = sub_07889cc9[sub_07889cc9.length]
        if sub_07889cc9.length < 1:
            revert with 0, 17
        if sub_07889cc9.length - 1 >= sub_07889cc9.length:
            revert with 0, 50
        sub_17cd4006[stor36[stor36.length]] = sub_17cd4006[arg1]
        if not sub_07889cc9.length:
            revert with 0, 49
        sub_07889cc9[sub_07889cc9.length] = 0
        sub_07889cc9.length--
        if msg.value:
            if not uint256(stor30[arg1].field_512):
                address(stor30[arg1].field_2304) = msg.sender
                uint256(stor30[arg1].field_1792) = msg.value
                uint256(stor30[arg1].field_1536) = block.timestamp
                require ext_code.size(address(stor30[arg1].field_2560))
                call address(stor30[arg1].field_2560).0x42842e0e with:
                     gas gas_remaining wei
                    args this.address, msg.sender, uint256(stor30[arg1].field_256)
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if msg.value and stor17 > -1 / msg.value:
                    revert with 0, 17
                if not stor19:
                    revert with 0, 18
                if not uint8(stor14.field_160):
                    if msg.value * stor17 / stor19:
                        if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                            if msg.value * stor17 / stor19 and stor11 > -1 / msg.value * stor17 / stor19:
                                revert with 0, 17
                            call address(stor10.field_8) with:
                               value msg.value * stor17 / stor19 * stor11 / 100 wei
                                 gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if msg.value * stor17 / stor19 < msg.value * stor17 / stor19 * stor11 / 100:
                                revert with 0, 17
                            call stor21 with:
                               value (msg.value * stor17 / stor19) - (msg.value * stor17 / stor19 * stor11 / 100) wei
                                 gas 2300 * is_zero(value) wei
                        else:
                            if not uint8(stor14.field_160):
                                if msg.value * stor17 / stor19 and stor11 > -1 / msg.value * stor17 / stor19:
                                    revert with 0, 17
                                call address(stor10.field_8) with:
                                   value msg.value * stor17 / stor19 * stor11 / 100 wei
                                     gas 2300 * is_zero(value) wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if msg.value * stor17 / stor19 < msg.value * stor17 / stor19 * stor11 / 100:
                                    revert with 0, 17
                                call stor21 with:
                                   value (msg.value * stor17 / stor19) - (msg.value * stor17 / stor19 * stor11 / 100) wei
                                     gas 2300 * is_zero(value) wei
                            else:
                                if stor16[address(msg.sender)] > -2:
                                    revert with 0, 17
                                stor16[address(msg.sender)]++
                                if stor16[address(stor30[arg1].field_2048)]:
                                    if stor16[address(stor30[arg1].field_2048)] < 1:
                                        revert with 0, 17
                                    stor16[address(stor30[arg1].field_2048)]--
                                    require ext_code.size(address(stor14.field_0))
                                    call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(stor14.field_0))
                                call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args msg.sender, stor16[address(msg.sender)]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(stor14.field_0))
                                call address(stor14.field_0).0xd0e30db0 with:
                                   value msg.value * stor17 / stor19 wei
                                     gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    if msg.value * stor17 / stor19 > -1:
                        revert with 0, 17
                    if msg.value < msg.value * stor17 / stor19:
                        revert with 0, 17
                    call address(stor30[arg1].field_2048) with:
                       value msg.value - (msg.value * stor17 / stor19) wei
                         gas 2300 * is_zero(value) wei
                else:
                    if msg.value and stor12 > -1 / msg.value:
                        revert with 0, 17
                    if not stor19:
                        revert with 0, 18
                    if msg.value * stor12 / stor19:
                        require ext_code.size(stor13)
                        call stor13.0xd0e30db0 with:
                           value msg.value * stor12 / stor19 wei
                             gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    if msg.value * stor17 / stor19:
                        if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                            if msg.value * stor17 / stor19 and stor11 > -1 / msg.value * stor17 / stor19:
                                revert with 0, 17
                            call address(stor10.field_8) with:
                               value msg.value * stor17 / stor19 * stor11 / 100 wei
                                 gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if msg.value * stor17 / stor19 < msg.value * stor17 / stor19 * stor11 / 100:
                                revert with 0, 17
                            call stor21 with:
                               value (msg.value * stor17 / stor19) - (msg.value * stor17 / stor19 * stor11 / 100) wei
                                 gas 2300 * is_zero(value) wei
                        else:
                            if not uint8(stor14.field_160):
                                if msg.value * stor17 / stor19 and stor11 > -1 / msg.value * stor17 / stor19:
                                    revert with 0, 17
                                call address(stor10.field_8) with:
                                   value msg.value * stor17 / stor19 * stor11 / 100 wei
                                     gas 2300 * is_zero(value) wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if msg.value * stor17 / stor19 < msg.value * stor17 / stor19 * stor11 / 100:
                                    revert with 0, 17
                                call stor21 with:
                                   value (msg.value * stor17 / stor19) - (msg.value * stor17 / stor19 * stor11 / 100) wei
                                     gas 2300 * is_zero(value) wei
                            else:
                                if stor16[address(msg.sender)] > -2:
                                    revert with 0, 17
                                stor16[address(msg.sender)]++
                                if stor16[address(stor30[arg1].field_2048)]:
                                    if stor16[address(stor30[arg1].field_2048)] < 1:
                                        revert with 0, 17
                                    stor16[address(stor30[arg1].field_2048)]--
                                    require ext_code.size(address(stor14.field_0))
                                    call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(stor14.field_0))
                                call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                     gas gas_remaining wei
                                    args msg.sender, stor16[address(msg.sender)]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(address(stor14.field_0))
                                call address(stor14.field_0).0xd0e30db0 with:
                                   value msg.value * stor17 / stor19 wei
                                     gas gas_remaining wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    if msg.value * stor17 / stor19 > !(msg.value * stor12 / stor19):
                        revert with 0, 17
                    if msg.value < (msg.value * stor17 / stor19) + (msg.value * stor12 / stor19):
                        revert with 0, 17
                    call address(stor30[arg1].field_2048) with:
                       value msg.value - (msg.value * stor17 / stor19) - (msg.value * stor12 / stor19) wei
                         gas 2300 * is_zero(value) wei
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                sub_3f88d08a[address(stor30[arg1].field_2560)]++
                sub_3f88d08a[address(stor30[arg1].field_2560)][sub_3f88d08a[address(stor30[arg1].field_2560)]] = arg1
                if address(stor30[arg1].field_2048) != msg.sender:
                    if block.timestamp < stor48:
                        revert with 0, 17
                    if block.timestamp - stor48 >= 24 * 3600:
                        sub_95ddf83a[address(stor30[arg1].field_2560)] = 0
                        stor48 = block.timestamp
                    if sub_95ddf83a[address(stor30[arg1].field_2560)] > !msg.value:
                        revert with 0, 17
                    sub_95ddf83a[address(stor30[arg1].field_2560)] += msg.value
                    if sub_c38694a5[address(stor30[arg1].field_2560)] > !msg.value:
                        revert with 0, 17
                    sub_c38694a5[address(stor30[arg1].field_2560)] += msg.value
                    if sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > !msg.value:
                        revert with 0, 17
                    sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] += msg.value
                    if msg.value > uint256(stor30[stor52].field_1792):
                        sub_9b175d77 = arg1
                    if not uint256(stor30[stor53].field_1792):
                        sub_362f53ca = arg1
                    else:
                        if msg.value < uint256(stor30[stor53].field_1792):
                            sub_362f53ca = arg1
                emit 0x9b3dc70a: arg1, msg.value
            else:
                if msg.value <= uint256(stor30[arg1].field_512):
                    address(stor30[arg1].field_2304) = msg.sender
                    uint256(stor30[arg1].field_1792) = msg.value
                    uint256(stor30[arg1].field_1536) = block.timestamp
                    require ext_code.size(address(stor30[arg1].field_2560))
                    call address(stor30[arg1].field_2560).0x42842e0e with:
                         gas gas_remaining wei
                        args this.address, msg.sender, uint256(stor30[arg1].field_256)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if msg.value and stor17 > -1 / msg.value:
                        revert with 0, 17
                    if not stor19:
                        revert with 0, 18
                    if not uint8(stor14.field_160):
                        if msg.value * stor17 / stor19:
                            if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                if msg.value * stor17 / stor19 and stor11 > -1 / msg.value * stor17 / stor19:
                                    revert with 0, 17
                                call address(stor10.field_8) with:
                                   value msg.value * stor17 / stor19 * stor11 / 100 wei
                                     gas 2300 * is_zero(value) wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if msg.value * stor17 / stor19 < msg.value * stor17 / stor19 * stor11 / 100:
                                    revert with 0, 17
                                call stor21 with:
                                   value (msg.value * stor17 / stor19) - (msg.value * stor17 / stor19 * stor11 / 100) wei
                                     gas 2300 * is_zero(value) wei
                            else:
                                if not uint8(stor14.field_160):
                                    if msg.value * stor17 / stor19 and stor11 > -1 / msg.value * stor17 / stor19:
                                        revert with 0, 17
                                    call address(stor10.field_8) with:
                                       value msg.value * stor17 / stor19 * stor11 / 100 wei
                                         gas 2300 * is_zero(value) wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if msg.value * stor17 / stor19 < msg.value * stor17 / stor19 * stor11 / 100:
                                        revert with 0, 17
                                    call stor21 with:
                                       value (msg.value * stor17 / stor19) - (msg.value * stor17 / stor19 * stor11 / 100) wei
                                         gas 2300 * is_zero(value) wei
                                else:
                                    if stor16[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    stor16[address(msg.sender)]++
                                    if stor16[address(stor30[arg1].field_2048)]:
                                        if stor16[address(stor30[arg1].field_2048)] < 1:
                                            revert with 0, 17
                                        stor16[address(stor30[arg1].field_2048)]--
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(stor14.field_0))
                                    call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, stor16[address(msg.sender)]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(stor14.field_0))
                                    call address(stor14.field_0).0xd0e30db0 with:
                                       value msg.value * stor17 / stor19 wei
                                         gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        if msg.value * stor17 / stor19 > -1:
                            revert with 0, 17
                        if msg.value < msg.value * stor17 / stor19:
                            revert with 0, 17
                        call address(stor30[arg1].field_2048) with:
                           value msg.value - (msg.value * stor17 / stor19) wei
                             gas 2300 * is_zero(value) wei
                    else:
                        if msg.value and stor12 > -1 / msg.value:
                            revert with 0, 17
                        if not stor19:
                            revert with 0, 18
                        if msg.value * stor12 / stor19:
                            require ext_code.size(stor13)
                            call stor13.0xd0e30db0 with:
                               value msg.value * stor12 / stor19 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        if msg.value * stor17 / stor19:
                            if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                if msg.value * stor17 / stor19 and stor11 > -1 / msg.value * stor17 / stor19:
                                    revert with 0, 17
                                call address(stor10.field_8) with:
                                   value msg.value * stor17 / stor19 * stor11 / 100 wei
                                     gas 2300 * is_zero(value) wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if msg.value * stor17 / stor19 < msg.value * stor17 / stor19 * stor11 / 100:
                                    revert with 0, 17
                                call stor21 with:
                                   value (msg.value * stor17 / stor19) - (msg.value * stor17 / stor19 * stor11 / 100) wei
                                     gas 2300 * is_zero(value) wei
                            else:
                                if not uint8(stor14.field_160):
                                    if msg.value * stor17 / stor19 and stor11 > -1 / msg.value * stor17 / stor19:
                                        revert with 0, 17
                                    call address(stor10.field_8) with:
                                       value msg.value * stor17 / stor19 * stor11 / 100 wei
                                         gas 2300 * is_zero(value) wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if msg.value * stor17 / stor19 < msg.value * stor17 / stor19 * stor11 / 100:
                                        revert with 0, 17
                                    call stor21 with:
                                       value (msg.value * stor17 / stor19) - (msg.value * stor17 / stor19 * stor11 / 100) wei
                                         gas 2300 * is_zero(value) wei
                                else:
                                    if stor16[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    stor16[address(msg.sender)]++
                                    if stor16[address(stor30[arg1].field_2048)]:
                                        if stor16[address(stor30[arg1].field_2048)] < 1:
                                            revert with 0, 17
                                        stor16[address(stor30[arg1].field_2048)]--
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(stor14.field_0))
                                    call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, stor16[address(msg.sender)]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(stor14.field_0))
                                    call address(stor14.field_0).0xd0e30db0 with:
                                       value msg.value * stor17 / stor19 wei
                                         gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        if msg.value * stor17 / stor19 > !(msg.value * stor12 / stor19):
                            revert with 0, 17
                        if msg.value < (msg.value * stor17 / stor19) + (msg.value * stor12 / stor19):
                            revert with 0, 17
                        call address(stor30[arg1].field_2048) with:
                           value msg.value - (msg.value * stor17 / stor19) - (msg.value * stor12 / stor19) wei
                             gas 2300 * is_zero(value) wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    sub_3f88d08a[address(stor30[arg1].field_2560)]++
                    sub_3f88d08a[address(stor30[arg1].field_2560)][sub_3f88d08a[address(stor30[arg1].field_2560)]] = arg1
                    if address(stor30[arg1].field_2048) != msg.sender:
                        if block.timestamp < stor48:
                            revert with 0, 17
                        if block.timestamp - stor48 >= 24 * 3600:
                            sub_95ddf83a[address(stor30[arg1].field_2560)] = 0
                            stor48 = block.timestamp
                        if sub_95ddf83a[address(stor30[arg1].field_2560)] > !msg.value:
                            revert with 0, 17
                        sub_95ddf83a[address(stor30[arg1].field_2560)] += msg.value
                        if sub_c38694a5[address(stor30[arg1].field_2560)] > !msg.value:
                            revert with 0, 17
                        sub_c38694a5[address(stor30[arg1].field_2560)] += msg.value
                        if sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > !msg.value:
                            revert with 0, 17
                        sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] += msg.value
                        if msg.value > uint256(stor30[stor52].field_1792):
                            sub_9b175d77 = arg1
                        if not uint256(stor30[stor53].field_1792):
                            sub_362f53ca = arg1
                        else:
                            if msg.value < uint256(stor30[stor53].field_1792):
                                sub_362f53ca = arg1
                    emit 0x9b3dc70a: arg1, msg.value
                else:
                    if msg.value < uint256(stor30[arg1].field_512):
                        revert with 0, 17
                    call msg.sender with:
                       value msg.value - uint256(stor30[arg1].field_512) wei
                         gas 2300 * is_zero(value) wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    address(stor30[arg1].field_2304) = msg.sender
                    uint256(stor30[arg1].field_1792) = uint256(stor30[arg1].field_512)
                    uint256(stor30[arg1].field_1536) = block.timestamp
                    require ext_code.size(address(stor30[arg1].field_2560))
                    call address(stor30[arg1].field_2560).0x42842e0e with:
                         gas gas_remaining wei
                        args this.address, msg.sender, uint256(stor30[arg1].field_256)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint256(stor30[arg1].field_512) and stor17 > -1 / uint256(stor30[arg1].field_512):
                        revert with 0, 17
                    if not stor19:
                        revert with 0, 18
                    if not uint8(stor14.field_160):
                        if uint256(stor30[arg1].field_512) * stor17 / stor19:
                            if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                if uint256(stor30[arg1].field_512) * stor17 / stor19 and stor11 > -1 / uint256(stor30[arg1].field_512) * stor17 / stor19:
                                    revert with 0, 17
                                call address(stor10.field_8) with:
                                   value uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100 wei
                                     gas 2300 * is_zero(value) wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if uint256(stor30[arg1].field_512) * stor17 / stor19 < uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100:
                                    revert with 0, 17
                                call stor21 with:
                                   value (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100) wei
                                     gas 2300 * is_zero(value) wei
                            else:
                                if not uint8(stor14.field_160):
                                    if uint256(stor30[arg1].field_512) * stor17 / stor19 and stor11 > -1 / uint256(stor30[arg1].field_512) * stor17 / stor19:
                                        revert with 0, 17
                                    call address(stor10.field_8) with:
                                       value uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100 wei
                                         gas 2300 * is_zero(value) wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint256(stor30[arg1].field_512) * stor17 / stor19 < uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100:
                                        revert with 0, 17
                                    call stor21 with:
                                       value (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100) wei
                                         gas 2300 * is_zero(value) wei
                                else:
                                    if stor16[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    stor16[address(msg.sender)]++
                                    if stor16[address(stor30[arg1].field_2048)]:
                                        if stor16[address(stor30[arg1].field_2048)] < 1:
                                            revert with 0, 17
                                        stor16[address(stor30[arg1].field_2048)]--
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(stor14.field_0))
                                    call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, stor16[address(msg.sender)]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(stor14.field_0))
                                    call address(stor14.field_0).0xd0e30db0 with:
                                       value uint256(stor30[arg1].field_512) * stor17 / stor19 wei
                                         gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        if uint256(stor30[arg1].field_512) * stor17 / stor19 > -1:
                            revert with 0, 17
                        if uint256(stor30[arg1].field_512) < uint256(stor30[arg1].field_512) * stor17 / stor19:
                            revert with 0, 17
                        call address(stor30[arg1].field_2048) with:
                           value uint256(stor30[arg1].field_512) - (uint256(stor30[arg1].field_512) * stor17 / stor19) wei
                             gas 2300 * is_zero(value) wei
                    else:
                        if uint256(stor30[arg1].field_512) and stor12 > -1 / uint256(stor30[arg1].field_512):
                            revert with 0, 17
                        if not stor19:
                            revert with 0, 18
                        if uint256(stor30[arg1].field_512) * stor12 / stor19:
                            require ext_code.size(stor13)
                            call stor13.0xd0e30db0 with:
                               value uint256(stor30[arg1].field_512) * stor12 / stor19 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        if uint256(stor30[arg1].field_512) * stor17 / stor19:
                            if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                if uint256(stor30[arg1].field_512) * stor17 / stor19 and stor11 > -1 / uint256(stor30[arg1].field_512) * stor17 / stor19:
                                    revert with 0, 17
                                call address(stor10.field_8) with:
                                   value uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100 wei
                                     gas 2300 * is_zero(value) wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if uint256(stor30[arg1].field_512) * stor17 / stor19 < uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100:
                                    revert with 0, 17
                                call stor21 with:
                                   value (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100) wei
                                     gas 2300 * is_zero(value) wei
                            else:
                                if not uint8(stor14.field_160):
                                    if uint256(stor30[arg1].field_512) * stor17 / stor19 and stor11 > -1 / uint256(stor30[arg1].field_512) * stor17 / stor19:
                                        revert with 0, 17
                                    call address(stor10.field_8) with:
                                       value uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100 wei
                                         gas 2300 * is_zero(value) wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint256(stor30[arg1].field_512) * stor17 / stor19 < uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100:
                                        revert with 0, 17
                                    call stor21 with:
                                       value (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100) wei
                                         gas 2300 * is_zero(value) wei
                                else:
                                    if stor16[address(msg.sender)] > -2:
                                        revert with 0, 17
                                    stor16[address(msg.sender)]++
                                    if stor16[address(stor30[arg1].field_2048)]:
                                        if stor16[address(stor30[arg1].field_2048)] < 1:
                                            revert with 0, 17
                                        stor16[address(stor30[arg1].field_2048)]--
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(stor14.field_0))
                                    call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args msg.sender, stor16[address(msg.sender)]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(stor14.field_0))
                                    call address(stor14.field_0).0xd0e30db0 with:
                                       value uint256(stor30[arg1].field_512) * stor17 / stor19 wei
                                         gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        if uint256(stor30[arg1].field_512) * stor17 / stor19 > !(uint256(stor30[arg1].field_512) * stor12 / stor19):
                            revert with 0, 17
                        if uint256(stor30[arg1].field_512) < (uint256(stor30[arg1].field_512) * stor17 / stor19) + (uint256(stor30[arg1].field_512) * stor12 / stor19):
                            revert with 0, 17
                        call address(stor30[arg1].field_2048) with:
                           value uint256(stor30[arg1].field_512) - (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor12 / stor19) wei
                             gas 2300 * is_zero(value) wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    sub_3f88d08a[address(stor30[arg1].field_2560)]++
                    sub_3f88d08a[address(stor30[arg1].field_2560)][sub_3f88d08a[address(stor30[arg1].field_2560)]] = arg1
                    if address(stor30[arg1].field_2048) != msg.sender:
                        if block.timestamp < stor48:
                            revert with 0, 17
                        if block.timestamp - stor48 >= 24 * 3600:
                            sub_95ddf83a[address(stor30[arg1].field_2560)] = 0
                            stor48 = block.timestamp
                        if sub_95ddf83a[address(stor30[arg1].field_2560)] > !uint256(stor30[arg1].field_512):
                            revert with 0, 17
                        sub_95ddf83a[address(stor30[arg1].field_2560)] += uint256(stor30[arg1].field_512)
                        if sub_c38694a5[address(stor30[arg1].field_2560)] > !uint256(stor30[arg1].field_512):
                            revert with 0, 17
                        sub_c38694a5[address(stor30[arg1].field_2560)] += uint256(stor30[arg1].field_512)
                        if sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > !uint256(stor30[arg1].field_512):
                            revert with 0, 17
                        sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] += uint256(stor30[arg1].field_512)
                        if uint256(stor30[arg1].field_512) > uint256(stor30[stor52].field_1792):
                            sub_9b175d77 = arg1
                        if not uint256(stor30[stor53].field_1792):
                            sub_362f53ca = arg1
                        else:
                            if uint256(stor30[arg1].field_512) < uint256(stor30[stor53].field_1792):
                                sub_362f53ca = arg1
                    emit 0x9b3dc70a: arg1, uint256(stor30[arg1].field_512)
    else:
        if msg.value < uint256(stor30[arg1].field_512):
            if not uint256(bids[arg1].field_0):
                if address(stor30[arg1].field_2304):
                    if 0 and sub_ebe9505f > -1 / 0:
                        revert with 0, 17
                    if msg.value < 0 / 100:
                        revert with 0, 'Insufficient amount sent'
                else:
                    if not uint256(stor30[arg1].field_768):
                        if uint256(stor30[arg1].field_768) > !sub_0f58fa4d:
                            revert with 0, 17
                        if msg.value < uint256(stor30[arg1].field_768) + sub_0f58fa4d:
                            revert with 0, 'Insufficient amount sent'
                    else:
                        if uint256(stor30[arg1].field_768) > -1:
                            revert with 0, 17
                        if msg.value < uint256(stor30[arg1].field_768):
                            revert with 0, 'Insufficient amount sent'
                if sub_ee218db4 < 0:
                    revert with 0, 17
                uint256(bids[arg1].field_0)++
                address(bids[arg1][uint256(bids[arg1].field_0)].field_0) = msg.sender
                uint256(bids[arg1][uint256(bids[arg1].field_0)].field_256) = msg.value
                if address(stor30[arg1].field_2048) != msg.sender:
                    if address(stor30[arg1].field_2048) != tx.origin:
                        if sub_63873525[address(stor30[arg1].field_2560)] > -2:
                            revert with 0, 17
                        sub_63873525[address(stor30[arg1].field_2560)]++
                        if sub_ec5fe15c[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > -2:
                            revert with 0, 17
                        sub_ec5fe15c[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]++
                        if sub_63873525[address(stor30[arg1].field_2560)] > sub_63873525[address(stor30[stor45].field_2560)]:
                            sub_002e9fb2 = arg1
                        if sub_ec5fe15c[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > sub_ec5fe15c[address(stor30[stor51].field_2560)][uint256(stor30[stor51].field_256)]:
                            sub_9019abdf = arg1
                if sub_ee218db4 > !msg.value:
                    revert with 0, 17
                sub_ee218db4 += msg.value
                uint256(stor30[arg1].field_2304) = msg.sender or Mask(96, 160, uint256(stor30[arg1].field_2304))
            else:
                if uint256(bids[arg1].field_0) < 1:
                    revert with 0, 17
                if uint256(bids[arg1].field_0) - 1 >= uint256(bids[arg1].field_0):
                    revert with 0, 50
                if address(stor30[arg1].field_2304):
                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) and sub_ebe9505f > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                        revert with 0, 17
                    if msg.value < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * sub_ebe9505f / 100:
                        revert with 0, 'Insufficient amount sent'
                else:
                    if not uint256(stor30[arg1].field_768):
                        if uint256(stor30[arg1].field_768) > !sub_0f58fa4d:
                            revert with 0, 17
                        if msg.value < uint256(stor30[arg1].field_768) + sub_0f58fa4d:
                            revert with 0, 'Insufficient amount sent'
                    else:
                        if uint256(stor30[arg1].field_768) > -1:
                            revert with 0, 17
                        if msg.value < uint256(stor30[arg1].field_768):
                            revert with 0, 'Insufficient amount sent'
                if sub_ee218db4 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                    revert with 0, 17
                sub_ee218db4 -= uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                uint256(bids[arg1].field_0)++
                address(bids[arg1][uint256(bids[arg1].field_0)].field_0) = msg.sender
                uint256(bids[arg1][uint256(bids[arg1].field_0)].field_256) = msg.value
                if address(stor30[arg1].field_2048) != msg.sender:
                    if address(stor30[arg1].field_2048) != tx.origin:
                        if sub_63873525[address(stor30[arg1].field_2560)] > -2:
                            revert with 0, 17
                        sub_63873525[address(stor30[arg1].field_2560)]++
                        if sub_ec5fe15c[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > -2:
                            revert with 0, 17
                        sub_ec5fe15c[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]++
                        if sub_63873525[address(stor30[arg1].field_2560)] > sub_63873525[address(stor30[stor45].field_2560)]:
                            sub_002e9fb2 = arg1
                        if sub_ec5fe15c[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > sub_ec5fe15c[address(stor30[stor51].field_2560)][uint256(stor30[stor51].field_256)]:
                            sub_9019abdf = arg1
                if sub_ee218db4 > !msg.value:
                    revert with 0, 17
                sub_ee218db4 += msg.value
                uint256(stor30[arg1].field_2304) = msg.sender or Mask(96, 160, uint256(stor30[arg1].field_2304))
                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) and stor18 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                        revert with 0, 17
                    if not stor19:
                        revert with 0, 18
                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor18 / stor19:
                        revert with 0, 17
                    call address(stor30[arg1].field_2304) with:
                       value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor18 / stor19) wei
                         gas 2300 * is_zero(value) wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
            emit 0xa87e14b1: arg1, msg.value
        else:
            if not uint256(stor30[arg1].field_512):
                if not uint256(bids[arg1].field_0):
                    if address(stor30[arg1].field_2304):
                        if 0 and sub_ebe9505f > -1 / 0:
                            revert with 0, 17
                        if msg.value < 0 / 100:
                            revert with 0, 'Insufficient amount sent'
                    else:
                        if not uint256(stor30[arg1].field_768):
                            if uint256(stor30[arg1].field_768) > !sub_0f58fa4d:
                                revert with 0, 17
                            if msg.value < uint256(stor30[arg1].field_768) + sub_0f58fa4d:
                                revert with 0, 'Insufficient amount sent'
                        else:
                            if uint256(stor30[arg1].field_768) > -1:
                                revert with 0, 17
                            if msg.value < uint256(stor30[arg1].field_768):
                                revert with 0, 'Insufficient amount sent'
                    if sub_ee218db4 < 0:
                        revert with 0, 17
                    uint256(bids[arg1].field_0)++
                    address(bids[arg1][uint256(bids[arg1].field_0)].field_0) = msg.sender
                    uint256(bids[arg1][uint256(bids[arg1].field_0)].field_256) = msg.value
                    if address(stor30[arg1].field_2048) != msg.sender:
                        if address(stor30[arg1].field_2048) != tx.origin:
                            if sub_63873525[address(stor30[arg1].field_2560)] > -2:
                                revert with 0, 17
                            sub_63873525[address(stor30[arg1].field_2560)]++
                            if sub_ec5fe15c[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > -2:
                                revert with 0, 17
                            sub_ec5fe15c[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]++
                            if sub_63873525[address(stor30[arg1].field_2560)] > sub_63873525[address(stor30[stor45].field_2560)]:
                                sub_002e9fb2 = arg1
                            if sub_ec5fe15c[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > sub_ec5fe15c[address(stor30[stor51].field_2560)][uint256(stor30[stor51].field_256)]:
                                sub_9019abdf = arg1
                    if sub_ee218db4 > !msg.value:
                        revert with 0, 17
                    sub_ee218db4 += msg.value
                    uint256(stor30[arg1].field_2304) = msg.sender or Mask(96, 160, uint256(stor30[arg1].field_2304))
                else:
                    if uint256(bids[arg1].field_0) < 1:
                        revert with 0, 17
                    if uint256(bids[arg1].field_0) - 1 >= uint256(bids[arg1].field_0):
                        revert with 0, 50
                    if address(stor30[arg1].field_2304):
                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) and sub_ebe9505f > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                            revert with 0, 17
                        if msg.value < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * sub_ebe9505f / 100:
                            revert with 0, 'Insufficient amount sent'
                    else:
                        if not uint256(stor30[arg1].field_768):
                            if uint256(stor30[arg1].field_768) > !sub_0f58fa4d:
                                revert with 0, 17
                            if msg.value < uint256(stor30[arg1].field_768) + sub_0f58fa4d:
                                revert with 0, 'Insufficient amount sent'
                        else:
                            if uint256(stor30[arg1].field_768) > -1:
                                revert with 0, 17
                            if msg.value < uint256(stor30[arg1].field_768):
                                revert with 0, 'Insufficient amount sent'
                    if sub_ee218db4 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                        revert with 0, 17
                    sub_ee218db4 -= uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                    uint256(bids[arg1].field_0)++
                    address(bids[arg1][uint256(bids[arg1].field_0)].field_0) = msg.sender
                    uint256(bids[arg1][uint256(bids[arg1].field_0)].field_256) = msg.value
                    if address(stor30[arg1].field_2048) != msg.sender:
                        if address(stor30[arg1].field_2048) != tx.origin:
                            if sub_63873525[address(stor30[arg1].field_2560)] > -2:
                                revert with 0, 17
                            sub_63873525[address(stor30[arg1].field_2560)]++
                            if sub_ec5fe15c[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > -2:
                                revert with 0, 17
                            sub_ec5fe15c[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]++
                            if sub_63873525[address(stor30[arg1].field_2560)] > sub_63873525[address(stor30[stor45].field_2560)]:
                                sub_002e9fb2 = arg1
                            if sub_ec5fe15c[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > sub_ec5fe15c[address(stor30[stor51].field_2560)][uint256(stor30[stor51].field_256)]:
                                sub_9019abdf = arg1
                    if sub_ee218db4 > !msg.value:
                        revert with 0, 17
                    sub_ee218db4 += msg.value
                    uint256(stor30[arg1].field_2304) = msg.sender or Mask(96, 160, uint256(stor30[arg1].field_2304))
                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) and stor18 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                            revert with 0, 17
                        if not stor19:
                            revert with 0, 18
                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor18 / stor19:
                            revert with 0, 17
                        call address(stor30[arg1].field_2304) with:
                           value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor18 / stor19) wei
                             gas 2300 * is_zero(value) wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                emit 0xa87e14b1: arg1, msg.value
            else:
                if msg.value < uint256(stor30[arg1].field_512):
                    revert with 0, 'Insufficient amount sent'
                uint256(stor30[arg1].field_1536) = 1
                stor35[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] = 0
                if sub_07889cc9.length < 1:
                    revert with 0, 17
                if sub_07889cc9.length - 1 >= sub_07889cc9.length:
                    revert with 0, 50
                if sub_17cd4006[arg1] >= sub_07889cc9.length:
                    revert with 0, 50
                sub_07889cc9[stor37[arg1]] = sub_07889cc9[sub_07889cc9.length]
                if sub_07889cc9.length < 1:
                    revert with 0, 17
                if sub_07889cc9.length - 1 >= sub_07889cc9.length:
                    revert with 0, 50
                sub_17cd4006[stor36[stor36.length]] = sub_17cd4006[arg1]
                if not sub_07889cc9.length:
                    revert with 0, 49
                sub_07889cc9[sub_07889cc9.length] = 0
                sub_07889cc9.length--
                if msg.value:
                    if not uint256(stor30[arg1].field_512):
                        address(stor30[arg1].field_2304) = msg.sender
                        uint256(stor30[arg1].field_1792) = msg.value
                        uint256(stor30[arg1].field_1536) = block.timestamp
                        require ext_code.size(address(stor30[arg1].field_2560))
                        call address(stor30[arg1].field_2560).0x42842e0e with:
                             gas gas_remaining wei
                            args this.address, msg.sender, uint256(stor30[arg1].field_256)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if msg.value and stor17 > -1 / msg.value:
                            revert with 0, 17
                        if not stor19:
                            revert with 0, 18
                        if not uint8(stor14.field_160):
                            if msg.value * stor17 / stor19:
                                if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                    if msg.value * stor17 / stor19 and stor11 > -1 / msg.value * stor17 / stor19:
                                        revert with 0, 17
                                    call address(stor10.field_8) with:
                                       value msg.value * stor17 / stor19 * stor11 / 100 wei
                                         gas 2300 * is_zero(value) wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if msg.value * stor17 / stor19 < msg.value * stor17 / stor19 * stor11 / 100:
                                        revert with 0, 17
                                    call stor21 with:
                                       value (msg.value * stor17 / stor19) - (msg.value * stor17 / stor19 * stor11 / 100) wei
                                         gas 2300 * is_zero(value) wei
                                else:
                                    if not uint8(stor14.field_160):
                                        if msg.value * stor17 / stor19 and stor11 > -1 / msg.value * stor17 / stor19:
                                            revert with 0, 17
                                        call address(stor10.field_8) with:
                                           value msg.value * stor17 / stor19 * stor11 / 100 wei
                                             gas 2300 * is_zero(value) wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if msg.value * stor17 / stor19 < msg.value * stor17 / stor19 * stor11 / 100:
                                            revert with 0, 17
                                        call stor21 with:
                                           value (msg.value * stor17 / stor19) - (msg.value * stor17 / stor19 * stor11 / 100) wei
                                             gas 2300 * is_zero(value) wei
                                    else:
                                        if stor16[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        stor16[address(msg.sender)]++
                                        if stor16[address(stor30[arg1].field_2048)]:
                                            if stor16[address(stor30[arg1].field_2048)] < 1:
                                                revert with 0, 17
                                            stor16[address(stor30[arg1].field_2048)]--
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args msg.sender, stor16[address(msg.sender)]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).0xd0e30db0 with:
                                           value msg.value * stor17 / stor19 wei
                                             gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            if msg.value * stor17 / stor19 > -1:
                                revert with 0, 17
                            if msg.value < msg.value * stor17 / stor19:
                                revert with 0, 17
                            call address(stor30[arg1].field_2048) with:
                               value msg.value - (msg.value * stor17 / stor19) wei
                                 gas 2300 * is_zero(value) wei
                        else:
                            if msg.value and stor12 > -1 / msg.value:
                                revert with 0, 17
                            if not stor19:
                                revert with 0, 18
                            if msg.value * stor12 / stor19:
                                require ext_code.size(stor13)
                                call stor13.0xd0e30db0 with:
                                   value msg.value * stor12 / stor19 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            if msg.value * stor17 / stor19:
                                if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                    if msg.value * stor17 / stor19 and stor11 > -1 / msg.value * stor17 / stor19:
                                        revert with 0, 17
                                    call address(stor10.field_8) with:
                                       value msg.value * stor17 / stor19 * stor11 / 100 wei
                                         gas 2300 * is_zero(value) wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if msg.value * stor17 / stor19 < msg.value * stor17 / stor19 * stor11 / 100:
                                        revert with 0, 17
                                    call stor21 with:
                                       value (msg.value * stor17 / stor19) - (msg.value * stor17 / stor19 * stor11 / 100) wei
                                         gas 2300 * is_zero(value) wei
                                else:
                                    if not uint8(stor14.field_160):
                                        if msg.value * stor17 / stor19 and stor11 > -1 / msg.value * stor17 / stor19:
                                            revert with 0, 17
                                        call address(stor10.field_8) with:
                                           value msg.value * stor17 / stor19 * stor11 / 100 wei
                                             gas 2300 * is_zero(value) wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if msg.value * stor17 / stor19 < msg.value * stor17 / stor19 * stor11 / 100:
                                            revert with 0, 17
                                        call stor21 with:
                                           value (msg.value * stor17 / stor19) - (msg.value * stor17 / stor19 * stor11 / 100) wei
                                             gas 2300 * is_zero(value) wei
                                    else:
                                        if stor16[address(msg.sender)] > -2:
                                            revert with 0, 17
                                        stor16[address(msg.sender)]++
                                        if stor16[address(stor30[arg1].field_2048)]:
                                            if stor16[address(stor30[arg1].field_2048)] < 1:
                                                revert with 0, 17
                                            stor16[address(stor30[arg1].field_2048)]--
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args msg.sender, stor16[address(msg.sender)]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).0xd0e30db0 with:
                                           value msg.value * stor17 / stor19 wei
                                             gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            if msg.value * stor17 / stor19 > !(msg.value * stor12 / stor19):
                                revert with 0, 17
                            if msg.value < (msg.value * stor17 / stor19) + (msg.value * stor12 / stor19):
                                revert with 0, 17
                            call address(stor30[arg1].field_2048) with:
                               value msg.value - (msg.value * stor17 / stor19) - (msg.value * stor12 / stor19) wei
                                 gas 2300 * is_zero(value) wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        sub_3f88d08a[address(stor30[arg1].field_2560)]++
                        sub_3f88d08a[address(stor30[arg1].field_2560)][sub_3f88d08a[address(stor30[arg1].field_2560)]] = arg1
                        if address(stor30[arg1].field_2048) != msg.sender:
                            if block.timestamp < stor48:
                                revert with 0, 17
                            if block.timestamp - stor48 >= 24 * 3600:
                                sub_95ddf83a[address(stor30[arg1].field_2560)] = 0
                                stor48 = block.timestamp
                            if sub_95ddf83a[address(stor30[arg1].field_2560)] > !msg.value:
                                revert with 0, 17
                            sub_95ddf83a[address(stor30[arg1].field_2560)] += msg.value
                            if sub_c38694a5[address(stor30[arg1].field_2560)] > !msg.value:
                                revert with 0, 17
                            sub_c38694a5[address(stor30[arg1].field_2560)] += msg.value
                            if sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > !msg.value:
                                revert with 0, 17
                            sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] += msg.value
                            if msg.value > uint256(stor30[stor52].field_1792):
                                sub_9b175d77 = arg1
                            if not uint256(stor30[stor53].field_1792):
                                sub_362f53ca = arg1
                            else:
                                if msg.value < uint256(stor30[stor53].field_1792):
                                    sub_362f53ca = arg1
                        emit 0x9b3dc70a: arg1, msg.value
                    else:
                        if msg.value <= uint256(stor30[arg1].field_512):
                            address(stor30[arg1].field_2304) = msg.sender
                            uint256(stor30[arg1].field_1792) = msg.value
                            uint256(stor30[arg1].field_1536) = block.timestamp
                            require ext_code.size(address(stor30[arg1].field_2560))
                            call address(stor30[arg1].field_2560).0x42842e0e with:
                                 gas gas_remaining wei
                                args this.address, msg.sender, uint256(stor30[arg1].field_256)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if msg.value and stor17 > -1 / msg.value:
                                revert with 0, 17
                            if not stor19:
                                revert with 0, 18
                            if not uint8(stor14.field_160):
                                if msg.value * stor17 / stor19:
                                    if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                        if msg.value * stor17 / stor19 and stor11 > -1 / msg.value * stor17 / stor19:
                                            revert with 0, 17
                                        call address(stor10.field_8) with:
                                           value msg.value * stor17 / stor19 * stor11 / 100 wei
                                             gas 2300 * is_zero(value) wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if msg.value * stor17 / stor19 < msg.value * stor17 / stor19 * stor11 / 100:
                                            revert with 0, 17
                                        call stor21 with:
                                           value (msg.value * stor17 / stor19) - (msg.value * stor17 / stor19 * stor11 / 100) wei
                                             gas 2300 * is_zero(value) wei
                                    else:
                                        if not uint8(stor14.field_160):
                                            if msg.value * stor17 / stor19 and stor11 > -1 / msg.value * stor17 / stor19:
                                                revert with 0, 17
                                            call address(stor10.field_8) with:
                                               value msg.value * stor17 / stor19 * stor11 / 100 wei
                                                 gas 2300 * is_zero(value) wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if msg.value * stor17 / stor19 < msg.value * stor17 / stor19 * stor11 / 100:
                                                revert with 0, 17
                                            call stor21 with:
                                               value (msg.value * stor17 / stor19) - (msg.value * stor17 / stor19 * stor11 / 100) wei
                                                 gas 2300 * is_zero(value) wei
                                        else:
                                            if stor16[address(msg.sender)] > -2:
                                                revert with 0, 17
                                            stor16[address(msg.sender)]++
                                            if stor16[address(stor30[arg1].field_2048)]:
                                                if stor16[address(stor30[arg1].field_2048)] < 1:
                                                    revert with 0, 17
                                                stor16[address(stor30[arg1].field_2048)]--
                                                require ext_code.size(address(stor14.field_0))
                                                call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args msg.sender, stor16[address(msg.sender)]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).0xd0e30db0 with:
                                               value msg.value * stor17 / stor19 wei
                                                 gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                if msg.value * stor17 / stor19 > -1:
                                    revert with 0, 17
                                if msg.value < msg.value * stor17 / stor19:
                                    revert with 0, 17
                                call address(stor30[arg1].field_2048) with:
                                   value msg.value - (msg.value * stor17 / stor19) wei
                                     gas 2300 * is_zero(value) wei
                            else:
                                if msg.value and stor12 > -1 / msg.value:
                                    revert with 0, 17
                                if not stor19:
                                    revert with 0, 18
                                if msg.value * stor12 / stor19:
                                    require ext_code.size(stor13)
                                    call stor13.0xd0e30db0 with:
                                       value msg.value * stor12 / stor19 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                if msg.value * stor17 / stor19:
                                    if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                        if msg.value * stor17 / stor19 and stor11 > -1 / msg.value * stor17 / stor19:
                                            revert with 0, 17
                                        call address(stor10.field_8) with:
                                           value msg.value * stor17 / stor19 * stor11 / 100 wei
                                             gas 2300 * is_zero(value) wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if msg.value * stor17 / stor19 < msg.value * stor17 / stor19 * stor11 / 100:
                                            revert with 0, 17
                                        call stor21 with:
                                           value (msg.value * stor17 / stor19) - (msg.value * stor17 / stor19 * stor11 / 100) wei
                                             gas 2300 * is_zero(value) wei
                                    else:
                                        if not uint8(stor14.field_160):
                                            if msg.value * stor17 / stor19 and stor11 > -1 / msg.value * stor17 / stor19:
                                                revert with 0, 17
                                            call address(stor10.field_8) with:
                                               value msg.value * stor17 / stor19 * stor11 / 100 wei
                                                 gas 2300 * is_zero(value) wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if msg.value * stor17 / stor19 < msg.value * stor17 / stor19 * stor11 / 100:
                                                revert with 0, 17
                                            call stor21 with:
                                               value (msg.value * stor17 / stor19) - (msg.value * stor17 / stor19 * stor11 / 100) wei
                                                 gas 2300 * is_zero(value) wei
                                        else:
                                            if stor16[address(msg.sender)] > -2:
                                                revert with 0, 17
                                            stor16[address(msg.sender)]++
                                            if stor16[address(stor30[arg1].field_2048)]:
                                                if stor16[address(stor30[arg1].field_2048)] < 1:
                                                    revert with 0, 17
                                                stor16[address(stor30[arg1].field_2048)]--
                                                require ext_code.size(address(stor14.field_0))
                                                call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args msg.sender, stor16[address(msg.sender)]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).0xd0e30db0 with:
                                               value msg.value * stor17 / stor19 wei
                                                 gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                if msg.value * stor17 / stor19 > !(msg.value * stor12 / stor19):
                                    revert with 0, 17
                                if msg.value < (msg.value * stor17 / stor19) + (msg.value * stor12 / stor19):
                                    revert with 0, 17
                                call address(stor30[arg1].field_2048) with:
                                   value msg.value - (msg.value * stor17 / stor19) - (msg.value * stor12 / stor19) wei
                                     gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            sub_3f88d08a[address(stor30[arg1].field_2560)]++
                            sub_3f88d08a[address(stor30[arg1].field_2560)][sub_3f88d08a[address(stor30[arg1].field_2560)]] = arg1
                            if address(stor30[arg1].field_2048) != msg.sender:
                                if block.timestamp < stor48:
                                    revert with 0, 17
                                if block.timestamp - stor48 >= 24 * 3600:
                                    sub_95ddf83a[address(stor30[arg1].field_2560)] = 0
                                    stor48 = block.timestamp
                                if sub_95ddf83a[address(stor30[arg1].field_2560)] > !msg.value:
                                    revert with 0, 17
                                sub_95ddf83a[address(stor30[arg1].field_2560)] += msg.value
                                if sub_c38694a5[address(stor30[arg1].field_2560)] > !msg.value:
                                    revert with 0, 17
                                sub_c38694a5[address(stor30[arg1].field_2560)] += msg.value
                                if sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > !msg.value:
                                    revert with 0, 17
                                sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] += msg.value
                                if msg.value > uint256(stor30[stor52].field_1792):
                                    sub_9b175d77 = arg1
                                if not uint256(stor30[stor53].field_1792):
                                    sub_362f53ca = arg1
                                else:
                                    if msg.value < uint256(stor30[stor53].field_1792):
                                        sub_362f53ca = arg1
                            emit 0x9b3dc70a: arg1, msg.value
                        else:
                            if msg.value < uint256(stor30[arg1].field_512):
                                revert with 0, 17
                            call msg.sender with:
                               value msg.value - uint256(stor30[arg1].field_512) wei
                                 gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            address(stor30[arg1].field_2304) = msg.sender
                            uint256(stor30[arg1].field_1792) = uint256(stor30[arg1].field_512)
                            uint256(stor30[arg1].field_1536) = block.timestamp
                            require ext_code.size(address(stor30[arg1].field_2560))
                            call address(stor30[arg1].field_2560).0x42842e0e with:
                                 gas gas_remaining wei
                                args this.address, msg.sender, uint256(stor30[arg1].field_256)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if uint256(stor30[arg1].field_512) and stor17 > -1 / uint256(stor30[arg1].field_512):
                                revert with 0, 17
                            if not stor19:
                                revert with 0, 18
                            if not uint8(stor14.field_160):
                                if uint256(stor30[arg1].field_512) * stor17 / stor19:
                                    if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                        if uint256(stor30[arg1].field_512) * stor17 / stor19 and stor11 > -1 / uint256(stor30[arg1].field_512) * stor17 / stor19:
                                            revert with 0, 17
                                        call address(stor10.field_8) with:
                                           value uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100 wei
                                             gas 2300 * is_zero(value) wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint256(stor30[arg1].field_512) * stor17 / stor19 < uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100:
                                            revert with 0, 17
                                        call stor21 with:
                                           value (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100) wei
                                             gas 2300 * is_zero(value) wei
                                    else:
                                        if not uint8(stor14.field_160):
                                            if uint256(stor30[arg1].field_512) * stor17 / stor19 and stor11 > -1 / uint256(stor30[arg1].field_512) * stor17 / stor19:
                                                revert with 0, 17
                                            call address(stor10.field_8) with:
                                               value uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100 wei
                                                 gas 2300 * is_zero(value) wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if uint256(stor30[arg1].field_512) * stor17 / stor19 < uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100:
                                                revert with 0, 17
                                            call stor21 with:
                                               value (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100) wei
                                                 gas 2300 * is_zero(value) wei
                                        else:
                                            if stor16[address(msg.sender)] > -2:
                                                revert with 0, 17
                                            stor16[address(msg.sender)]++
                                            if stor16[address(stor30[arg1].field_2048)]:
                                                if stor16[address(stor30[arg1].field_2048)] < 1:
                                                    revert with 0, 17
                                                stor16[address(stor30[arg1].field_2048)]--
                                                require ext_code.size(address(stor14.field_0))
                                                call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args msg.sender, stor16[address(msg.sender)]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).0xd0e30db0 with:
                                               value uint256(stor30[arg1].field_512) * stor17 / stor19 wei
                                                 gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                if uint256(stor30[arg1].field_512) * stor17 / stor19 > -1:
                                    revert with 0, 17
                                if uint256(stor30[arg1].field_512) < uint256(stor30[arg1].field_512) * stor17 / stor19:
                                    revert with 0, 17
                                call address(stor30[arg1].field_2048) with:
                                   value uint256(stor30[arg1].field_512) - (uint256(stor30[arg1].field_512) * stor17 / stor19) wei
                                     gas 2300 * is_zero(value) wei
                            else:
                                if uint256(stor30[arg1].field_512) and stor12 > -1 / uint256(stor30[arg1].field_512):
                                    revert with 0, 17
                                if not stor19:
                                    revert with 0, 18
                                if uint256(stor30[arg1].field_512) * stor12 / stor19:
                                    require ext_code.size(stor13)
                                    call stor13.0xd0e30db0 with:
                                       value uint256(stor30[arg1].field_512) * stor12 / stor19 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                if uint256(stor30[arg1].field_512) * stor17 / stor19:
                                    if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                        if uint256(stor30[arg1].field_512) * stor17 / stor19 and stor11 > -1 / uint256(stor30[arg1].field_512) * stor17 / stor19:
                                            revert with 0, 17
                                        call address(stor10.field_8) with:
                                           value uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100 wei
                                             gas 2300 * is_zero(value) wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint256(stor30[arg1].field_512) * stor17 / stor19 < uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100:
                                            revert with 0, 17
                                        call stor21 with:
                                           value (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100) wei
                                             gas 2300 * is_zero(value) wei
                                    else:
                                        if not uint8(stor14.field_160):
                                            if uint256(stor30[arg1].field_512) * stor17 / stor19 and stor11 > -1 / uint256(stor30[arg1].field_512) * stor17 / stor19:
                                                revert with 0, 17
                                            call address(stor10.field_8) with:
                                               value uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100 wei
                                                 gas 2300 * is_zero(value) wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if uint256(stor30[arg1].field_512) * stor17 / stor19 < uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100:
                                                revert with 0, 17
                                            call stor21 with:
                                               value (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100) wei
                                                 gas 2300 * is_zero(value) wei
                                        else:
                                            if stor16[address(msg.sender)] > -2:
                                                revert with 0, 17
                                            stor16[address(msg.sender)]++
                                            if stor16[address(stor30[arg1].field_2048)]:
                                                if stor16[address(stor30[arg1].field_2048)] < 1:
                                                    revert with 0, 17
                                                stor16[address(stor30[arg1].field_2048)]--
                                                require ext_code.size(address(stor14.field_0))
                                                call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args msg.sender, stor16[address(msg.sender)]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).0xd0e30db0 with:
                                               value uint256(stor30[arg1].field_512) * stor17 / stor19 wei
                                                 gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                if uint256(stor30[arg1].field_512) * stor17 / stor19 > !(uint256(stor30[arg1].field_512) * stor12 / stor19):
                                    revert with 0, 17
                                if uint256(stor30[arg1].field_512) < (uint256(stor30[arg1].field_512) * stor17 / stor19) + (uint256(stor30[arg1].field_512) * stor12 / stor19):
                                    revert with 0, 17
                                call address(stor30[arg1].field_2048) with:
                                   value uint256(stor30[arg1].field_512) - (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor12 / stor19) wei
                                     gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            sub_3f88d08a[address(stor30[arg1].field_2560)]++
                            sub_3f88d08a[address(stor30[arg1].field_2560)][sub_3f88d08a[address(stor30[arg1].field_2560)]] = arg1
                            if address(stor30[arg1].field_2048) != msg.sender:
                                if block.timestamp < stor48:
                                    revert with 0, 17
                                if block.timestamp - stor48 >= 24 * 3600:
                                    sub_95ddf83a[address(stor30[arg1].field_2560)] = 0
                                    stor48 = block.timestamp
                                if sub_95ddf83a[address(stor30[arg1].field_2560)] > !uint256(stor30[arg1].field_512):
                                    revert with 0, 17
                                sub_95ddf83a[address(stor30[arg1].field_2560)] += uint256(stor30[arg1].field_512)
                                if sub_c38694a5[address(stor30[arg1].field_2560)] > !uint256(stor30[arg1].field_512):
                                    revert with 0, 17
                                sub_c38694a5[address(stor30[arg1].field_2560)] += uint256(stor30[arg1].field_512)
                                if sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > !uint256(stor30[arg1].field_512):
                                    revert with 0, 17
                                sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] += uint256(stor30[arg1].field_512)
                                if uint256(stor30[arg1].field_512) > uint256(stor30[stor52].field_1792):
                                    sub_9b175d77 = arg1
                                if not uint256(stor30[stor53].field_1792):
                                    sub_362f53ca = arg1
                                else:
                                    if uint256(stor30[arg1].field_512) < uint256(stor30[stor53].field_1792):
                                        sub_362f53ca = arg1
                            emit 0x9b3dc70a: arg1, uint256(stor30[arg1].field_512)
    return 1
}

function sub_8cdaab53(?) {
    require calldata.size - 4 >= 64
    require arg2 == bool(arg2)
    if owner != msg.sender:
        if not stor38[msg.sender]:
            if address(stor30[arg1].field_2048) != msg.sender:
                require msg.sender == address(stor30[arg1].field_2304)
    if not uint256(stor30[arg1].field_1280):
        revert with 0, 'Auction not finished'
    if block.timestamp < uint256(stor30[arg1].field_1280):
        revert with 0, 'Auction not finished'
    if not stor35[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
        revert with 0, 'Auction not finished'
    if not uint256(bids[arg1].field_0):
        if sub_ee218db4 < 0:
            revert with 0, 17
        if not uint256(stor30[arg1].field_1024):
            uint256(stor30[arg1].field_1536) = 1
            stor35[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] = 0
            if sub_07889cc9.length < 1:
                revert with 0, 17
            if sub_07889cc9.length - 1 >= sub_07889cc9.length:
                revert with 0, 50
            if sub_17cd4006[arg1] >= sub_07889cc9.length:
                revert with 0, 50
            sub_07889cc9[stor37[arg1]] = sub_07889cc9[sub_07889cc9.length]
            if sub_07889cc9.length < 1:
                revert with 0, 17
            if sub_07889cc9.length - 1 >= sub_07889cc9.length:
                revert with 0, 50
            sub_17cd4006[stor36[stor36.length]] = sub_17cd4006[arg1]
            if not sub_07889cc9.length:
                revert with 0, 49
            sub_07889cc9[sub_07889cc9.length] = 0
            sub_07889cc9.length--
        else:
            if 0 >= uint256(stor30[arg1].field_1024):
                uint256(stor30[arg1].field_1536) = 1
                stor35[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] = 0
                if sub_07889cc9.length < 1:
                    revert with 0, 17
                if sub_07889cc9.length - 1 >= sub_07889cc9.length:
                    revert with 0, 50
                if sub_17cd4006[arg1] >= sub_07889cc9.length:
                    revert with 0, 50
                sub_07889cc9[stor37[arg1]] = sub_07889cc9[sub_07889cc9.length]
                if sub_07889cc9.length < 1:
                    revert with 0, 17
                if sub_07889cc9.length - 1 >= sub_07889cc9.length:
                    revert with 0, 50
                sub_17cd4006[stor36[stor36.length]] = sub_17cd4006[arg1]
                if not sub_07889cc9.length:
                    revert with 0, 49
                sub_07889cc9[sub_07889cc9.length] = 0
                sub_07889cc9.length--
            else:
                if arg2:
                    if address(stor30[arg1].field_2048) != msg.sender:
                        revert with 0, 'Only seller can accept lower than reserve price'
                    uint256(stor30[arg1].field_1536) = 1
                    stor35[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] = 0
                    if sub_07889cc9.length < 1:
                        revert with 0, 17
                    if sub_07889cc9.length - 1 >= sub_07889cc9.length:
                        revert with 0, 50
                    if sub_17cd4006[arg1] >= sub_07889cc9.length:
                        revert with 0, 50
                    sub_07889cc9[stor37[arg1]] = sub_07889cc9[sub_07889cc9.length]
                    if sub_07889cc9.length < 1:
                        revert with 0, 17
                    if sub_07889cc9.length - 1 >= sub_07889cc9.length:
                        revert with 0, 50
                    sub_17cd4006[stor36[stor36.length]] = sub_17cd4006[arg1]
                    if not sub_07889cc9.length:
                        revert with 0, 49
                    sub_07889cc9[sub_07889cc9.length] = 0
                    sub_07889cc9.length--
                else:
                    uint256(stor30[arg1].field_1536) = 1
                    stor35[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] = 0
                    if sub_07889cc9.length < 1:
                        revert with 0, 17
                    if sub_07889cc9.length - 1 >= sub_07889cc9.length:
                        revert with 0, 50
                    if sub_17cd4006[arg1] >= sub_07889cc9.length:
                        revert with 0, 50
                    sub_07889cc9[stor37[arg1]] = sub_07889cc9[sub_07889cc9.length]
                    if sub_07889cc9.length < 1:
                        revert with 0, 17
                    if sub_07889cc9.length - 1 >= sub_07889cc9.length:
                        revert with 0, 50
                    sub_17cd4006[stor36[stor36.length]] = sub_17cd4006[arg1]
                    if not sub_07889cc9.length:
                        revert with 0, 49
                    sub_07889cc9[sub_07889cc9.length] = 0
                    sub_07889cc9.length--
                    require ext_code.size(address(stor30[arg1].field_2560))
                    call address(stor30[arg1].field_2560).0x42842e0e with:
                         gas gas_remaining wei
                        args this.address, address(stor30[arg1].field_2048), uint256(stor30[arg1].field_256)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
    else:
        if uint256(bids[arg1].field_0) < 1:
            revert with 0, 17
        if uint256(bids[arg1].field_0) - 1 >= uint256(bids[arg1].field_0):
            revert with 0, 50
        if sub_ee218db4 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
            revert with 0, 17
        sub_ee218db4 -= uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
        if not uint256(stor30[arg1].field_1024):
            uint256(stor30[arg1].field_1536) = 1
            stor35[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] = 0
            if sub_07889cc9.length < 1:
                revert with 0, 17
            if sub_07889cc9.length - 1 >= sub_07889cc9.length:
                revert with 0, 50
            if sub_17cd4006[arg1] >= sub_07889cc9.length:
                revert with 0, 50
            sub_07889cc9[stor37[arg1]] = sub_07889cc9[sub_07889cc9.length]
            if sub_07889cc9.length < 1:
                revert with 0, 17
            if sub_07889cc9.length - 1 >= sub_07889cc9.length:
                revert with 0, 50
            sub_17cd4006[stor36[stor36.length]] = sub_17cd4006[arg1]
            if not sub_07889cc9.length:
                revert with 0, 49
            sub_07889cc9[sub_07889cc9.length] = 0
            sub_07889cc9.length--
            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                if not uint256(stor30[arg1].field_512):
                    address(stor30[arg1].field_2304) = address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0)
                    uint256(stor30[arg1].field_1792) = uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                    uint256(stor30[arg1].field_1536) = block.timestamp
                    require ext_code.size(address(stor30[arg1].field_2560))
                    call address(stor30[arg1].field_2560).0x42842e0e with:
                         gas gas_remaining wei
                        args this.address, address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), uint256(stor30[arg1].field_256)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) and stor17 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                        revert with 0, 17
                    if not stor19:
                        revert with 0, 18
                    if not uint8(stor14.field_160):
                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                            if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                    revert with 0, 17
                                call address(stor10.field_8) with:
                                   value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                     gas 2300 * is_zero(value) wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                    revert with 0, 17
                                call stor21 with:
                                   value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                     gas 2300 * is_zero(value) wei
                            else:
                                if not uint8(stor14.field_160):
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                        revert with 0, 17
                                    call address(stor10.field_8) with:
                                       value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                         gas 2300 * is_zero(value) wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                        revert with 0, 17
                                    call stor21 with:
                                       value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                         gas 2300 * is_zero(value) wei
                                else:
                                    if stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)] > -2:
                                        revert with 0, 17
                                    stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]++
                                    if stor16[address(stor30[arg1].field_2048)]:
                                        if stor16[address(stor30[arg1].field_2048)] < 1:
                                            revert with 0, 17
                                        stor16[address(stor30[arg1].field_2048)]--
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(stor14.field_0))
                                    call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(stor14.field_0))
                                    call address(stor14.field_0).0xd0e30db0 with:
                                       value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 wei
                                         gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 > -1:
                            revert with 0, 17
                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                            revert with 0, 17
                        call address(stor30[arg1].field_2048) with:
                           value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) wei
                             gas 2300 * is_zero(value) wei
                    else:
                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) and stor12 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                            revert with 0, 17
                        if not stor19:
                            revert with 0, 18
                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19:
                            require ext_code.size(stor13)
                            call stor13.0xd0e30db0 with:
                               value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19 wei
                                 gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                            if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                    revert with 0, 17
                                call address(stor10.field_8) with:
                                   value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                     gas 2300 * is_zero(value) wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                    revert with 0, 17
                                call stor21 with:
                                   value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                     gas 2300 * is_zero(value) wei
                            else:
                                if not uint8(stor14.field_160):
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                        revert with 0, 17
                                    call address(stor10.field_8) with:
                                       value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                         gas 2300 * is_zero(value) wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                        revert with 0, 17
                                    call stor21 with:
                                       value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                         gas 2300 * is_zero(value) wei
                                else:
                                    if stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)] > -2:
                                        revert with 0, 17
                                    stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]++
                                    if stor16[address(stor30[arg1].field_2048)]:
                                        if stor16[address(stor30[arg1].field_2048)] < 1:
                                            revert with 0, 17
                                        stor16[address(stor30[arg1].field_2048)]--
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(stor14.field_0))
                                    call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                         gas gas_remaining wei
                                        args address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(address(stor14.field_0))
                                    call address(stor14.field_0).0xd0e30db0 with:
                                       value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 wei
                                         gas gas_remaining wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 > !(uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19):
                            revert with 0, 17
                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) + (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19):
                            revert with 0, 17
                        call address(stor30[arg1].field_2048) with:
                           value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19) wei
                             gas 2300 * is_zero(value) wei
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    sub_3f88d08a[address(stor30[arg1].field_2560)]++
                    sub_3f88d08a[address(stor30[arg1].field_2560)][sub_3f88d08a[address(stor30[arg1].field_2560)]] = arg1
                    if address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0) != address(stor30[arg1].field_2048):
                        if block.timestamp < stor48:
                            revert with 0, 17
                        if block.timestamp - stor48 >= 24 * 3600:
                            sub_95ddf83a[address(stor30[arg1].field_2560)] = 0
                            stor48 = block.timestamp
                        if sub_95ddf83a[address(stor30[arg1].field_2560)] > !uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                            revert with 0, 17
                        sub_95ddf83a[address(stor30[arg1].field_2560)] += uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                        if sub_c38694a5[address(stor30[arg1].field_2560)] > !uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                            revert with 0, 17
                        sub_c38694a5[address(stor30[arg1].field_2560)] += uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                        if sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > !uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                            revert with 0, 17
                        sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] += uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) > uint256(stor30[stor52].field_1792):
                            sub_9b175d77 = arg1
                        if not uint256(stor30[stor53].field_1792):
                            sub_362f53ca = arg1
                        else:
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < uint256(stor30[stor53].field_1792):
                                sub_362f53ca = arg1
                    emit 0x9b3dc70a: arg1, uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                else:
                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) <= uint256(stor30[arg1].field_512):
                        address(stor30[arg1].field_2304) = address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0)
                        uint256(stor30[arg1].field_1792) = uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                        uint256(stor30[arg1].field_1536) = block.timestamp
                        require ext_code.size(address(stor30[arg1].field_2560))
                        call address(stor30[arg1].field_2560).0x42842e0e with:
                             gas gas_remaining wei
                            args this.address, address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), uint256(stor30[arg1].field_256)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) and stor17 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                            revert with 0, 17
                        if not stor19:
                            revert with 0, 18
                        if not uint8(stor14.field_160):
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                        revert with 0, 17
                                    call address(stor10.field_8) with:
                                       value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                         gas 2300 * is_zero(value) wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                        revert with 0, 17
                                    call stor21 with:
                                       value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                         gas 2300 * is_zero(value) wei
                                else:
                                    if not uint8(stor14.field_160):
                                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                            revert with 0, 17
                                        call address(stor10.field_8) with:
                                           value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                             gas 2300 * is_zero(value) wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                            revert with 0, 17
                                        call stor21 with:
                                           value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                             gas 2300 * is_zero(value) wei
                                    else:
                                        if stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)] > -2:
                                            revert with 0, 17
                                        stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]++
                                        if stor16[address(stor30[arg1].field_2048)]:
                                            if stor16[address(stor30[arg1].field_2048)] < 1:
                                                revert with 0, 17
                                            stor16[address(stor30[arg1].field_2048)]--
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).0xd0e30db0 with:
                                           value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 wei
                                             gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 > -1:
                                revert with 0, 17
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                revert with 0, 17
                            call address(stor30[arg1].field_2048) with:
                               value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) wei
                                 gas 2300 * is_zero(value) wei
                        else:
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) and stor12 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                revert with 0, 17
                            if not stor19:
                                revert with 0, 18
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19:
                                require ext_code.size(stor13)
                                call stor13.0xd0e30db0 with:
                                   value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                        revert with 0, 17
                                    call address(stor10.field_8) with:
                                       value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                         gas 2300 * is_zero(value) wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                        revert with 0, 17
                                    call stor21 with:
                                       value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                         gas 2300 * is_zero(value) wei
                                else:
                                    if not uint8(stor14.field_160):
                                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                            revert with 0, 17
                                        call address(stor10.field_8) with:
                                           value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                             gas 2300 * is_zero(value) wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                            revert with 0, 17
                                        call stor21 with:
                                           value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                             gas 2300 * is_zero(value) wei
                                    else:
                                        if stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)] > -2:
                                            revert with 0, 17
                                        stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]++
                                        if stor16[address(stor30[arg1].field_2048)]:
                                            if stor16[address(stor30[arg1].field_2048)] < 1:
                                                revert with 0, 17
                                            stor16[address(stor30[arg1].field_2048)]--
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).0xd0e30db0 with:
                                           value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 wei
                                             gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 > !(uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19):
                                revert with 0, 17
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) + (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19):
                                revert with 0, 17
                            call address(stor30[arg1].field_2048) with:
                               value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19) wei
                                 gas 2300 * is_zero(value) wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        sub_3f88d08a[address(stor30[arg1].field_2560)]++
                        sub_3f88d08a[address(stor30[arg1].field_2560)][sub_3f88d08a[address(stor30[arg1].field_2560)]] = arg1
                        if address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0) != address(stor30[arg1].field_2048):
                            if block.timestamp < stor48:
                                revert with 0, 17
                            if block.timestamp - stor48 >= 24 * 3600:
                                sub_95ddf83a[address(stor30[arg1].field_2560)] = 0
                                stor48 = block.timestamp
                            if sub_95ddf83a[address(stor30[arg1].field_2560)] > !uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                revert with 0, 17
                            sub_95ddf83a[address(stor30[arg1].field_2560)] += uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                            if sub_c38694a5[address(stor30[arg1].field_2560)] > !uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                revert with 0, 17
                            sub_c38694a5[address(stor30[arg1].field_2560)] += uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                            if sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > !uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                revert with 0, 17
                            sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] += uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) > uint256(stor30[stor52].field_1792):
                                sub_9b175d77 = arg1
                            if not uint256(stor30[stor53].field_1792):
                                sub_362f53ca = arg1
                            else:
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < uint256(stor30[stor53].field_1792):
                                    sub_362f53ca = arg1
                        emit 0x9b3dc70a: arg1, uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                    else:
                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < uint256(stor30[arg1].field_512):
                            revert with 0, 17
                        call address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0) with:
                           value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) - uint256(stor30[arg1].field_512) wei
                             gas 2300 * is_zero(value) wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        address(stor30[arg1].field_2304) = address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0)
                        uint256(stor30[arg1].field_1792) = uint256(stor30[arg1].field_512)
                        uint256(stor30[arg1].field_1536) = block.timestamp
                        require ext_code.size(address(stor30[arg1].field_2560))
                        call address(stor30[arg1].field_2560).0x42842e0e with:
                             gas gas_remaining wei
                            args this.address, address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), uint256(stor30[arg1].field_256)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint256(stor30[arg1].field_512) and stor17 > -1 / uint256(stor30[arg1].field_512):
                            revert with 0, 17
                        if not stor19:
                            revert with 0, 18
                        if not uint8(stor14.field_160):
                            if uint256(stor30[arg1].field_512) * stor17 / stor19:
                                if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                    if uint256(stor30[arg1].field_512) * stor17 / stor19 and stor11 > -1 / uint256(stor30[arg1].field_512) * stor17 / stor19:
                                        revert with 0, 17
                                    call address(stor10.field_8) with:
                                       value uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100 wei
                                         gas 2300 * is_zero(value) wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint256(stor30[arg1].field_512) * stor17 / stor19 < uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100:
                                        revert with 0, 17
                                    call stor21 with:
                                       value (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100) wei
                                         gas 2300 * is_zero(value) wei
                                else:
                                    if not uint8(stor14.field_160):
                                        if uint256(stor30[arg1].field_512) * stor17 / stor19 and stor11 > -1 / uint256(stor30[arg1].field_512) * stor17 / stor19:
                                            revert with 0, 17
                                        call address(stor10.field_8) with:
                                           value uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100 wei
                                             gas 2300 * is_zero(value) wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint256(stor30[arg1].field_512) * stor17 / stor19 < uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100:
                                            revert with 0, 17
                                        call stor21 with:
                                           value (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100) wei
                                             gas 2300 * is_zero(value) wei
                                    else:
                                        if stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)] > -2:
                                            revert with 0, 17
                                        stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]++
                                        if stor16[address(stor30[arg1].field_2048)]:
                                            if stor16[address(stor30[arg1].field_2048)] < 1:
                                                revert with 0, 17
                                            stor16[address(stor30[arg1].field_2048)]--
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).0xd0e30db0 with:
                                           value uint256(stor30[arg1].field_512) * stor17 / stor19 wei
                                             gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            if uint256(stor30[arg1].field_512) * stor17 / stor19 > -1:
                                revert with 0, 17
                            if uint256(stor30[arg1].field_512) < uint256(stor30[arg1].field_512) * stor17 / stor19:
                                revert with 0, 17
                            call address(stor30[arg1].field_2048) with:
                               value uint256(stor30[arg1].field_512) - (uint256(stor30[arg1].field_512) * stor17 / stor19) wei
                                 gas 2300 * is_zero(value) wei
                        else:
                            if uint256(stor30[arg1].field_512) and stor12 > -1 / uint256(stor30[arg1].field_512):
                                revert with 0, 17
                            if not stor19:
                                revert with 0, 18
                            if uint256(stor30[arg1].field_512) * stor12 / stor19:
                                require ext_code.size(stor13)
                                call stor13.0xd0e30db0 with:
                                   value uint256(stor30[arg1].field_512) * stor12 / stor19 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            if uint256(stor30[arg1].field_512) * stor17 / stor19:
                                if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                    if uint256(stor30[arg1].field_512) * stor17 / stor19 and stor11 > -1 / uint256(stor30[arg1].field_512) * stor17 / stor19:
                                        revert with 0, 17
                                    call address(stor10.field_8) with:
                                       value uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100 wei
                                         gas 2300 * is_zero(value) wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint256(stor30[arg1].field_512) * stor17 / stor19 < uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100:
                                        revert with 0, 17
                                    call stor21 with:
                                       value (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100) wei
                                         gas 2300 * is_zero(value) wei
                                else:
                                    if not uint8(stor14.field_160):
                                        if uint256(stor30[arg1].field_512) * stor17 / stor19 and stor11 > -1 / uint256(stor30[arg1].field_512) * stor17 / stor19:
                                            revert with 0, 17
                                        call address(stor10.field_8) with:
                                           value uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100 wei
                                             gas 2300 * is_zero(value) wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint256(stor30[arg1].field_512) * stor17 / stor19 < uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100:
                                            revert with 0, 17
                                        call stor21 with:
                                           value (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100) wei
                                             gas 2300 * is_zero(value) wei
                                    else:
                                        if stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)] > -2:
                                            revert with 0, 17
                                        stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]++
                                        if stor16[address(stor30[arg1].field_2048)]:
                                            if stor16[address(stor30[arg1].field_2048)] < 1:
                                                revert with 0, 17
                                            stor16[address(stor30[arg1].field_2048)]--
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).0xd0e30db0 with:
                                           value uint256(stor30[arg1].field_512) * stor17 / stor19 wei
                                             gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            if uint256(stor30[arg1].field_512) * stor17 / stor19 > !(uint256(stor30[arg1].field_512) * stor12 / stor19):
                                revert with 0, 17
                            if uint256(stor30[arg1].field_512) < (uint256(stor30[arg1].field_512) * stor17 / stor19) + (uint256(stor30[arg1].field_512) * stor12 / stor19):
                                revert with 0, 17
                            call address(stor30[arg1].field_2048) with:
                               value uint256(stor30[arg1].field_512) - (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor12 / stor19) wei
                                 gas 2300 * is_zero(value) wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        sub_3f88d08a[address(stor30[arg1].field_2560)]++
                        sub_3f88d08a[address(stor30[arg1].field_2560)][sub_3f88d08a[address(stor30[arg1].field_2560)]] = arg1
                        if address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0) != address(stor30[arg1].field_2048):
                            if block.timestamp < stor48:
                                revert with 0, 17
                            if block.timestamp - stor48 >= 24 * 3600:
                                sub_95ddf83a[address(stor30[arg1].field_2560)] = 0
                                stor48 = block.timestamp
                            if sub_95ddf83a[address(stor30[arg1].field_2560)] > !uint256(stor30[arg1].field_512):
                                revert with 0, 17
                            sub_95ddf83a[address(stor30[arg1].field_2560)] += uint256(stor30[arg1].field_512)
                            if sub_c38694a5[address(stor30[arg1].field_2560)] > !uint256(stor30[arg1].field_512):
                                revert with 0, 17
                            sub_c38694a5[address(stor30[arg1].field_2560)] += uint256(stor30[arg1].field_512)
                            if sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > !uint256(stor30[arg1].field_512):
                                revert with 0, 17
                            sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] += uint256(stor30[arg1].field_512)
                            if uint256(stor30[arg1].field_512) > uint256(stor30[stor52].field_1792):
                                sub_9b175d77 = arg1
                            if not uint256(stor30[stor53].field_1792):
                                sub_362f53ca = arg1
                            else:
                                if uint256(stor30[arg1].field_512) < uint256(stor30[stor53].field_1792):
                                    sub_362f53ca = arg1
                        emit 0x9b3dc70a: arg1, uint256(stor30[arg1].field_512)
        else:
            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) >= uint256(stor30[arg1].field_1024):
                uint256(stor30[arg1].field_1536) = 1
                stor35[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] = 0
                if sub_07889cc9.length < 1:
                    revert with 0, 17
                if sub_07889cc9.length - 1 >= sub_07889cc9.length:
                    revert with 0, 50
                if sub_17cd4006[arg1] >= sub_07889cc9.length:
                    revert with 0, 50
                sub_07889cc9[stor37[arg1]] = sub_07889cc9[sub_07889cc9.length]
                if sub_07889cc9.length < 1:
                    revert with 0, 17
                if sub_07889cc9.length - 1 >= sub_07889cc9.length:
                    revert with 0, 50
                sub_17cd4006[stor36[stor36.length]] = sub_17cd4006[arg1]
                if not sub_07889cc9.length:
                    revert with 0, 49
                sub_07889cc9[sub_07889cc9.length] = 0
                sub_07889cc9.length--
                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                    if not uint256(stor30[arg1].field_512):
                        address(stor30[arg1].field_2304) = address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0)
                        uint256(stor30[arg1].field_1792) = uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                        uint256(stor30[arg1].field_1536) = block.timestamp
                        require ext_code.size(address(stor30[arg1].field_2560))
                        call address(stor30[arg1].field_2560).0x42842e0e with:
                             gas gas_remaining wei
                            args this.address, address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), uint256(stor30[arg1].field_256)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) and stor17 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                            revert with 0, 17
                        if not stor19:
                            revert with 0, 18
                        if not uint8(stor14.field_160):
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                        revert with 0, 17
                                    call address(stor10.field_8) with:
                                       value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                         gas 2300 * is_zero(value) wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                        revert with 0, 17
                                    call stor21 with:
                                       value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                         gas 2300 * is_zero(value) wei
                                else:
                                    if not uint8(stor14.field_160):
                                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                            revert with 0, 17
                                        call address(stor10.field_8) with:
                                           value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                             gas 2300 * is_zero(value) wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                            revert with 0, 17
                                        call stor21 with:
                                           value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                             gas 2300 * is_zero(value) wei
                                    else:
                                        if stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)] > -2:
                                            revert with 0, 17
                                        stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]++
                                        if stor16[address(stor30[arg1].field_2048)]:
                                            if stor16[address(stor30[arg1].field_2048)] < 1:
                                                revert with 0, 17
                                            stor16[address(stor30[arg1].field_2048)]--
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).0xd0e30db0 with:
                                           value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 wei
                                             gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 > -1:
                                revert with 0, 17
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                revert with 0, 17
                            call address(stor30[arg1].field_2048) with:
                               value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) wei
                                 gas 2300 * is_zero(value) wei
                        else:
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) and stor12 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                revert with 0, 17
                            if not stor19:
                                revert with 0, 18
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19:
                                require ext_code.size(stor13)
                                call stor13.0xd0e30db0 with:
                                   value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19 wei
                                     gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                        revert with 0, 17
                                    call address(stor10.field_8) with:
                                       value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                         gas 2300 * is_zero(value) wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                        revert with 0, 17
                                    call stor21 with:
                                       value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                         gas 2300 * is_zero(value) wei
                                else:
                                    if not uint8(stor14.field_160):
                                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                            revert with 0, 17
                                        call address(stor10.field_8) with:
                                           value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                             gas 2300 * is_zero(value) wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                            revert with 0, 17
                                        call stor21 with:
                                           value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                             gas 2300 * is_zero(value) wei
                                    else:
                                        if stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)] > -2:
                                            revert with 0, 17
                                        stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]++
                                        if stor16[address(stor30[arg1].field_2048)]:
                                            if stor16[address(stor30[arg1].field_2048)] < 1:
                                                revert with 0, 17
                                            stor16[address(stor30[arg1].field_2048)]--
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                             gas gas_remaining wei
                                            args address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(address(stor14.field_0))
                                        call address(stor14.field_0).0xd0e30db0 with:
                                           value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 wei
                                             gas gas_remaining wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 > !(uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19):
                                revert with 0, 17
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) + (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19):
                                revert with 0, 17
                            call address(stor30[arg1].field_2048) with:
                               value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19) wei
                                 gas 2300 * is_zero(value) wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        sub_3f88d08a[address(stor30[arg1].field_2560)]++
                        sub_3f88d08a[address(stor30[arg1].field_2560)][sub_3f88d08a[address(stor30[arg1].field_2560)]] = arg1
                        if address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0) != address(stor30[arg1].field_2048):
                            if block.timestamp < stor48:
                                revert with 0, 17
                            if block.timestamp - stor48 >= 24 * 3600:
                                sub_95ddf83a[address(stor30[arg1].field_2560)] = 0
                                stor48 = block.timestamp
                            if sub_95ddf83a[address(stor30[arg1].field_2560)] > !uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                revert with 0, 17
                            sub_95ddf83a[address(stor30[arg1].field_2560)] += uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                            if sub_c38694a5[address(stor30[arg1].field_2560)] > !uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                revert with 0, 17
                            sub_c38694a5[address(stor30[arg1].field_2560)] += uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                            if sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > !uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                revert with 0, 17
                            sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] += uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) > uint256(stor30[stor52].field_1792):
                                sub_9b175d77 = arg1
                            if not uint256(stor30[stor53].field_1792):
                                sub_362f53ca = arg1
                            else:
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < uint256(stor30[stor53].field_1792):
                                    sub_362f53ca = arg1
                        emit 0x9b3dc70a: arg1, uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                    else:
                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) <= uint256(stor30[arg1].field_512):
                            address(stor30[arg1].field_2304) = address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0)
                            uint256(stor30[arg1].field_1792) = uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                            uint256(stor30[arg1].field_1536) = block.timestamp
                            require ext_code.size(address(stor30[arg1].field_2560))
                            call address(stor30[arg1].field_2560).0x42842e0e with:
                                 gas gas_remaining wei
                                args this.address, address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), uint256(stor30[arg1].field_256)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) and stor17 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                revert with 0, 17
                            if not stor19:
                                revert with 0, 18
                            if not uint8(stor14.field_160):
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                    if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                            revert with 0, 17
                                        call address(stor10.field_8) with:
                                           value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                             gas 2300 * is_zero(value) wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                            revert with 0, 17
                                        call stor21 with:
                                           value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                             gas 2300 * is_zero(value) wei
                                    else:
                                        if not uint8(stor14.field_160):
                                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                                revert with 0, 17
                                            call address(stor10.field_8) with:
                                               value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                                 gas 2300 * is_zero(value) wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                                revert with 0, 17
                                            call stor21 with:
                                               value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                                 gas 2300 * is_zero(value) wei
                                        else:
                                            if stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)] > -2:
                                                revert with 0, 17
                                            stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]++
                                            if stor16[address(stor30[arg1].field_2048)]:
                                                if stor16[address(stor30[arg1].field_2048)] < 1:
                                                    revert with 0, 17
                                                stor16[address(stor30[arg1].field_2048)]--
                                                require ext_code.size(address(stor14.field_0))
                                                call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).0xd0e30db0 with:
                                               value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 wei
                                                 gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 > -1:
                                    revert with 0, 17
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                    revert with 0, 17
                                call address(stor30[arg1].field_2048) with:
                                   value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) wei
                                     gas 2300 * is_zero(value) wei
                            else:
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) and stor12 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                    revert with 0, 17
                                if not stor19:
                                    revert with 0, 18
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19:
                                    require ext_code.size(stor13)
                                    call stor13.0xd0e30db0 with:
                                       value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                    if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                            revert with 0, 17
                                        call address(stor10.field_8) with:
                                           value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                             gas 2300 * is_zero(value) wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                            revert with 0, 17
                                        call stor21 with:
                                           value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                             gas 2300 * is_zero(value) wei
                                    else:
                                        if not uint8(stor14.field_160):
                                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                                revert with 0, 17
                                            call address(stor10.field_8) with:
                                               value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                                 gas 2300 * is_zero(value) wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                                revert with 0, 17
                                            call stor21 with:
                                               value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                                 gas 2300 * is_zero(value) wei
                                        else:
                                            if stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)] > -2:
                                                revert with 0, 17
                                            stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]++
                                            if stor16[address(stor30[arg1].field_2048)]:
                                                if stor16[address(stor30[arg1].field_2048)] < 1:
                                                    revert with 0, 17
                                                stor16[address(stor30[arg1].field_2048)]--
                                                require ext_code.size(address(stor14.field_0))
                                                call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).0xd0e30db0 with:
                                               value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 wei
                                                 gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 > !(uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19):
                                    revert with 0, 17
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) + (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19):
                                    revert with 0, 17
                                call address(stor30[arg1].field_2048) with:
                                   value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19) wei
                                     gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            sub_3f88d08a[address(stor30[arg1].field_2560)]++
                            sub_3f88d08a[address(stor30[arg1].field_2560)][sub_3f88d08a[address(stor30[arg1].field_2560)]] = arg1
                            if address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0) != address(stor30[arg1].field_2048):
                                if block.timestamp < stor48:
                                    revert with 0, 17
                                if block.timestamp - stor48 >= 24 * 3600:
                                    sub_95ddf83a[address(stor30[arg1].field_2560)] = 0
                                    stor48 = block.timestamp
                                if sub_95ddf83a[address(stor30[arg1].field_2560)] > !uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                    revert with 0, 17
                                sub_95ddf83a[address(stor30[arg1].field_2560)] += uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                                if sub_c38694a5[address(stor30[arg1].field_2560)] > !uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                    revert with 0, 17
                                sub_c38694a5[address(stor30[arg1].field_2560)] += uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                                if sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > !uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                    revert with 0, 17
                                sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] += uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) > uint256(stor30[stor52].field_1792):
                                    sub_9b175d77 = arg1
                                if not uint256(stor30[stor53].field_1792):
                                    sub_362f53ca = arg1
                                else:
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < uint256(stor30[stor53].field_1792):
                                        sub_362f53ca = arg1
                            emit 0x9b3dc70a: arg1, uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                        else:
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < uint256(stor30[arg1].field_512):
                                revert with 0, 17
                            call address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0) with:
                               value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) - uint256(stor30[arg1].field_512) wei
                                 gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            address(stor30[arg1].field_2304) = address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0)
                            uint256(stor30[arg1].field_1792) = uint256(stor30[arg1].field_512)
                            uint256(stor30[arg1].field_1536) = block.timestamp
                            require ext_code.size(address(stor30[arg1].field_2560))
                            call address(stor30[arg1].field_2560).0x42842e0e with:
                                 gas gas_remaining wei
                                args this.address, address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), uint256(stor30[arg1].field_256)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if uint256(stor30[arg1].field_512) and stor17 > -1 / uint256(stor30[arg1].field_512):
                                revert with 0, 17
                            if not stor19:
                                revert with 0, 18
                            if not uint8(stor14.field_160):
                                if uint256(stor30[arg1].field_512) * stor17 / stor19:
                                    if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                        if uint256(stor30[arg1].field_512) * stor17 / stor19 and stor11 > -1 / uint256(stor30[arg1].field_512) * stor17 / stor19:
                                            revert with 0, 17
                                        call address(stor10.field_8) with:
                                           value uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100 wei
                                             gas 2300 * is_zero(value) wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint256(stor30[arg1].field_512) * stor17 / stor19 < uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100:
                                            revert with 0, 17
                                        call stor21 with:
                                           value (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100) wei
                                             gas 2300 * is_zero(value) wei
                                    else:
                                        if not uint8(stor14.field_160):
                                            if uint256(stor30[arg1].field_512) * stor17 / stor19 and stor11 > -1 / uint256(stor30[arg1].field_512) * stor17 / stor19:
                                                revert with 0, 17
                                            call address(stor10.field_8) with:
                                               value uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100 wei
                                                 gas 2300 * is_zero(value) wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if uint256(stor30[arg1].field_512) * stor17 / stor19 < uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100:
                                                revert with 0, 17
                                            call stor21 with:
                                               value (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100) wei
                                                 gas 2300 * is_zero(value) wei
                                        else:
                                            if stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)] > -2:
                                                revert with 0, 17
                                            stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]++
                                            if stor16[address(stor30[arg1].field_2048)]:
                                                if stor16[address(stor30[arg1].field_2048)] < 1:
                                                    revert with 0, 17
                                                stor16[address(stor30[arg1].field_2048)]--
                                                require ext_code.size(address(stor14.field_0))
                                                call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).0xd0e30db0 with:
                                               value uint256(stor30[arg1].field_512) * stor17 / stor19 wei
                                                 gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                if uint256(stor30[arg1].field_512) * stor17 / stor19 > -1:
                                    revert with 0, 17
                                if uint256(stor30[arg1].field_512) < uint256(stor30[arg1].field_512) * stor17 / stor19:
                                    revert with 0, 17
                                call address(stor30[arg1].field_2048) with:
                                   value uint256(stor30[arg1].field_512) - (uint256(stor30[arg1].field_512) * stor17 / stor19) wei
                                     gas 2300 * is_zero(value) wei
                            else:
                                if uint256(stor30[arg1].field_512) and stor12 > -1 / uint256(stor30[arg1].field_512):
                                    revert with 0, 17
                                if not stor19:
                                    revert with 0, 18
                                if uint256(stor30[arg1].field_512) * stor12 / stor19:
                                    require ext_code.size(stor13)
                                    call stor13.0xd0e30db0 with:
                                       value uint256(stor30[arg1].field_512) * stor12 / stor19 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                if uint256(stor30[arg1].field_512) * stor17 / stor19:
                                    if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                        if uint256(stor30[arg1].field_512) * stor17 / stor19 and stor11 > -1 / uint256(stor30[arg1].field_512) * stor17 / stor19:
                                            revert with 0, 17
                                        call address(stor10.field_8) with:
                                           value uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100 wei
                                             gas 2300 * is_zero(value) wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint256(stor30[arg1].field_512) * stor17 / stor19 < uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100:
                                            revert with 0, 17
                                        call stor21 with:
                                           value (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100) wei
                                             gas 2300 * is_zero(value) wei
                                    else:
                                        if not uint8(stor14.field_160):
                                            if uint256(stor30[arg1].field_512) * stor17 / stor19 and stor11 > -1 / uint256(stor30[arg1].field_512) * stor17 / stor19:
                                                revert with 0, 17
                                            call address(stor10.field_8) with:
                                               value uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100 wei
                                                 gas 2300 * is_zero(value) wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if uint256(stor30[arg1].field_512) * stor17 / stor19 < uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100:
                                                revert with 0, 17
                                            call stor21 with:
                                               value (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100) wei
                                                 gas 2300 * is_zero(value) wei
                                        else:
                                            if stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)] > -2:
                                                revert with 0, 17
                                            stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]++
                                            if stor16[address(stor30[arg1].field_2048)]:
                                                if stor16[address(stor30[arg1].field_2048)] < 1:
                                                    revert with 0, 17
                                                stor16[address(stor30[arg1].field_2048)]--
                                                require ext_code.size(address(stor14.field_0))
                                                call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).0xd0e30db0 with:
                                               value uint256(stor30[arg1].field_512) * stor17 / stor19 wei
                                                 gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                if uint256(stor30[arg1].field_512) * stor17 / stor19 > !(uint256(stor30[arg1].field_512) * stor12 / stor19):
                                    revert with 0, 17
                                if uint256(stor30[arg1].field_512) < (uint256(stor30[arg1].field_512) * stor17 / stor19) + (uint256(stor30[arg1].field_512) * stor12 / stor19):
                                    revert with 0, 17
                                call address(stor30[arg1].field_2048) with:
                                   value uint256(stor30[arg1].field_512) - (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor12 / stor19) wei
                                     gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            sub_3f88d08a[address(stor30[arg1].field_2560)]++
                            sub_3f88d08a[address(stor30[arg1].field_2560)][sub_3f88d08a[address(stor30[arg1].field_2560)]] = arg1
                            if address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0) != address(stor30[arg1].field_2048):
                                if block.timestamp < stor48:
                                    revert with 0, 17
                                if block.timestamp - stor48 >= 24 * 3600:
                                    sub_95ddf83a[address(stor30[arg1].field_2560)] = 0
                                    stor48 = block.timestamp
                                if sub_95ddf83a[address(stor30[arg1].field_2560)] > !uint256(stor30[arg1].field_512):
                                    revert with 0, 17
                                sub_95ddf83a[address(stor30[arg1].field_2560)] += uint256(stor30[arg1].field_512)
                                if sub_c38694a5[address(stor30[arg1].field_2560)] > !uint256(stor30[arg1].field_512):
                                    revert with 0, 17
                                sub_c38694a5[address(stor30[arg1].field_2560)] += uint256(stor30[arg1].field_512)
                                if sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > !uint256(stor30[arg1].field_512):
                                    revert with 0, 17
                                sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] += uint256(stor30[arg1].field_512)
                                if uint256(stor30[arg1].field_512) > uint256(stor30[stor52].field_1792):
                                    sub_9b175d77 = arg1
                                if not uint256(stor30[stor53].field_1792):
                                    sub_362f53ca = arg1
                                else:
                                    if uint256(stor30[arg1].field_512) < uint256(stor30[stor53].field_1792):
                                        sub_362f53ca = arg1
                            emit 0x9b3dc70a: arg1, uint256(stor30[arg1].field_512)
            else:
                if not arg2:
                    uint256(stor30[arg1].field_1536) = 1
                    stor35[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] = 0
                    if sub_07889cc9.length < 1:
                        revert with 0, 17
                    if sub_07889cc9.length - 1 >= sub_07889cc9.length:
                        revert with 0, 50
                    if sub_17cd4006[arg1] >= sub_07889cc9.length:
                        revert with 0, 50
                    sub_07889cc9[stor37[arg1]] = sub_07889cc9[sub_07889cc9.length]
                    if sub_07889cc9.length < 1:
                        revert with 0, 17
                    if sub_07889cc9.length - 1 >= sub_07889cc9.length:
                        revert with 0, 50
                    sub_17cd4006[stor36[stor36.length]] = sub_17cd4006[arg1]
                    if not sub_07889cc9.length:
                        revert with 0, 49
                    sub_07889cc9[sub_07889cc9.length] = 0
                    sub_07889cc9.length--
                    require ext_code.size(address(stor30[arg1].field_2560))
                    call address(stor30[arg1].field_2560).0x42842e0e with:
                         gas gas_remaining wei
                        args this.address, address(stor30[arg1].field_2048), uint256(stor30[arg1].field_256)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) > 0:
                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) and stor18 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                            revert with 0, 17
                        if not stor19:
                            revert with 0, 18
                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor18 / stor19:
                            revert with 0, 17
                        call address(stor30[arg1].field_2304) with:
                           value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor18 / stor19) wei
                             gas 2300 * is_zero(value) wei
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                else:
                    if address(stor30[arg1].field_2048) != msg.sender:
                        revert with 0, 'Only seller can accept lower than reserve price'
                    uint256(stor30[arg1].field_1536) = 1
                    stor35[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] = 0
                    if sub_07889cc9.length < 1:
                        revert with 0, 17
                    if sub_07889cc9.length - 1 >= sub_07889cc9.length:
                        revert with 0, 50
                    if sub_17cd4006[arg1] >= sub_07889cc9.length:
                        revert with 0, 50
                    sub_07889cc9[stor37[arg1]] = sub_07889cc9[sub_07889cc9.length]
                    if sub_07889cc9.length < 1:
                        revert with 0, 17
                    if sub_07889cc9.length - 1 >= sub_07889cc9.length:
                        revert with 0, 50
                    sub_17cd4006[stor36[stor36.length]] = sub_17cd4006[arg1]
                    if not sub_07889cc9.length:
                        revert with 0, 49
                    sub_07889cc9[sub_07889cc9.length] = 0
                    sub_07889cc9.length--
                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                        if not uint256(stor30[arg1].field_512):
                            address(stor30[arg1].field_2304) = address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0)
                            uint256(stor30[arg1].field_1792) = uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                            uint256(stor30[arg1].field_1536) = block.timestamp
                            require ext_code.size(address(stor30[arg1].field_2560))
                            call address(stor30[arg1].field_2560).0x42842e0e with:
                                 gas gas_remaining wei
                                args this.address, address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), uint256(stor30[arg1].field_256)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) and stor17 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                revert with 0, 17
                            if not stor19:
                                revert with 0, 18
                            if not uint8(stor14.field_160):
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                    if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                            revert with 0, 17
                                        call address(stor10.field_8) with:
                                           value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                             gas 2300 * is_zero(value) wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                            revert with 0, 17
                                        call stor21 with:
                                           value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                             gas 2300 * is_zero(value) wei
                                    else:
                                        if not uint8(stor14.field_160):
                                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                                revert with 0, 17
                                            call address(stor10.field_8) with:
                                               value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                                 gas 2300 * is_zero(value) wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                                revert with 0, 17
                                            call stor21 with:
                                               value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                                 gas 2300 * is_zero(value) wei
                                        else:
                                            if stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)] > -2:
                                                revert with 0, 17
                                            stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]++
                                            if stor16[address(stor30[arg1].field_2048)]:
                                                if stor16[address(stor30[arg1].field_2048)] < 1:
                                                    revert with 0, 17
                                                stor16[address(stor30[arg1].field_2048)]--
                                                require ext_code.size(address(stor14.field_0))
                                                call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).0xd0e30db0 with:
                                               value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 wei
                                                 gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 > -1:
                                    revert with 0, 17
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                    revert with 0, 17
                                call address(stor30[arg1].field_2048) with:
                                   value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) wei
                                     gas 2300 * is_zero(value) wei
                            else:
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) and stor12 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                    revert with 0, 17
                                if not stor19:
                                    revert with 0, 18
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19:
                                    require ext_code.size(stor13)
                                    call stor13.0xd0e30db0 with:
                                       value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19 wei
                                         gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                    if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                            revert with 0, 17
                                        call address(stor10.field_8) with:
                                           value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                             gas 2300 * is_zero(value) wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                            revert with 0, 17
                                        call stor21 with:
                                           value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                             gas 2300 * is_zero(value) wei
                                    else:
                                        if not uint8(stor14.field_160):
                                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                                revert with 0, 17
                                            call address(stor10.field_8) with:
                                               value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                                 gas 2300 * is_zero(value) wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                                revert with 0, 17
                                            call stor21 with:
                                               value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                                 gas 2300 * is_zero(value) wei
                                        else:
                                            if stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)] > -2:
                                                revert with 0, 17
                                            stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]++
                                            if stor16[address(stor30[arg1].field_2048)]:
                                                if stor16[address(stor30[arg1].field_2048)] < 1:
                                                    revert with 0, 17
                                                stor16[address(stor30[arg1].field_2048)]--
                                                require ext_code.size(address(stor14.field_0))
                                                call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                 gas gas_remaining wei
                                                args address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require ext_code.size(address(stor14.field_0))
                                            call address(stor14.field_0).0xd0e30db0 with:
                                               value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 wei
                                                 gas gas_remaining wei
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 > !(uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19):
                                    revert with 0, 17
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) + (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19):
                                    revert with 0, 17
                                call address(stor30[arg1].field_2048) with:
                                   value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19) wei
                                     gas 2300 * is_zero(value) wei
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            sub_3f88d08a[address(stor30[arg1].field_2560)]++
                            sub_3f88d08a[address(stor30[arg1].field_2560)][sub_3f88d08a[address(stor30[arg1].field_2560)]] = arg1
                            if address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0) != address(stor30[arg1].field_2048):
                                if block.timestamp < stor48:
                                    revert with 0, 17
                                if block.timestamp - stor48 >= 24 * 3600:
                                    sub_95ddf83a[address(stor30[arg1].field_2560)] = 0
                                    stor48 = block.timestamp
                                if sub_95ddf83a[address(stor30[arg1].field_2560)] > !uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                    revert with 0, 17
                                sub_95ddf83a[address(stor30[arg1].field_2560)] += uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                                if sub_c38694a5[address(stor30[arg1].field_2560)] > !uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                    revert with 0, 17
                                sub_c38694a5[address(stor30[arg1].field_2560)] += uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                                if sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > !uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                    revert with 0, 17
                                sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] += uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) > uint256(stor30[stor52].field_1792):
                                    sub_9b175d77 = arg1
                                if not uint256(stor30[stor53].field_1792):
                                    sub_362f53ca = arg1
                                else:
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < uint256(stor30[stor53].field_1792):
                                        sub_362f53ca = arg1
                            emit 0x9b3dc70a: arg1, uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                        else:
                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) <= uint256(stor30[arg1].field_512):
                                address(stor30[arg1].field_2304) = address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0)
                                uint256(stor30[arg1].field_1792) = uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                                uint256(stor30[arg1].field_1536) = block.timestamp
                                require ext_code.size(address(stor30[arg1].field_2560))
                                call address(stor30[arg1].field_2560).0x42842e0e with:
                                     gas gas_remaining wei
                                    args this.address, address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), uint256(stor30[arg1].field_256)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) and stor17 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                    revert with 0, 17
                                if not stor19:
                                    revert with 0, 18
                                if not uint8(stor14.field_160):
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                        if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                                revert with 0, 17
                                            call address(stor10.field_8) with:
                                               value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                                 gas 2300 * is_zero(value) wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                                revert with 0, 17
                                            call stor21 with:
                                               value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                                 gas 2300 * is_zero(value) wei
                                        else:
                                            if not uint8(stor14.field_160):
                                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                                    revert with 0, 17
                                                call address(stor10.field_8) with:
                                                   value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                                     gas 2300 * is_zero(value) wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                                    revert with 0, 17
                                                call stor21 with:
                                                   value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                                     gas 2300 * is_zero(value) wei
                                            else:
                                                if stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)] > -2:
                                                    revert with 0, 17
                                                stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]++
                                                if stor16[address(stor30[arg1].field_2048)]:
                                                    if stor16[address(stor30[arg1].field_2048)] < 1:
                                                        revert with 0, 17
                                                    stor16[address(stor30[arg1].field_2048)]--
                                                    require ext_code.size(address(stor14.field_0))
                                                    call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(address(stor14.field_0))
                                                call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(address(stor14.field_0))
                                                call address(stor14.field_0).0xd0e30db0 with:
                                                   value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 wei
                                                     gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 > -1:
                                        revert with 0, 17
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                        revert with 0, 17
                                    call address(stor30[arg1].field_2048) with:
                                       value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) wei
                                         gas 2300 * is_zero(value) wei
                                else:
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) and stor12 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                        revert with 0, 17
                                    if not stor19:
                                        revert with 0, 18
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19:
                                        require ext_code.size(stor13)
                                        call stor13.0xd0e30db0 with:
                                           value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                        if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                                revert with 0, 17
                                            call address(stor10.field_8) with:
                                               value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                                 gas 2300 * is_zero(value) wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                                revert with 0, 17
                                            call stor21 with:
                                               value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                                 gas 2300 * is_zero(value) wei
                                        else:
                                            if not uint8(stor14.field_160):
                                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 and stor11 > -1 / uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19:
                                                    revert with 0, 17
                                                call address(stor10.field_8) with:
                                                   value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100 wei
                                                     gas 2300 * is_zero(value) wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 < uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100:
                                                    revert with 0, 17
                                                call stor21 with:
                                                   value (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 * stor11 / 100) wei
                                                     gas 2300 * is_zero(value) wei
                                            else:
                                                if stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)] > -2:
                                                    revert with 0, 17
                                                stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]++
                                                if stor16[address(stor30[arg1].field_2048)]:
                                                    if stor16[address(stor30[arg1].field_2048)] < 1:
                                                        revert with 0, 17
                                                    stor16[address(stor30[arg1].field_2048)]--
                                                    require ext_code.size(address(stor14.field_0))
                                                    call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(address(stor14.field_0))
                                                call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(address(stor14.field_0))
                                                call address(stor14.field_0).0xd0e30db0 with:
                                                   value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 wei
                                                     gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19 > !(uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19):
                                        revert with 0, 17
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) + (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19):
                                        revert with 0, 17
                                    call address(stor30[arg1].field_2048) with:
                                       value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor17 / stor19) - (uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) * stor12 / stor19) wei
                                         gas 2300 * is_zero(value) wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                sub_3f88d08a[address(stor30[arg1].field_2560)]++
                                sub_3f88d08a[address(stor30[arg1].field_2560)][sub_3f88d08a[address(stor30[arg1].field_2560)]] = arg1
                                if address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0) != address(stor30[arg1].field_2048):
                                    if block.timestamp < stor48:
                                        revert with 0, 17
                                    if block.timestamp - stor48 >= 24 * 3600:
                                        sub_95ddf83a[address(stor30[arg1].field_2560)] = 0
                                        stor48 = block.timestamp
                                    if sub_95ddf83a[address(stor30[arg1].field_2560)] > !uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                        revert with 0, 17
                                    sub_95ddf83a[address(stor30[arg1].field_2560)] += uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                                    if sub_c38694a5[address(stor30[arg1].field_2560)] > !uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                        revert with 0, 17
                                    sub_c38694a5[address(stor30[arg1].field_2560)] += uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                                    if sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > !uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256):
                                        revert with 0, 17
                                    sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] += uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                                    if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) > uint256(stor30[stor52].field_1792):
                                        sub_9b175d77 = arg1
                                    if not uint256(stor30[stor53].field_1792):
                                        sub_362f53ca = arg1
                                    else:
                                        if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < uint256(stor30[stor53].field_1792):
                                            sub_362f53ca = arg1
                                emit 0x9b3dc70a: arg1, uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256)
                            else:
                                if uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) < uint256(stor30[arg1].field_512):
                                    revert with 0, 17
                                call address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0) with:
                                   value uint256(bids[arg1][uint256(bids[arg1].field_0) - 1].field_256) - uint256(stor30[arg1].field_512) wei
                                     gas 2300 * is_zero(value) wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                address(stor30[arg1].field_2304) = address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0)
                                uint256(stor30[arg1].field_1792) = uint256(stor30[arg1].field_512)
                                uint256(stor30[arg1].field_1536) = block.timestamp
                                require ext_code.size(address(stor30[arg1].field_2560))
                                call address(stor30[arg1].field_2560).0x42842e0e with:
                                     gas gas_remaining wei
                                    args this.address, address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), uint256(stor30[arg1].field_256)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if uint256(stor30[arg1].field_512) and stor17 > -1 / uint256(stor30[arg1].field_512):
                                    revert with 0, 17
                                if not stor19:
                                    revert with 0, 18
                                if not uint8(stor14.field_160):
                                    if uint256(stor30[arg1].field_512) * stor17 / stor19:
                                        if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                            if uint256(stor30[arg1].field_512) * stor17 / stor19 and stor11 > -1 / uint256(stor30[arg1].field_512) * stor17 / stor19:
                                                revert with 0, 17
                                            call address(stor10.field_8) with:
                                               value uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100 wei
                                                 gas 2300 * is_zero(value) wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if uint256(stor30[arg1].field_512) * stor17 / stor19 < uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100:
                                                revert with 0, 17
                                            call stor21 with:
                                               value (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100) wei
                                                 gas 2300 * is_zero(value) wei
                                        else:
                                            if not uint8(stor14.field_160):
                                                if uint256(stor30[arg1].field_512) * stor17 / stor19 and stor11 > -1 / uint256(stor30[arg1].field_512) * stor17 / stor19:
                                                    revert with 0, 17
                                                call address(stor10.field_8) with:
                                                   value uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100 wei
                                                     gas 2300 * is_zero(value) wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if uint256(stor30[arg1].field_512) * stor17 / stor19 < uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100:
                                                    revert with 0, 17
                                                call stor21 with:
                                                   value (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100) wei
                                                     gas 2300 * is_zero(value) wei
                                            else:
                                                if stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)] > -2:
                                                    revert with 0, 17
                                                stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]++
                                                if stor16[address(stor30[arg1].field_2048)]:
                                                    if stor16[address(stor30[arg1].field_2048)] < 1:
                                                        revert with 0, 17
                                                    stor16[address(stor30[arg1].field_2048)]--
                                                    require ext_code.size(address(stor14.field_0))
                                                    call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(address(stor14.field_0))
                                                call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(address(stor14.field_0))
                                                call address(stor14.field_0).0xd0e30db0 with:
                                                   value uint256(stor30[arg1].field_512) * stor17 / stor19 wei
                                                     gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    if uint256(stor30[arg1].field_512) * stor17 / stor19 > -1:
                                        revert with 0, 17
                                    if uint256(stor30[arg1].field_512) < uint256(stor30[arg1].field_512) * stor17 / stor19:
                                        revert with 0, 17
                                    call address(stor30[arg1].field_2048) with:
                                       value uint256(stor30[arg1].field_512) - (uint256(stor30[arg1].field_512) * stor17 / stor19) wei
                                         gas 2300 * is_zero(value) wei
                                else:
                                    if uint256(stor30[arg1].field_512) and stor12 > -1 / uint256(stor30[arg1].field_512):
                                        revert with 0, 17
                                    if not stor19:
                                        revert with 0, 18
                                    if uint256(stor30[arg1].field_512) * stor12 / stor19:
                                        require ext_code.size(stor13)
                                        call stor13.0xd0e30db0 with:
                                           value uint256(stor30[arg1].field_512) * stor12 / stor19 wei
                                             gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    if uint256(stor30[arg1].field_512) * stor17 / stor19:
                                        if not stor15[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)]:
                                            if uint256(stor30[arg1].field_512) * stor17 / stor19 and stor11 > -1 / uint256(stor30[arg1].field_512) * stor17 / stor19:
                                                revert with 0, 17
                                            call address(stor10.field_8) with:
                                               value uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100 wei
                                                 gas 2300 * is_zero(value) wei
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            if uint256(stor30[arg1].field_512) * stor17 / stor19 < uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100:
                                                revert with 0, 17
                                            call stor21 with:
                                               value (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100) wei
                                                 gas 2300 * is_zero(value) wei
                                        else:
                                            if not uint8(stor14.field_160):
                                                if uint256(stor30[arg1].field_512) * stor17 / stor19 and stor11 > -1 / uint256(stor30[arg1].field_512) * stor17 / stor19:
                                                    revert with 0, 17
                                                call address(stor10.field_8) with:
                                                   value uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100 wei
                                                     gas 2300 * is_zero(value) wei
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                if uint256(stor30[arg1].field_512) * stor17 / stor19 < uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100:
                                                    revert with 0, 17
                                                call stor21 with:
                                                   value (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor17 / stor19 * stor11 / 100) wei
                                                     gas 2300 * is_zero(value) wei
                                            else:
                                                if stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)] > -2:
                                                    revert with 0, 17
                                                stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]++
                                                if stor16[address(stor30[arg1].field_2048)]:
                                                    if stor16[address(stor30[arg1].field_2048)] < 1:
                                                        revert with 0, 17
                                                    stor16[address(stor30[arg1].field_2048)]--
                                                    require ext_code.size(address(stor14.field_0))
                                                    call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                         gas gas_remaining wei
                                                        args address(stor30[arg1].field_2048), stor16[address(stor30[arg1].field_2048)]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(address(stor14.field_0))
                                                call address(stor14.field_0).setShares(address rg1, uint256 rg2) with:
                                                     gas gas_remaining wei
                                                    args address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0), stor16[address(stor31[arg1][uint256(stor31[arg1].field_0) - 1].field_0)]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require ext_code.size(address(stor14.field_0))
                                                call address(stor14.field_0).0xd0e30db0 with:
                                                   value uint256(stor30[arg1].field_512) * stor17 / stor19 wei
                                                     gas gas_remaining wei
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                    if uint256(stor30[arg1].field_512) * stor17 / stor19 > !(uint256(stor30[arg1].field_512) * stor12 / stor19):
                                        revert with 0, 17
                                    if uint256(stor30[arg1].field_512) < (uint256(stor30[arg1].field_512) * stor17 / stor19) + (uint256(stor30[arg1].field_512) * stor12 / stor19):
                                        revert with 0, 17
                                    call address(stor30[arg1].field_2048) with:
                                       value uint256(stor30[arg1].field_512) - (uint256(stor30[arg1].field_512) * stor17 / stor19) - (uint256(stor30[arg1].field_512) * stor12 / stor19) wei
                                         gas 2300 * is_zero(value) wei
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                sub_3f88d08a[address(stor30[arg1].field_2560)]++
                                sub_3f88d08a[address(stor30[arg1].field_2560)][sub_3f88d08a[address(stor30[arg1].field_2560)]] = arg1
                                if address(bids[arg1][uint256(bids[arg1].field_0) - 1].field_0) != address(stor30[arg1].field_2048):
                                    if block.timestamp < stor48:
                                        revert with 0, 17
                                    if block.timestamp - stor48 >= 24 * 3600:
                                        sub_95ddf83a[address(stor30[arg1].field_2560)] = 0
                                        stor48 = block.timestamp
                                    if sub_95ddf83a[address(stor30[arg1].field_2560)] > !uint256(stor30[arg1].field_512):
                                        revert with 0, 17
                                    sub_95ddf83a[address(stor30[arg1].field_2560)] += uint256(stor30[arg1].field_512)
                                    if sub_c38694a5[address(stor30[arg1].field_2560)] > !uint256(stor30[arg1].field_512):
                                        revert with 0, 17
                                    sub_c38694a5[address(stor30[arg1].field_2560)] += uint256(stor30[arg1].field_512)
                                    if sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] > !uint256(stor30[arg1].field_512):
                                        revert with 0, 17
                                    sub_92f62add[address(stor30[arg1].field_2560)][uint256(stor30[arg1].field_256)] += uint256(stor30[arg1].field_512)
                                    if uint256(stor30[arg1].field_512) > uint256(stor30[stor52].field_1792):
                                        sub_9b175d77 = arg1
                                    if not uint256(stor30[stor53].field_1792):
                                        sub_362f53ca = arg1
                                    else:
                                        if uint256(stor30[arg1].field_512) < uint256(stor30[stor53].field_1792):
                                            sub_362f53ca = arg1
                                emit 0x9b3dc70a: arg1, uint256(stor30[arg1].field_512)
}

function sub_b0ff762a(?) {
    require calldata.size - 4 >= 224
    require cd[164] == address(cd[164])
    require cd[196] <= test266151307()
    require cd[196] + 35 < calldata.size
    require ('cd', 196).length <= test266151307()
    require cd[196] + (32 * ('cd', 196).length) + 36 <= calldata.size
    if not uint8(stor10.field_0):
        revert with 0, 'Market closed'
    if stor27[address(cd[164])]:
        if stor28[address(cd[164])]:
            revert with 0, 'NFT not approved for sale'
        if stor35[address(cd[164])][cd[4]]:
            revert with 0, 'Sale in progress'
        if cd[68] > 0:
            if cd[132] < sub_5cdedc5a:
                revert with 0, 'Auction too short'
            if cd[132] > sub_518b057e:
                revert with 0, 'Auction too long'
            uint256(stor30[stor9].field_0) = stor9
            uint256(stor30[stor9].field_256) = cd[4]
            uint256(stor30[stor9].field_512) = cd[36]
            uint256(stor30[stor9].field_768) = cd[68]
            uint256(stor30[stor9].field_1024) = cd[100]
            if not cd[132]:
                uint256(stor30[stor9].field_1280) = 0
                uint256(stor30[stor9].field_2048) = msg.sender or Mask(96, 160, uint256(stor30[stor9].field_2048))
                address(stor30[stor9].field_2560) = address(cd[164])
                mem[96] = 0xc87b56dd00000000000000000000000000000000000000000000000000000000
                mem[100] = cd[4]
                require ext_code.size(address(cd[164]))
                staticcall address(cd[164]).0xc87b56dd with:
                        gas gas_remaining wei
                       args cd[4]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(return_data.size) + 96
                require return_data.size >= 32
                _131 = mem[96 len 4], Mask(224, 32, cd[4]) >> 32
                require mem[96 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                require return_data.size + 96 > mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 127
                _143 = mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96]
                if mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 1 < 0 or ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97
                mem[ceil32(return_data.size) + 96] = _143
                require _131 + _143 + 32 <= return_data.size
                mem[ceil32(return_data.size) + 128 len ceil32(_143)] = mem[_131 + 128 len ceil32(_143)]
                if ceil32(_143) <= _143:
                    if bool(stor30[stor9].field_2816):
                        if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                            revert with 0, 34
                        if _143:
                            uint256(stor30[stor9][11][].field_0) = Array(len=_143, data=mem[ceil32(return_data.size) + 128 len _143])
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _24071 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24071 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                        else:
                            uint256(stor30[stor9].field_2816) = 0
                            idx = 0
                            while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                uint256(stor30[stor9][idx + 11].field_0) = 0
                                idx = idx + 1
                                continue 
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                    else:
                        if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                            revert with 0, 34
                        if _143:
                            uint256(stor30[stor9][11][].field_0) = Array(len=_143, data=mem[ceil32(return_data.size) + 128 len _143])
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _24075 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24075 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                        else:
                            uint256(stor30[stor9].field_2816) = 0
                            idx = 0
                            while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                uint256(stor30[stor9][idx + 11].field_0) = 0
                                idx = idx + 1
                                continue 
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _19995 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _19995 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                else:
                    mem[_143 + ceil32(return_data.size) + 128] = 0
                    if not bool(stor30[stor9].field_2816):
                        if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                            revert with 0, 34
                        if _143:
                            uint256(stor30[stor9][11][].field_0) = Array(len=_143, data=mem[ceil32(return_data.size) + 128 len _143])
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _24083 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24083 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                        else:
                            uint256(stor30[stor9].field_2816) = 0
                            idx = 0
                            while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                uint256(stor30[stor9][idx + 11].field_0) = 0
                                idx = idx + 1
                                continue 
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                    else:
                        if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                            revert with 0, 34
                        if _143:
                            uint256(stor30[stor9][11][].field_0) = Array(len=_143, data=mem[ceil32(return_data.size) + 128 len _143])
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                        else:
                            uint256(stor30[stor9].field_2816) = 0
                            idx = 0
                            while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                uint256(stor30[stor9][idx + 11].field_0) = 0
                                idx = idx + 1
                                continue 
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _20007 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20007 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
            else:
                if block.timestamp > !cd[132]:
                    revert with 0, 17
                uint256(stor30[stor9].field_1280) = block.timestamp + cd[132]
                uint256(stor30[stor9].field_2048) = msg.sender or Mask(96, 160, uint256(stor30[stor9].field_2048))
                address(stor30[stor9].field_2560) = address(cd[164])
                mem[96] = 0xc87b56dd00000000000000000000000000000000000000000000000000000000
                mem[100] = cd[4]
                require ext_code.size(address(cd[164]))
                staticcall address(cd[164]).0xc87b56dd with:
                        gas gas_remaining wei
                       args cd[4]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(return_data.size) + 96
                require return_data.size >= 32
                _142 = mem[96 len 4], Mask(224, 32, cd[4]) >> 32
                require mem[96 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                require return_data.size + 96 > mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 127
                _153 = mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96]
                if mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 1 < 0 or ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97
                mem[ceil32(return_data.size) + 96] = _153
                require _142 + _153 + 32 <= return_data.size
                mem[ceil32(return_data.size) + 128 len ceil32(_153)] = mem[_142 + 128 len ceil32(_153)]
                if ceil32(_153) <= _153:
                    if not bool(stor30[stor9].field_2816):
                        if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                            revert with 0, 34
                        if _153:
                            uint256(stor30[stor9][11][].field_0) = Array(len=_153, data=mem[ceil32(return_data.size) + 128 len _153])
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _24059 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24059 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                        else:
                            uint256(stor30[stor9].field_2816) = 0
                            idx = 0
                            while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                uint256(stor30[stor9][idx + 11].field_0) = 0
                                idx = idx + 1
                                continue 
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                    else:
                        if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                            revert with 0, 34
                        if _153:
                            uint256(stor30[stor9][11][].field_0) = Array(len=_153, data=mem[ceil32(return_data.size) + 128 len _153])
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _24055 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24055 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                        else:
                            uint256(stor30[stor9].field_2816) = 0
                            idx = 0
                            while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                uint256(stor30[stor9][idx + 11].field_0) = 0
                                idx = idx + 1
                                continue 
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _19935 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _19935 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                else:
                    mem[_153 + ceil32(return_data.size) + 128] = 0
                    if bool(stor30[stor9].field_2816):
                        if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                            revert with 0, 34
                        if _153:
                            uint256(stor30[stor9][11][].field_0) = Array(len=_153, data=mem[ceil32(return_data.size) + 128 len _153])
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _24063 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24063 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                        else:
                            uint256(stor30[stor9].field_2816) = 0
                            idx = 0
                            while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                uint256(stor30[stor9][idx + 11].field_0) = 0
                                idx = idx + 1
                                continue 
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _19959 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _19959 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                    else:
                        if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                            revert with 0, 34
                        if _153:
                            uint256(stor30[stor9][11][].field_0) = Array(len=_153, data=mem[ceil32(return_data.size) + 128 len _153])
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _24067 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24067 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                        else:
                            uint256(stor30[stor9].field_2816) = 0
                            idx = 0
                            while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                uint256(stor30[stor9][idx + 11].field_0) = 0
                                idx = idx + 1
                                continue 
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _19971 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _19971 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
        else:
            if cd[132] <= 0:
                if cd[36] < sub_0f58fa4d:
                    revert with 0, 'Must set purchase price'
                uint256(stor30[stor9].field_0) = stor9
                uint256(stor30[stor9].field_256) = cd[4]
                uint256(stor30[stor9].field_512) = cd[36]
                uint256(stor30[stor9].field_768) = cd[68]
                uint256(stor30[stor9].field_1024) = cd[100]
                if not cd[132]:
                    uint256(stor30[stor9].field_1280) = 0
                    uint256(stor30[stor9].field_2048) = msg.sender or Mask(96, 160, uint256(stor30[stor9].field_2048))
                    address(stor30[stor9].field_2560) = address(cd[164])
                    mem[96] = 0xc87b56dd00000000000000000000000000000000000000000000000000000000
                    mem[100] = cd[4]
                    require ext_code.size(address(cd[164]))
                    staticcall address(cd[164]).0xc87b56dd with:
                            gas gas_remaining wei
                           args cd[4]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    _121 = mem[96 len 4], Mask(224, 32, cd[4]) >> 32
                    require mem[96 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                    require return_data.size + 96 > mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 127
                    _137 = mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96]
                    if mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96] > test266151307():
                        revert with 0, 65
                    if ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 1 < 0 or ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97
                    mem[ceil32(return_data.size) + 96] = _137
                    require _121 + _137 + 32 <= return_data.size
                    mem[ceil32(return_data.size) + 128 len ceil32(_137)] = mem[_121 + 128 len ceil32(_137)]
                    if ceil32(_137) <= _137:
                        if not bool(stor30[stor9].field_2816):
                            if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                                revert with 0, 34
                            if _137:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_137, data=mem[ceil32(return_data.size) + 128 len _137])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24107 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24107 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                        else:
                            if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                                revert with 0, 34
                            if _137:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_137, data=mem[ceil32(return_data.size) + 128 len _137])
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20079 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20079 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                    else:
                        mem[_137 + ceil32(return_data.size) + 128] = 0
                        if bool(stor30[stor9].field_2816):
                            if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                                revert with 0, 34
                            if _137:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_137, data=mem[ceil32(return_data.size) + 128 len _137])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24111 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24111 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20103 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20103 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                        else:
                            if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                                revert with 0, 34
                            if _137:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_137, data=mem[ceil32(return_data.size) + 128 len _137])
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20115 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20115 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                else:
                    if block.timestamp > !cd[132]:
                        revert with 0, 17
                    uint256(stor30[stor9].field_1280) = block.timestamp + cd[132]
                    uint256(stor30[stor9].field_2048) = msg.sender or Mask(96, 160, uint256(stor30[stor9].field_2048))
                    address(stor30[stor9].field_2560) = address(cd[164])
                    mem[96] = 0xc87b56dd00000000000000000000000000000000000000000000000000000000
                    mem[100] = cd[4]
                    require ext_code.size(address(cd[164]))
                    staticcall address(cd[164]).0xc87b56dd with:
                            gas gas_remaining wei
                           args cd[4]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    _136 = mem[96 len 4], Mask(224, 32, cd[4]) >> 32
                    require mem[96 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                    require return_data.size + 96 > mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 127
                    _148 = mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96]
                    if mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96] > test266151307():
                        revert with 0, 65
                    if ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 1 < 0 or ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97
                    mem[ceil32(return_data.size) + 96] = _148
                    require _136 + _148 + 32 <= return_data.size
                    mem[ceil32(return_data.size) + 128 len ceil32(_148)] = mem[_136 + 128 len ceil32(_148)]
                    if ceil32(_148) <= _148:
                        if bool(stor30[stor9].field_2816):
                            if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                                revert with 0, 34
                            if _148:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_148, data=mem[ceil32(return_data.size) + 128 len _148])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24087 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24087 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20031 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20031 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                        else:
                            if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                                revert with 0, 34
                            if _148:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_148, data=mem[ceil32(return_data.size) + 128 len _148])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24091 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24091 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20043 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20043 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                    else:
                        mem[_148 + ceil32(return_data.size) + 128] = 0
                        if bool(stor30[stor9].field_2816):
                            if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                                revert with 0, 34
                            if _148:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_148, data=mem[ceil32(return_data.size) + 128 len _148])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24095 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24095 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                        else:
                            if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                                revert with 0, 34
                            if _148:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_148, data=mem[ceil32(return_data.size) + 128 len _148])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24099 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24099 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20067 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20067 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
            else:
                if cd[132] < sub_5cdedc5a:
                    revert with 0, 'Auction too short'
                if cd[132] > sub_518b057e:
                    revert with 0, 'Auction too long'
                uint256(stor30[stor9].field_0) = stor9
                uint256(stor30[stor9].field_256) = cd[4]
                uint256(stor30[stor9].field_512) = cd[36]
                uint256(stor30[stor9].field_768) = cd[68]
                uint256(stor30[stor9].field_1024) = cd[100]
                if not cd[132]:
                    uint256(stor30[stor9].field_1280) = 0
                    uint256(stor30[stor9].field_2048) = msg.sender or Mask(96, 160, uint256(stor30[stor9].field_2048))
                    address(stor30[stor9].field_2560) = address(cd[164])
                    mem[96] = 0xc87b56dd00000000000000000000000000000000000000000000000000000000
                    mem[100] = cd[4]
                    require ext_code.size(address(cd[164]))
                    staticcall address(cd[164]).0xc87b56dd with:
                            gas gas_remaining wei
                           args cd[4]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    _139 = mem[96 len 4], Mask(224, 32, cd[4]) >> 32
                    require mem[96 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                    require return_data.size + 96 > mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 127
                    _150 = mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96]
                    if mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96] > test266151307():
                        revert with 0, 65
                    if ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 1 < 0 or ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97
                    mem[ceil32(return_data.size) + 96] = _150
                    require _139 + _150 + 32 <= return_data.size
                    mem[ceil32(return_data.size) + 128 len ceil32(_150)] = mem[_139 + 128 len ceil32(_150)]
                    if ceil32(_150) <= _150:
                        if bool(stor30[stor9].field_2816):
                            if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                                revert with 0, 34
                            if _150:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_150, data=mem[ceil32(return_data.size) + 128 len _150])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24135 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24135 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20175 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20175 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                        else:
                            if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                                revert with 0, 34
                            if _150:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_150, data=mem[ceil32(return_data.size) + 128 len _150])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24139 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24139 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20187 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20187 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                    else:
                        mem[_150 + ceil32(return_data.size) + 128] = 0
                        if bool(stor30[stor9].field_2816):
                            if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                                revert with 0, 34
                            if _150:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_150, data=mem[ceil32(return_data.size) + 128 len _150])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24143 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24143 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                        else:
                            if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                                revert with 0, 34
                            if _150:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_150, data=mem[ceil32(return_data.size) + 128 len _150])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24147 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24147 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20211 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20211 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                else:
                    if block.timestamp > !cd[132]:
                        revert with 0, 17
                    uint256(stor30[stor9].field_1280) = block.timestamp + cd[132]
                    uint256(stor30[stor9].field_2048) = msg.sender or Mask(96, 160, uint256(stor30[stor9].field_2048))
                    address(stor30[stor9].field_2560) = address(cd[164])
                    mem[96] = 0xc87b56dd00000000000000000000000000000000000000000000000000000000
                    mem[100] = cd[4]
                    require ext_code.size(address(cd[164]))
                    staticcall address(cd[164]).0xc87b56dd with:
                            gas gas_remaining wei
                           args cd[4]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    _149 = mem[96 len 4], Mask(224, 32, cd[4]) >> 32
                    require mem[96 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                    require return_data.size + 96 > mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 127
                    _158 = mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96]
                    if mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96] > test266151307():
                        revert with 0, 65
                    if ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 1 < 0 or ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97
                    mem[ceil32(return_data.size) + 96] = _158
                    require _149 + _158 + 32 <= return_data.size
                    mem[ceil32(return_data.size) + 128 len ceil32(_158)] = mem[_149 + 128 len ceil32(_158)]
                    if ceil32(_158) <= _158:
                        if bool(stor30[stor9].field_2816):
                            if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                                revert with 0, 34
                            if _158:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_158, data=mem[ceil32(return_data.size) + 128 len _158])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24119 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24119 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                        else:
                            if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                                revert with 0, 34
                            if _158:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_158, data=mem[ceil32(return_data.size) + 128 len _158])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24123 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24123 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20139 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20139 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                    else:
                        mem[_158 + ceil32(return_data.size) + 128] = 0
                        if not bool(stor30[stor9].field_2816):
                            if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                                revert with 0, 34
                            if _158:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_158, data=mem[ceil32(return_data.size) + 128 len _158])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24131 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24131 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                        else:
                            if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                                revert with 0, 34
                            if _158:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_158, data=mem[ceil32(return_data.size) + 128 len _158])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24127 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24127 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20151 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20151 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
    else:
        if uint8(stor29.field_8):
            revert with 0, 'NFT not approved for sale'
        if stor28[address(cd[164])]:
            revert with 0, 'NFT not approved for sale'
        if stor35[address(cd[164])][cd[4]]:
            revert with 0, 'Sale in progress'
        if cd[68] > 0:
            if cd[132] < sub_5cdedc5a:
                revert with 0, 'Auction too short'
            if cd[132] > sub_518b057e:
                revert with 0, 'Auction too long'
            uint256(stor30[stor9].field_0) = stor9
            uint256(stor30[stor9].field_256) = cd[4]
            uint256(stor30[stor9].field_512) = cd[36]
            uint256(stor30[stor9].field_768) = cd[68]
            uint256(stor30[stor9].field_1024) = cd[100]
            if not cd[132]:
                uint256(stor30[stor9].field_1280) = 0
                uint256(stor30[stor9].field_2048) = msg.sender or Mask(96, 160, uint256(stor30[stor9].field_2048))
                address(stor30[stor9].field_2560) = address(cd[164])
                mem[96] = 0xc87b56dd00000000000000000000000000000000000000000000000000000000
                mem[100] = cd[4]
                require ext_code.size(address(cd[164]))
                staticcall address(cd[164]).0xc87b56dd with:
                        gas gas_remaining wei
                       args cd[4]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(return_data.size) + 96
                require return_data.size >= 32
                _141 = mem[96 len 4], Mask(224, 32, cd[4]) >> 32
                require mem[96 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                require return_data.size + 96 > mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 127
                _152 = mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96]
                if mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 1 < 0 or ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97
                mem[ceil32(return_data.size) + 96] = _152
                require _141 + _152 + 32 <= return_data.size
                mem[ceil32(return_data.size) + 128 len ceil32(_152)] = mem[_141 + 128 len ceil32(_152)]
                if ceil32(_152) <= _152:
                    if bool(stor30[stor9].field_2816):
                        if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                            revert with 0, 34
                        if _152:
                            uint256(stor30[stor9][11][].field_0) = Array(len=_152, data=mem[ceil32(return_data.size) + 128 len _152])
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _24167 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24167 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                        else:
                            uint256(stor30[stor9].field_2816) = 0
                            idx = 0
                            while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                uint256(stor30[stor9][idx + 11].field_0) = 0
                                idx = idx + 1
                                continue 
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _20271 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20271 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                    else:
                        if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                            revert with 0, 34
                        if _152:
                            uint256(stor30[stor9][11][].field_0) = Array(len=_152, data=mem[ceil32(return_data.size) + 128 len _152])
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _24171 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24171 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                        else:
                            uint256(stor30[stor9].field_2816) = 0
                            idx = 0
                            while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                uint256(stor30[stor9][idx + 11].field_0) = 0
                                idx = idx + 1
                                continue 
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _20283 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20283 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                else:
                    mem[_152 + ceil32(return_data.size) + 128] = 0
                    if bool(stor30[stor9].field_2816):
                        if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                            revert with 0, 34
                        if _152:
                            uint256(stor30[stor9][11][].field_0) = Array(len=_152, data=mem[ceil32(return_data.size) + 128 len _152])
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _24175 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24175 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                        else:
                            uint256(stor30[stor9].field_2816) = 0
                            idx = 0
                            while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                uint256(stor30[stor9][idx + 11].field_0) = 0
                                idx = idx + 1
                                continue 
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                    else:
                        if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                            revert with 0, 34
                        if _152:
                            uint256(stor30[stor9][11][].field_0) = Array(len=_152, data=mem[ceil32(return_data.size) + 128 len _152])
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _24179 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24179 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                        else:
                            uint256(stor30[stor9].field_2816) = 0
                            idx = 0
                            while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                uint256(stor30[stor9][idx + 11].field_0) = 0
                                idx = idx + 1
                                continue 
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _20307 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20307 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
            else:
                if block.timestamp > !cd[132]:
                    revert with 0, 17
                uint256(stor30[stor9].field_1280) = block.timestamp + cd[132]
                uint256(stor30[stor9].field_2048) = msg.sender or Mask(96, 160, uint256(stor30[stor9].field_2048))
                address(stor30[stor9].field_2560) = address(cd[164])
                mem[96] = 0xc87b56dd00000000000000000000000000000000000000000000000000000000
                mem[100] = cd[4]
                require ext_code.size(address(cd[164]))
                staticcall address(cd[164]).0xc87b56dd with:
                        gas gas_remaining wei
                       args cd[4]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                mem[64] = ceil32(return_data.size) + 96
                require return_data.size >= 32
                _151 = mem[96 len 4], Mask(224, 32, cd[4]) >> 32
                require mem[96 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                require return_data.size + 96 > mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 127
                _159 = mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96]
                if mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96] > test266151307():
                    revert with 0, 65
                if ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 1 < 0 or ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97 > test266151307():
                    revert with 0, 65
                mem[64] = ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97
                mem[ceil32(return_data.size) + 96] = _159
                require _151 + _159 + 32 <= return_data.size
                mem[ceil32(return_data.size) + 128 len ceil32(_159)] = mem[_151 + 128 len ceil32(_159)]
                if ceil32(_159) <= _159:
                    if bool(stor30[stor9].field_2816):
                        if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                            revert with 0, 34
                        if _159:
                            uint256(stor30[stor9][11][].field_0) = Array(len=_159, data=mem[ceil32(return_data.size) + 128 len _159])
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _24151 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24151 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                        else:
                            uint256(stor30[stor9].field_2816) = 0
                            idx = 0
                            while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                uint256(stor30[stor9][idx + 11].field_0) = 0
                                idx = idx + 1
                                continue 
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                    else:
                        if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                            revert with 0, 34
                        if _159:
                            uint256(stor30[stor9][11][].field_0) = Array(len=_159, data=mem[ceil32(return_data.size) + 128 len _159])
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _24155 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24155 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                        else:
                            uint256(stor30[stor9].field_2816) = 0
                            idx = 0
                            while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                uint256(stor30[stor9][idx + 11].field_0) = 0
                                idx = idx + 1
                                continue 
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _20235 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20235 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                else:
                    mem[_159 + ceil32(return_data.size) + 128] = 0
                    if not bool(stor30[stor9].field_2816):
                        if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                            revert with 0, 34
                        if _159:
                            uint256(stor30[stor9][11][].field_0) = Array(len=_159, data=mem[ceil32(return_data.size) + 128 len _159])
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _24163 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24163 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                        else:
                            uint256(stor30[stor9].field_2816) = 0
                            idx = 0
                            while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                uint256(stor30[stor9][idx + 11].field_0) = 0
                                idx = idx + 1
                                continue 
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                    else:
                        if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                            revert with 0, 34
                        if _159:
                            uint256(stor30[stor9][11][].field_0) = Array(len=_159, data=mem[ceil32(return_data.size) + 128 len _159])
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _24159 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24159 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
                        else:
                            uint256(stor30[stor9].field_2816) = 0
                            idx = 0
                            while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                uint256(stor30[stor9][idx + 11].field_0) = 0
                                idx = idx + 1
                                continue 
                            mem[0] = stor9
                            uint256(stor30[stor9].field_3072) = block.timestamp
                            idx = 0
                            while idx < ('cd', 196).length:
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                _20247 = mem[64]
                                mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20247 + -mem[64] + 32])]):
                                    revert with 0, 'Unknown sale tag'
                                mem[32] = 30
                                if idx >= ('cd', 196).length:
                                    revert with 0, 50
                                require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                uint256(stor30[stor9].field_3328)++
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                    else:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                        while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                            uint256(stor[s]) = cd[t]
                                            s = s + 1
                                            t = t + 32
                                            continue 
                                        t = s
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                            uint256(stor[t]) = 0
                                            t = t + 1
                                            continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                    revert with 0, 34
                                mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                        uint256(stor[s]) = 0
                                        s = s + 1
                                        continue 
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                    uint256(stor[s]) = cd[t]
                                    s = s + 1
                                    t = t + 32
                                    continue 
                                t = s
                                while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                    uint256(stor[t]) = 0
                                    t = t + 1
                                    continue 
                                if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                    revert with 0, 17
                                t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                continue 
        else:
            if cd[132] <= 0:
                if cd[36] < sub_0f58fa4d:
                    revert with 0, 'Must set purchase price'
                uint256(stor30[stor9].field_0) = stor9
                uint256(stor30[stor9].field_256) = cd[4]
                uint256(stor30[stor9].field_512) = cd[36]
                uint256(stor30[stor9].field_768) = cd[68]
                uint256(stor30[stor9].field_1024) = cd[100]
                if not cd[132]:
                    uint256(stor30[stor9].field_1280) = 0
                    uint256(stor30[stor9].field_2048) = msg.sender or Mask(96, 160, uint256(stor30[stor9].field_2048))
                    address(stor30[stor9].field_2560) = address(cd[164])
                    mem[96] = 0xc87b56dd00000000000000000000000000000000000000000000000000000000
                    mem[100] = cd[4]
                    require ext_code.size(address(cd[164]))
                    staticcall address(cd[164]).0xc87b56dd with:
                            gas gas_remaining wei
                           args cd[4]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    _133 = mem[96 len 4], Mask(224, 32, cd[4]) >> 32
                    require mem[96 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                    require return_data.size + 96 > mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 127
                    _145 = mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96]
                    if mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96] > test266151307():
                        revert with 0, 65
                    if ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 1 < 0 or ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97
                    mem[ceil32(return_data.size) + 96] = _145
                    require _133 + _145 + 32 <= return_data.size
                    mem[ceil32(return_data.size) + 128 len ceil32(_145)] = mem[_133 + 128 len ceil32(_145)]
                    if ceil32(_145) <= _145:
                        if bool(stor30[stor9].field_2816):
                            if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                                revert with 0, 34
                            if _145:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_145, data=mem[ceil32(return_data.size) + 128 len _145])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24199 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24199 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                        else:
                            if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                                revert with 0, 34
                            if _145:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_145, data=mem[ceil32(return_data.size) + 128 len _145])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24203 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24203 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20379 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20379 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                    else:
                        mem[_145 + ceil32(return_data.size) + 128] = 0
                        if not bool(stor30[stor9].field_2816):
                            if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                                revert with 0, 34
                            if _145:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_145, data=mem[ceil32(return_data.size) + 128 len _145])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24211 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24211 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                        else:
                            if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                                revert with 0, 34
                            if _145:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_145, data=mem[ceil32(return_data.size) + 128 len _145])
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20391 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20391 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                else:
                    if block.timestamp > !cd[132]:
                        revert with 0, 17
                    uint256(stor30[stor9].field_1280) = block.timestamp + cd[132]
                    uint256(stor30[stor9].field_2048) = msg.sender or Mask(96, 160, uint256(stor30[stor9].field_2048))
                    address(stor30[stor9].field_2560) = address(cd[164])
                    mem[96] = 0xc87b56dd00000000000000000000000000000000000000000000000000000000
                    mem[100] = cd[4]
                    require ext_code.size(address(cd[164]))
                    staticcall address(cd[164]).0xc87b56dd with:
                            gas gas_remaining wei
                           args cd[4]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    _144 = mem[96 len 4], Mask(224, 32, cd[4]) >> 32
                    require mem[96 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                    require return_data.size + 96 > mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 127
                    _154 = mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96]
                    if mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96] > test266151307():
                        revert with 0, 65
                    if ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 1 < 0 or ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97
                    mem[ceil32(return_data.size) + 96] = _154
                    require _144 + _154 + 32 <= return_data.size
                    mem[ceil32(return_data.size) + 128 len ceil32(_154)] = mem[_144 + 128 len ceil32(_154)]
                    if ceil32(_154) <= _154:
                        if not bool(stor30[stor9].field_2816):
                            if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                                revert with 0, 34
                            if _154:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_154, data=mem[ceil32(return_data.size) + 128 len _154])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24187 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24187 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                        else:
                            if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                                revert with 0, 34
                            if _154:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_154, data=mem[ceil32(return_data.size) + 128 len _154])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24183 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24183 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20319 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20319 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                    else:
                        mem[_154 + ceil32(return_data.size) + 128] = 0
                        if bool(stor30[stor9].field_2816):
                            if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                                revert with 0, 34
                            if _154:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_154, data=mem[ceil32(return_data.size) + 128 len _154])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24191 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24191 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20343 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20343 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                        else:
                            if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                                revert with 0, 34
                            if _154:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_154, data=mem[ceil32(return_data.size) + 128 len _154])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24195 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24195 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20355 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20355 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
            else:
                if cd[132] < sub_5cdedc5a:
                    revert with 0, 'Auction too short'
                if cd[132] > sub_518b057e:
                    revert with 0, 'Auction too long'
                uint256(stor30[stor9].field_0) = stor9
                uint256(stor30[stor9].field_256) = cd[4]
                uint256(stor30[stor9].field_512) = cd[36]
                uint256(stor30[stor9].field_768) = cd[68]
                uint256(stor30[stor9].field_1024) = cd[100]
                if not cd[132]:
                    uint256(stor30[stor9].field_1280) = 0
                    uint256(stor30[stor9].field_2048) = msg.sender or Mask(96, 160, uint256(stor30[stor9].field_2048))
                    address(stor30[stor9].field_2560) = address(cd[164])
                    mem[96] = 0xc87b56dd00000000000000000000000000000000000000000000000000000000
                    mem[100] = cd[4]
                    require ext_code.size(address(cd[164]))
                    staticcall address(cd[164]).0xc87b56dd with:
                            gas gas_remaining wei
                           args cd[4]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    _147 = mem[96 len 4], Mask(224, 32, cd[4]) >> 32
                    require mem[96 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                    require return_data.size + 96 > mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 127
                    _156 = mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96]
                    if mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96] > test266151307():
                        revert with 0, 65
                    if ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 1 < 0 or ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97
                    mem[ceil32(return_data.size) + 96] = _156
                    require _147 + _156 + 32 <= return_data.size
                    mem[ceil32(return_data.size) + 128 len ceil32(_156)] = mem[_147 + 128 len ceil32(_156)]
                    if ceil32(_156) <= _156:
                        if not bool(stor30[stor9].field_2816):
                            if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                                revert with 0, 34
                            if _156:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_156, data=mem[ceil32(return_data.size) + 128 len _156])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24235 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24235 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                        else:
                            if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                                revert with 0, 34
                            if _156:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_156, data=mem[ceil32(return_data.size) + 128 len _156])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24231 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24231 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20463 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20463 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                    else:
                        mem[_156 + ceil32(return_data.size) + 128] = 0
                        if bool(stor30[stor9].field_2816):
                            if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                                revert with 0, 34
                            if _156:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_156, data=mem[ceil32(return_data.size) + 128 len _156])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24239 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24239 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20487 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20487 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                        else:
                            if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                                revert with 0, 34
                            if _156:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_156, data=mem[ceil32(return_data.size) + 128 len _156])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24243 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24243 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20499 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20499 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                else:
                    if block.timestamp > !cd[132]:
                        revert with 0, 17
                    uint256(stor30[stor9].field_1280) = block.timestamp + cd[132]
                    uint256(stor30[stor9].field_2048) = msg.sender or Mask(96, 160, uint256(stor30[stor9].field_2048))
                    address(stor30[stor9].field_2560) = address(cd[164])
                    mem[96] = 0xc87b56dd00000000000000000000000000000000000000000000000000000000
                    mem[100] = cd[4]
                    require ext_code.size(address(cd[164]))
                    staticcall address(cd[164]).0xc87b56dd with:
                            gas gas_remaining wei
                           args cd[4]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(return_data.size) + 96
                    require return_data.size >= 32
                    _155 = mem[96 len 4], Mask(224, 32, cd[4]) >> 32
                    require mem[96 len 4], Mask(224, 32, cd[4]) >> 32 <= test266151307()
                    require return_data.size + 96 > mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 127
                    _162 = mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96]
                    if mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96] > test266151307():
                        revert with 0, 65
                    if ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 1 < 0 or ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97 > test266151307():
                        revert with 0, 65
                    mem[64] = ceil32(return_data.size) + ceil32(ceil32(mem[mem[96 len 4], Mask(224, 32, cd[4]) >> 32 + 96])) + 97
                    mem[ceil32(return_data.size) + 96] = _162
                    require _155 + _162 + 32 <= return_data.size
                    mem[ceil32(return_data.size) + 128 len ceil32(_162)] = mem[_155 + 128 len ceil32(_162)]
                    if ceil32(_162) <= _162:
                        if bool(stor30[stor9].field_2816):
                            if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                                revert with 0, 34
                            if _162:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_162, data=mem[ceil32(return_data.size) + 128 len _162])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24215 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24215 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20415 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20415 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                        else:
                            if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                                revert with 0, 34
                            if _162:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_162, data=mem[ceil32(return_data.size) + 128 len _162])
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20427 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20427 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                    else:
                        mem[_162 + ceil32(return_data.size) + 128] = 0
                        if bool(stor30[stor9].field_2816):
                            if bool(stor30[stor9].field_2816) == uint255(uint256(stor30[stor9].field_2816)) * 0.5 < 32:
                                revert with 0, 34
                            if _162:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_162, data=mem[ceil32(return_data.size) + 128 len _162])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24223 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24223 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while (uint255(uint256(stor30[stor9].field_2816)) * 0.5) + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not stor41[call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]]:
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                        else:
                            if bool(stor30[stor9].field_2816) == stor30[stor9].field_2817 % 128 < 32:
                                revert with 0, 34
                            if _162:
                                uint256(stor30[stor9][11][].field_0) = Array(len=_162, data=mem[ceil32(return_data.size) + 128 len _162])
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _24227 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _24227 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
                            else:
                                uint256(stor30[stor9].field_2816) = 0
                                idx = 0
                                while stor30[stor9].field_2817 % 128 + 31 / 32 > idx:
                                    uint256(stor30[stor9][idx + 11].field_0) = 0
                                    idx = idx + 1
                                    continue 
                                mem[0] = stor9
                                uint256(stor30[stor9].field_3072) = block.timestamp
                                idx = 0
                                while idx < ('cd', 196).length:
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    _20451 = mem[64]
                                    mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]] = call.data[cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]]
                                    mem[cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + mem[64]] = 41
                                    if not uint8(stor[sha3(mem[mem[64] len cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + _20451 + -mem[64] + 32])]):
                                        revert with 0, 'Unknown sale tag'
                                    mem[32] = 30
                                    if idx >= ('cd', 196).length:
                                        revert with 0, 50
                                    require cd[(cd[196] + (32 * idx) + 36)] < calldata.size + -cd[196] - 67
                                    require cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] <= test266151307()
                                    require cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68 <= calldata.size - cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]
                                    uint256(stor30[stor9].field_3328)++
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0):
                                        if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5 < 32:
                                            revert with 0, 34
                                        mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                        if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > s:
                                                uint256(stor[s]) = 0
                                                s = s + 1
                                                continue 
                                        else:
                                            uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                            s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                            t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                            while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                                uint256(stor[s]) = cd[t]
                                                s = s + 1
                                                t = t + 32
                                                continue 
                                            t = s
                                            while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + ((uint255(uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0)) * 0.5) + 31 / 32) > t:
                                                uint256(stor[t]) = 0
                                                t = t + 1
                                                continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    if bool(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) == stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 < 32:
                                        revert with 0, 34
                                    mem[0] = uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)
                                    if not cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]:
                                        uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = 0
                                        s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                        while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > s:
                                            uint256(stor[s]) = 0
                                            s = s + 1
                                            continue 
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    uint256(stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_0) = (2 * cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)]) + 1
                                    s = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13))
                                    t = cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 68
                                    while cd[196] + cd[(cd[196] + (32 * idx) + 36)] + cd[(cd[196] + cd[(cd[196] + (32 * idx) + 36)] + 36)] + 68 > t:
                                        uint256(stor[s]) = cd[t]
                                        s = s + 1
                                        t = t + 32
                                        continue 
                                    t = s
                                    while sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) > t:
                                        uint256(stor[t]) = 0
                                        t = t + 1
                                        continue 
                                    if sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) == -1:
                                        revert with 0, 17
                                    t = sha3(uint256(stor30[stor9].field_3328) + sha3(sha3(stor9, 30) + 13)) + (stor[uint256(stor30[stor9].field_3328) + ('array', 13, ('map', ('stor', ('name', 'stor9', 9)), ('name', 'stor30', 30)))].field_1 % 128 + 31 / 32) + 1
                                    continue 
    sub_ebbed411[address(cd[164])][cd[4]]++
    sub_ebbed411[address(cd[164])][cd[4]][sub_ebbed411[address(cd[164])][cd[4]]] = stor9
    sub_9f2db3cb[msg.sender]++
    sub_9f2db3cb[msg.sender][sub_9f2db3cb[msg.sender]] = stor9
    stor35[address(cd[164])][cd[4]] = 1
    sub_17cd4006[stor9] = sub_07889cc9.length
    sub_07889cc9.length++
    stor7CD3[stor36.length] = stor9
    if stor9 > -2:
        revert with 0, 17
    stor9++
    require ext_code.size(address(cd[164]))
    call address(cd[164]).0x42842e0e with:
         gas gas_remaining wei
        args msg.sender, this.address, cd[4]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    if not stor39[address(cd[164])]:
        stor39[address(cd[164])] = 1
        sub_b42b22d6.length++
        storE16D[stor40.length] = address(cd[164])
    emit 0xbf266949: stor9, cd[36], cd[68], cd[132]
    return stor9
}



}
